#
# Autogenerated by Thrift Compiler (0.15.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'

module Swcdb
  module Thrift
    module Gen
      module KeySeq
        # Unknown/Unrecognized Type
        UNKNOWN = 0
        # The Lexical Key Order Sequence
        LEXIC = 1
        # The Volumetric Key Order Sequence
        VOLUME = 2
        # The by Fractions Count on Lexical Key Order Sequence
        FC_LEXIC = 3
        # The by Fractions Count on Volumetric Key Order Sequence
        FC_VOLUME = 4
        VALUE_MAP = {0 => "UNKNOWN", 1 => "LEXIC", 2 => "VOLUME", 3 => "FC_LEXIC", 4 => "FC_VOLUME"}
        VALID_VALUES = Set.new([UNKNOWN, LEXIC, VOLUME, FC_LEXIC, FC_VOLUME]).freeze
      end

      module ColumnType
        # Unknown/Unrecognized Type
        UNKNOWN = 0
        # A Plain Column Value
        PLAIN = 1
        # A Counter Column Value with integrity of signed-64bit
        COUNTER_I64 = 2
        # A Counter Column Value with integrity of signed-32bit
        COUNTER_I32 = 3
        # A Counter Column Value with integrity of signed-16bit
        COUNTER_I16 = 4
        # A Counter Column Value with integrity of signed-8bit
        COUNTER_I8 = 5
        # A Serial Column Value
        SERIAL = 6
        # Not used - experimental
        CELL_DEFINED = 15
        VALUE_MAP = {0 => "UNKNOWN", 1 => "PLAIN", 2 => "COUNTER_I64", 3 => "COUNTER_I32", 4 => "COUNTER_I16", 5 => "COUNTER_I8", 6 => "SERIAL", 15 => "CELL_DEFINED"}
        VALID_VALUES = Set.new([UNKNOWN, PLAIN, COUNTER_I64, COUNTER_I32, COUNTER_I16, COUNTER_I8, SERIAL, CELL_DEFINED]).freeze
      end

      module EncodingType
        # Encoding by Ranger DEFAULT configurations
        DEFAULT = 0
        # No Encoding
        PLAIN = 1
        # Encode with zlib
        ZLIB = 2
        # Encode with snappy
        SNAPPY = 3
        # Encode with zstandard
        ZSTD = 4
        # Unrecognized Type
        UNKNOWN = 255
        VALUE_MAP = {0 => "DEFAULT", 1 => "PLAIN", 2 => "ZLIB", 3 => "SNAPPY", 4 => "ZSTD", 255 => "UNKNOWN"}
        VALID_VALUES = Set.new([DEFAULT, PLAIN, ZLIB, SNAPPY, ZSTD, UNKNOWN]).freeze
      end

      module SchemaFunc
        # Create Column Function
        CREATE = 3
        # Delete Column Function
        DELETE = 5
        # Modify Column Function
        MODIFY = 7
        VALUE_MAP = {3 => "CREATE", 5 => "DELETE", 7 => "MODIFY"}
        VALID_VALUES = Set.new([CREATE, DELETE, MODIFY]).freeze
      end

      module Comp
        # [         ]  :   none               (no comparison applied)
        NONE = 0
        # [  =^     ]  :   -pf [prefix]       (starts-with)
        PF = 1
        # [ &gt;    ]  :   -gt                (greater-than)
        GT = 2
        # [ &gt;=   ]  :   -ge                (greater-equal)
        GE = 3
        # [  =      ]  :   -eq                (equal)
        EQ = 4
        # [ &lt;=   ]  :   -le                (lower-equal)
        LE = 5
        # [ &lt;    ]  :   -lt                (lower-than)
        LT = 6
        # [  !=     ]  :   -ne                (not-equal)
        NE = 7
        # [  re     ]  :   -re [r,regexp]     (regular-expression)
        RE = 8
        # [ v&gt;   ]  :   -vgt               (vol greater-than)
        VGT = 9
        # [ v&gt;=  ]  :   -vge               (vol greater-equal)
        VGE = 10
        # [ v&lt;=  ]  :   -vle               (vol lower-equal)
        VLE = 11
        # [ v&lt;   ]  :   -vlt               (vol lower-than)
        VLT = 12
        # [ %&gt;   ]  :   -subset [sbs]      (subset)
        SBS = 13
        # [ &lt;%   ]  :   -supset [sps]      (superset)
        SPS = 14
        # [ ~&gt;   ]  :   -posubset [posbs]  (eq/part ordered subset)
        POSBS = 15
        # [ &lt;~   ]  :   -posupset [posps]  (eq/part ordered superset)
        POSPS = 16
        # [ -&gt;   ]  :   -fosubset [fosbs]  (eq/full ordered subset)
        FOSBS = 17
        # [ &lt;-   ]  :   -fosupset [fosps]  (eq/full ordered superset)
        FOSPS = 18
        VALUE_MAP = {0 => "NONE", 1 => "PF", 2 => "GT", 3 => "GE", 4 => "EQ", 5 => "LE", 6 => "LT", 7 => "NE", 8 => "RE", 9 => "VGT", 10 => "VGE", 11 => "VLE", 12 => "VLT", 13 => "SBS", 14 => "SPS", 15 => "POSBS", 16 => "POSPS", 17 => "FOSBS", 18 => "FOSPS"}
        VALID_VALUES = Set.new([NONE, PF, GT, GE, EQ, LE, LT, NE, RE, VGT, VGE, VLE, VLT, SBS, SPS, POSBS, POSPS, FOSBS, FOSPS]).freeze
      end

      module SpecFlagsOpt
        # No Flag Applied
        NONE = 0
        # Cells Limit by Keys
        LIMIT_BY_KEYS = 1
        # Cells Offset by Keys
        OFFSET_BY_KEYS = 4
        # Select Cells Only Keys without Value data
        ONLY_KEYS = 8
        # Select Cells Only with DELETE(cell-flag)
        ONLY_DELETES = 10
        VALUE_MAP = {0 => "NONE", 1 => "LIMIT_BY_KEYS", 4 => "OFFSET_BY_KEYS", 8 => "ONLY_KEYS", 10 => "ONLY_DELETES"}
        VALID_VALUES = Set.new([NONE, LIMIT_BY_KEYS, OFFSET_BY_KEYS, ONLY_KEYS, ONLY_DELETES]).freeze
      end

      module Flag
        # Unknown/Undefined
        NONE = 0
        # The Cell is an insert
        INSERT = 1
        # The Cell is a delete
        DELETE = 2
        # The Cell is a delete-version
        DELETE_VERSION = 3
        VALUE_MAP = {0 => "NONE", 1 => "INSERT", 2 => "DELETE", 3 => "DELETE_VERSION"}
        VALID_VALUES = Set.new([NONE, INSERT, DELETE, DELETE_VERSION]).freeze
      end

      module CellsResult
        # Correspond to result on Cells (Cells in list)
        IN_LIST = 0
        # Correspond to result on CCells (Columns Cells)
        ON_COLUMN = 1
        # Correspond to result on KCells (Keys Cells)
        ON_KEY = 2
        # Correspond to result on FCells (Fraction Cells)
        ON_FRACTION = 3
        VALUE_MAP = {0 => "IN_LIST", 1 => "ON_COLUMN", 2 => "ON_KEY", 3 => "ON_FRACTION"}
        VALID_VALUES = Set.new([IN_LIST, ON_COLUMN, ON_KEY, ON_FRACTION]).freeze
      end

      class Exception < ::Thrift::Exception; end

      class Schema; end

      class SchemaPattern; end

      class SchemaTagsPatterns; end

      class SchemaPatterns; end

      class SpecSchemas; end

      class SpecFlags; end

      class SpecFraction; end

      class SpecTimestamp; end

      class SpecKeyInterval; end

      class SpecValue; end

      class SpecInterval; end

      class SpecColumn; end

      class SpecValueSerial_INT64; end

      class SpecValueSerial_DOUBLE; end

      class SpecValueSerial_BYTES; end

      class SpecValueSerial_KEY; end

      class SpecValueSerial_LI; end

      class SpecValueSerial_LB; end

      class SpecValueSerialField; end

      class SpecValueSerial; end

      class SpecIntervalSerial; end

      class SpecColumnSerial; end

      class SpecScan; end

      class UCell; end

      class CellValueSerial; end

      class UCellSerial; end

      class Cell; end

      class CellSerial; end

      class Cells; end

      class CCell; end

      class CCellSerial; end

      class ColCells; end

      class KCell; end

      class KCellSerial; end

      class KCells; end

      class FCell; end

      class FCellSerial; end

      class FCells; end

      class CellsGroup; end

      class CompactResult; end

      class Result; end

      # The SWC::Thrift::Exception a base for any Exceptions
# both for the Thrift-Protocol and SWC-DB Errors.
      class Exception < ::Thrift::Exception
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CODE = 1
        MESSAGE = 2

        FIELDS = {
          # The corresponding Thrift-Procotol or SWC-DB Error Code
          CODE => {:type => ::Thrift::Types::I32, :name => 'code'},
          # The message describing the error code
          MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Schema Definition
      class Schema
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CID = 1
        COL_NAME = 2
        COL_TAGS = 3
        COL_SEQ = 4
        COL_TYPE = 5
        CELL_VERSIONS = 6
        CELL_TTL = 7
        BLK_ENCODING = 8
        BLK_SIZE = 9
        BLK_CELLS = 10
        CS_REPLICATION = 11
        CS_SIZE = 12
        CS_MAX = 13
        LOG_ROLLOUT_RATIO = 14
        LOG_COMPACT_COINTERVALING = 15
        LOG_FRAGMENT_PRELOAD = 16
        COMPACT_PERCENT = 17
        REVISION = 18

        FIELDS = {
          # Column ID
          CID => {:type => ::Thrift::Types::I64, :name => 'cid', :optional => true},
          # Column Name
          COL_NAME => {:type => ::Thrift::Types::STRING, :name => 'col_name', :optional => true},
          # Column Tags
          COL_TAGS => {:type => ::Thrift::Types::LIST, :name => 'col_tags', :element => {:type => ::Thrift::Types::STRING}},
          # Column Key Sequence
          COL_SEQ => {:type => ::Thrift::Types::I32, :name => 'col_seq', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::KeySeq},
          # Column Type
          COL_TYPE => {:type => ::Thrift::Types::I32, :name => 'col_type', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::ColumnType},
          # Cell Versions
          CELL_VERSIONS => {:type => ::Thrift::Types::I32, :name => 'cell_versions', :optional => true},
          # Cell Time to Live
          CELL_TTL => {:type => ::Thrift::Types::I32, :name => 'cell_ttl', :optional => true},
          # Block Encoding
          BLK_ENCODING => {:type => ::Thrift::Types::I32, :name => 'blk_encoding', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::EncodingType},
          # Block Size in Bytes
          BLK_SIZE => {:type => ::Thrift::Types::I32, :name => 'blk_size', :optional => true},
          # Number of Cells in Block
          BLK_CELLS => {:type => ::Thrift::Types::I32, :name => 'blk_cells', :optional => true},
          # CellStore file Replication
          CS_REPLICATION => {:type => ::Thrift::Types::BYTE, :name => 'cs_replication', :optional => true},
          # CellStore Size in Bytes
          CS_SIZE => {:type => ::Thrift::Types::I32, :name => 'cs_size', :optional => true},
          # Max CellStores in a Range
          CS_MAX => {:type => ::Thrift::Types::BYTE, :name => 'cs_max', :optional => true},
          # Write Fragment File on ratio reached
          LOG_ROLLOUT_RATIO => {:type => ::Thrift::Types::BYTE, :name => 'log_rollout_ratio', :optional => true},
          # Min. Cointervaling Fragments for Compaction
          LOG_COMPACT_COINTERVALING => {:type => ::Thrift::Types::BYTE, :name => 'log_compact_cointervaling', :optional => true},
          # Number of Fragment to Preload
          LOG_FRAGMENT_PRELOAD => {:type => ::Thrift::Types::BYTE, :name => 'log_fragment_preload', :optional => true},
          # Compact at percent reach
          COMPACT_PERCENT => {:type => ::Thrift::Types::BYTE, :name => 'compact_percent', :optional => true},
          # Schema's revision/id
          REVISION => {:type => ::Thrift::Types::I64, :name => 'revision', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @col_seq.nil? || ::Swcdb::Thrift::Gen::KeySeq::VALID_VALUES.include?(@col_seq)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field col_seq!')
          end
          unless @col_type.nil? || ::Swcdb::Thrift::Gen::ColumnType::VALID_VALUES.include?(@col_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field col_type!')
          end
          unless @blk_encoding.nil? || ::Swcdb::Thrift::Gen::EncodingType::VALID_VALUES.include?(@blk_encoding)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field blk_encoding!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Schema matching Pattern
      class SchemaPattern
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        VALUE = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The patern value to match against
          VALUE => {:type => ::Thrift::Types::STRING, :name => 'value'}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Schema Tags patterns for the SchemaPatterns
      class SchemaTagsPatterns
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        VALUES = 2

        FIELDS = {
          # Logical comparator to Apply, unsupported PF, RE and Vol. kind
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The tags patterns to match against schema's column tags
          VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SchemaPattern}}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Schema Patterns for the SpecSchemas
      class SchemaPatterns
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NAMES = 1
        TAGS = 2

        FIELDS = {
          # The Schema patterns for selecting by Column Name
          NAMES => {:type => ::Thrift::Types::LIST, :name => 'names', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SchemaPattern}},
          # The Schema patterns for selecting by Column Tags
          TAGS => {:type => ::Thrift::Types::STRUCT, :name => 'tags', :class => ::Swcdb::Thrift::Gen::SchemaTagsPatterns}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Specs for Schemas for using with list_columns or compact_columns
      class SpecSchemas
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CIDS = 1
        NAMES = 2
        PATTERNS = 3

        FIELDS = {
          # The Column IDs
          CIDS => {:type => ::Thrift::Types::LIST, :name => 'cids', :element => {:type => ::Thrift::Types::I64}},
          # The Column Names
          NAMES => {:type => ::Thrift::Types::LIST, :name => 'names', :element => {:type => ::Thrift::Types::STRING}},
          # The Schema's selector patterns
          PATTERNS => {:type => ::Thrift::Types::STRUCT, :name => 'patterns', :class => ::Swcdb::Thrift::Gen::SchemaPatterns}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Scan Specifications Flags
      class SpecFlags
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LIMIT = 1
        OFFSET = 2
        MAX_VERSIONS = 3
        MAX_BUFFER = 4
        OPTIONS = 5

        FIELDS = {
          # Limit to this number of cells
          LIMIT => {:type => ::Thrift::Types::I64, :name => 'limit', :optional => true},
          # Scan from this number of cells Offset on matching Cell-Interval
          OFFSET => {:type => ::Thrift::Types::I64, :name => 'offset', :optional => true},
          # Select only this number of Versions of a given Cell-Key
          MAX_VERSIONS => {:type => ::Thrift::Types::I32, :name => 'max_versions', :optional => true},
          # return results with reach of this Buffer size in bytes
          MAX_BUFFER => {:type => ::Thrift::Types::I32, :name => 'max_buffer', :optional => true},
          # The options bit by SpecFlagsOpt
          OPTIONS => {:type => ::Thrift::Types::BYTE, :name => 'options', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Fraction Specifications
      class SpecFraction
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        F = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The binary(bytes) to match against a fraction of a Cell-Key
          F => {:type => ::Thrift::Types::STRING, :name => 'f', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Timestamp Specifications
      class SpecTimestamp
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        TS = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The timestamp in nanoseconds to match against the Cell timestamp/version (not the revision)
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Key Interval Specifications
      class SpecKeyInterval
        include ::Thrift::Struct, ::Thrift::Struct_Union
        START = 1
        FINISH = 2

        FIELDS = {
          # The Key Start Spec, the start of cells-interval key match
          START => {:type => ::Thrift::Types::LIST, :name => 'start', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecFraction}},
          # The Key Finish Spec, the finish of cells-interval key match
          FINISH => {:type => ::Thrift::Types::LIST, :name => 'finish', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecFraction}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Value Specifications, option to use with Extended Logical Comparators
      class SpecValue
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        V = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The binary(bytes) to match against the Cell value
          V => {:type => ::Thrift::Types::STRING, :name => 'v', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Cells Interval Specifications with interval-scope Flags
      class SpecInterval
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RANGE_BEGIN = 1
        RANGE_END = 2
        OFFSET_KEY = 3
        OFFSET_REV = 4
        KEY_INTERVALS = 5
        VALUES = 6
        TS_START = 7
        TS_FINISH = 8
        FLAGS = 9

        FIELDS = {
          # Begin of Ranges evaluation with this Key inclusive
          RANGE_BEGIN => {:type => ::Thrift::Types::LIST, :name => 'range_begin', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # End of Ranges evaluation with this Key inclusive
          RANGE_END => {:type => ::Thrift::Types::LIST, :name => 'range_end', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # Offset Cell Key of a Scan, select cells from this key inclusive
          OFFSET_KEY => {:type => ::Thrift::Types::LIST, :name => 'offset_key', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # Offset Cell Timestamp of a Scan, select cells after this timestamp
          OFFSET_REV => {:type => ::Thrift::Types::I64, :name => 'offset_rev', :optional => true},
          # The Key Intervals
          KEY_INTERVALS => {:type => ::Thrift::Types::LIST, :name => 'key_intervals', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecKeyInterval}},
          # The Cell Value Specifications, cell-value match
          VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecValue}},
          # The Timestamp Start Spec, the start of cells-interval timestamp match
          TS_START => {:type => ::Thrift::Types::STRUCT, :name => 'ts_start', :class => ::Swcdb::Thrift::Gen::SpecTimestamp, :optional => true},
          # The Timestamp Finish Spec, the finish of cells-interval timestamp match
          TS_FINISH => {:type => ::Thrift::Types::STRUCT, :name => 'ts_finish', :class => ::Swcdb::Thrift::Gen::SpecTimestamp, :optional => true},
          # The Interval Flags Specification
          FLAGS => {:type => ::Thrift::Types::STRUCT, :name => 'flags', :class => ::Swcdb::Thrift::Gen::SpecFlags, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Column Specifications, the Cells-Intervals(SpecInterval/s) specification for a column
      class SpecColumn
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CID = 1
        INTERVALS = 2

        FIELDS = {
          # The Column ID
          CID => {:type => ::Thrift::Types::I64, :name => 'cid'},
          # The Cells Interval in a list-container
          INTERVALS => {:type => ::Thrift::Types::LIST, :name => 'intervals', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecInterval}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Specifications of INT64 Serial Value Field
      class SpecValueSerial_INT64
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        V = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The int64 to match against the value field
          V => {:type => ::Thrift::Types::I64, :name => 'v'}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Specifications of DOUBLE Serial Value Field
      class SpecValueSerial_DOUBLE
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        V = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The double to match against the value field
          V => {:type => ::Thrift::Types::DOUBLE, :name => 'v'}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Specifications of BYTES Serial Value Field
      class SpecValueSerial_BYTES
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        V = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The binary(bytes) to match against the value field
          V => {:type => ::Thrift::Types::STRING, :name => 'v', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Specifications of KEY Serial Value Field
      class SpecValueSerial_KEY
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SEQ = 1
        V = 2

        FIELDS = {
          # The Key Sequence to use
          SEQ => {:type => ::Thrift::Types::I32, :name => 'seq', :enum_class => ::Swcdb::Thrift::Gen::KeySeq},
          # The Specification of the Key to match against the value field
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecFraction}}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @seq.nil? || ::Swcdb::Thrift::Gen::KeySeq::VALID_VALUES.include?(@seq)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field seq!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Specifications of LIST_INT64(LI) Serial Value Field
      class SpecValueSerial_LI
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        V = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The List of Int64 to match against the value field
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecValueSerial_INT64}}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Specifications of LIST_BYTES(LB) Serial Value Field
      class SpecValueSerial_LB
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        V = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The List of Bytes to match against the value field
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecValueSerial_BYTES}}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class SpecValueSerialField
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIELD_ID = 1
        SPEC_INT64 = 2
        SPEC_DOUBLE = 3
        SPEC_BYTES = 4
        SPEC_KEY = 5
        SPEC_LI = 6
        SPEC_LB = 7

        FIELDS = {
          # The Field Id of the Value Field
          FIELD_ID => {:type => ::Thrift::Types::I32, :name => 'field_id'},
          # The specifications of Int64 for the field
          SPEC_INT64 => {:type => ::Thrift::Types::STRUCT, :name => 'spec_int64', :class => ::Swcdb::Thrift::Gen::SpecValueSerial_INT64, :optional => true},
          # The specifications of Double for the field
          SPEC_DOUBLE => {:type => ::Thrift::Types::STRUCT, :name => 'spec_double', :class => ::Swcdb::Thrift::Gen::SpecValueSerial_DOUBLE, :optional => true},
          # The specifications of Bytes for the field
          SPEC_BYTES => {:type => ::Thrift::Types::STRUCT, :name => 'spec_bytes', :class => ::Swcdb::Thrift::Gen::SpecValueSerial_BYTES},
          # The specifications of Cell-Key for the field
          SPEC_KEY => {:type => ::Thrift::Types::STRUCT, :name => 'spec_key', :class => ::Swcdb::Thrift::Gen::SpecValueSerial_KEY},
          # The specifications of List Int64 for the field
          SPEC_LI => {:type => ::Thrift::Types::STRUCT, :name => 'spec_li', :class => ::Swcdb::Thrift::Gen::SpecValueSerial_LI},
          # The specifications of List Bytes for the field
          SPEC_LB => {:type => ::Thrift::Types::STRUCT, :name => 'spec_lb', :class => ::Swcdb::Thrift::Gen::SpecValueSerial_LB}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Serial Value Specifications
      class SpecValueSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        FIELDS = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The Serial Value Specifications to match against the SERIAL Cell value fields
          FIELDS => {:type => ::Thrift::Types::LIST, :name => 'fields', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecValueSerialField}}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Serial Value Cells Interval Specifications with interval-scope Flags
      class SpecIntervalSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RANGE_BEGIN = 1
        RANGE_END = 2
        OFFSET_KEY = 3
        OFFSET_REV = 4
        KEY_INTERVALS = 5
        VALUES = 6
        TS_START = 7
        TS_FINISH = 8
        FLAGS = 9

        FIELDS = {
          # Begin of Ranges evaluation with this Key inclusive
          RANGE_BEGIN => {:type => ::Thrift::Types::LIST, :name => 'range_begin', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # End of Ranges evaluation with this Key inclusive
          RANGE_END => {:type => ::Thrift::Types::LIST, :name => 'range_end', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # Offset Cell Key of a Scan, select cells from this key inclusive
          OFFSET_KEY => {:type => ::Thrift::Types::LIST, :name => 'offset_key', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # Offset Cell Timestamp of a Scan, select cells after this timestamp
          OFFSET_REV => {:type => ::Thrift::Types::I64, :name => 'offset_rev', :optional => true},
          # The Key Intervals
          KEY_INTERVALS => {:type => ::Thrift::Types::LIST, :name => 'key_intervals', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecKeyInterval}},
          # The Serial Cell Value Specifications, cell-value fields match
          VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecValueSerial}},
          # The Timestamp Start Spec, the start of cells-interval timestamp match
          TS_START => {:type => ::Thrift::Types::STRUCT, :name => 'ts_start', :class => ::Swcdb::Thrift::Gen::SpecTimestamp, :optional => true},
          # The Timestamp Finish Spec, the finish of cells-interval timestamp match
          TS_FINISH => {:type => ::Thrift::Types::STRUCT, :name => 'ts_finish', :class => ::Swcdb::Thrift::Gen::SpecTimestamp, :optional => true},
          # The Interval Flags Specification
          FLAGS => {:type => ::Thrift::Types::STRUCT, :name => 'flags', :class => ::Swcdb::Thrift::Gen::SpecFlags, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Column Specifications, the Cells-Intervals(SpecInterval/s) specification for a SERIAL Type Column
      class SpecColumnSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CID = 1
        INTERVALS = 2

        FIELDS = {
          # The Column ID
          CID => {:type => ::Thrift::Types::I64, :name => 'cid'},
          # The Serial Cells Interval in a list-container
          INTERVALS => {:type => ::Thrift::Types::LIST, :name => 'intervals', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecIntervalSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Scan Specifications, the Columns-Intervals(SpecColumn/s) with global-scope Flags
      class SpecScan
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COLUMNS = 1
        COLUMNS_SERIAL = 2
        FLAGS = 3

        FIELDS = {
          # The Column Intervals(SpecColumn) in a list-container
          COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecColumn}},
          # The Serial Column Intervals(SpecColumnSerial) in a list-container
          COLUMNS_SERIAL => {:type => ::Thrift::Types::LIST, :name => 'columns_serial', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecColumnSerial}},
          # The Global Flags Specification
          FLAGS => {:type => ::Thrift::Types::STRUCT, :name => 'flags', :class => ::Swcdb::Thrift::Gen::SpecFlags, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Cell data for using with Update
      class UCell
        include ::Thrift::Struct, ::Thrift::Struct_Union
        F = 1
        K = 2
        TS = 3
        TS_DESC = 4
        V = 5
        ENCODER = 6

        FIELDS = {
          # The Cell Flag
          F => {:type => ::Thrift::Types::I32, :name => 'f', :enum_class => ::Swcdb::Thrift::Gen::Flag},
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Cell Timestamp in nanoseconds
          TS => {:type => ::Thrift::Types::I64, :name => 'ts', :optional => true},
          # The Cell Version is in timestamp descending
          TS_DESC => {:type => ::Thrift::Types::BOOL, :name => 'ts_desc', :optional => true},
          # The Cell Value
          V => {:type => ::Thrift::Types::STRING, :name => 'v', :binary => true},
          # Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
          ENCODER => {:type => ::Thrift::Types::I32, :name => 'encoder', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::EncodingType}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @f.nil? || ::Swcdb::Thrift::Gen::Flag::VALID_VALUES.include?(@f)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field f!')
          end
          unless @encoder.nil? || ::Swcdb::Thrift::Gen::EncodingType::VALID_VALUES.include?(@encoder)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field encoder!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Serial Value Cell field
      class CellValueSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIELD_ID = 1
        V_INT64 = 2
        V_DOUBLE = 3
        V_BYTES = 4
        V_KEY = 5
        V_LI = 6
        V_LB = 7

        FIELDS = {
          # The Field ID, a single ID can have any/all the field types
          FIELD_ID => {:type => ::Thrift::Types::I32, :name => 'field_id'},
          # The INT64 type field
          V_INT64 => {:type => ::Thrift::Types::I64, :name => 'v_int64', :optional => true},
          # The DOUBLE type field
          V_DOUBLE => {:type => ::Thrift::Types::DOUBLE, :name => 'v_double', :optional => true},
          # The BYTES type field
          V_BYTES => {:type => ::Thrift::Types::STRING, :name => 'v_bytes', :binary => true},
          # The Cell KEY type field
          V_KEY => {:type => ::Thrift::Types::LIST, :name => 'v_key', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The LIST INT64 type field
          V_LI => {:type => ::Thrift::Types::LIST, :name => 'v_li', :element => {:type => ::Thrift::Types::I64}},
          # The LIST BYTES type field
          V_LB => {:type => ::Thrift::Types::LIST, :name => 'v_lb', :element => {:type => ::Thrift::Types::STRING, :binary => true}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Cell data for using with Update of SERIAL Column Type
      class UCellSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        F = 1
        K = 2
        TS = 3
        TS_DESC = 4
        V = 5
        ENCODER = 6

        FIELDS = {
          # The Cell Flag
          F => {:type => ::Thrift::Types::I32, :name => 'f', :enum_class => ::Swcdb::Thrift::Gen::Flag},
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Cell Timestamp in nanoseconds
          TS => {:type => ::Thrift::Types::I64, :name => 'ts', :optional => true},
          # The Cell Version is in timestamp descending
          TS_DESC => {:type => ::Thrift::Types::BOOL, :name => 'ts_desc', :optional => true},
          # The Serial Cell Value fields
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CellValueSerial}},
          # Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
          ENCODER => {:type => ::Thrift::Types::I32, :name => 'encoder', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::EncodingType}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @f.nil? || ::Swcdb::Thrift::Gen::Flag::VALID_VALUES.include?(@f)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field f!')
          end
          unless @encoder.nil? || ::Swcdb::Thrift::Gen::EncodingType::VALID_VALUES.include?(@encoder)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field encoder!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Cell for results list of scan
      class Cell
        include ::Thrift::Struct, ::Thrift::Struct_Union
        C = 1
        K = 2
        TS = 3
        V = 4

        FIELDS = {
          # The Column Name
          C => {:type => ::Thrift::Types::STRING, :name => 'c'},
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Value
          V => {:type => ::Thrift::Types::STRING, :name => 'v', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Serial Cell for results list of scan
      class CellSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        C = 1
        K = 2
        TS = 3
        V = 4

        FIELDS = {
          # The Column Name
          C => {:type => ::Thrift::Types::STRING, :name => 'c'},
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Serial Value
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CellValueSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Cells for results list of scan
      class Cells
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CELLS = 1
        SERIAL_CELLS = 2

        FIELDS = {
          # The Cells, defined as Cell items in a list-container
          CELLS => {:type => ::Thrift::Types::LIST, :name => 'cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::Cell}},
          # The Serial Cells, defined as CellSerial items in a list-container
          SERIAL_CELLS => {:type => ::Thrift::Types::LIST, :name => 'serial_cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CellSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Column Cell for results on Columns of scan
      class CCell
        include ::Thrift::Struct, ::Thrift::Struct_Union
        K = 1
        TS = 2
        V = 3

        FIELDS = {
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Value
          V => {:type => ::Thrift::Types::STRING, :name => 'v', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Column Serial Cell for results on Columns of scan
      class CCellSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        K = 1
        TS = 2
        V = 3

        FIELDS = {
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Serial Value
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CellValueSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Column Cells for results on Columns of scan
      class ColCells
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CELLS = 1
        SERIAL_CELLS = 2

        FIELDS = {
          # The Cells, defined as CCell items in a list-container
          CELLS => {:type => ::Thrift::Types::LIST, :name => 'cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CCell}},
          # The Serial Cells, defined as CCellSerial items in a list-container
          SERIAL_CELLS => {:type => ::Thrift::Types::LIST, :name => 'serial_cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CCellSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Key Cell for results on Key of scan
      class KCell
        include ::Thrift::Struct, ::Thrift::Struct_Union
        C = 1
        TS = 2
        V = 3

        FIELDS = {
          # The Column Name
          C => {:type => ::Thrift::Types::STRING, :name => 'c'},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Value
          V => {:type => ::Thrift::Types::STRING, :name => 'v', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Key Serial Cell for results on Key of scan
      class KCellSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        C = 1
        TS = 2
        V = 3

        FIELDS = {
          # The Column Name
          C => {:type => ::Thrift::Types::STRING, :name => 'c'},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Serial Value
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CellValueSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Key Cells for results on Key of scan
      class KCells
        include ::Thrift::Struct, ::Thrift::Struct_Union
        K = 1
        CELLS = 2
        SERIAL_CELLS = 3

        FIELDS = {
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Key's Cells, defined as KCell items in a list-container
          CELLS => {:type => ::Thrift::Types::LIST, :name => 'cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::KCell}},
          # The Key's Serial Cells, defined as KCellSerial items in a list-container
          SERIAL_CELLS => {:type => ::Thrift::Types::LIST, :name => 'serial_cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::KCellSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Fraction Cell for results on Fraction of scan
      class FCell
        include ::Thrift::Struct, ::Thrift::Struct_Union
        C = 1
        TS = 2
        V = 3

        FIELDS = {
          # The Column Name
          C => {:type => ::Thrift::Types::STRING, :name => 'c'},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Value
          V => {:type => ::Thrift::Types::STRING, :name => 'v', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Fraction Serial Cell for results on Fraction of scan
      class FCellSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        C = 1
        TS = 2
        V = 3

        FIELDS = {
          # The Column Name
          C => {:type => ::Thrift::Types::STRING, :name => 'c'},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Serial Value
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CellValueSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Fraction Cells for results on Fraction of scan
      class FCells
        include ::Thrift::Struct, ::Thrift::Struct_Union
        F = 1
        CELLS = 2
        SERIAL_CELLS = 3

        FIELDS = {
          # The Fraction Container for the Next Fractions Tree,  defined as FCells items in a map-container by current Fraction bytes
          F => {:type => ::Thrift::Types::MAP, :name => 'f', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::FCells}},
          # The current Fraction's Cells, defined as FCell items in a list-container
          CELLS => {:type => ::Thrift::Types::LIST, :name => 'cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::FCell}},
          # The current Fraction's Serial Cells, defined as FCellSerial items in a list-container
          SERIAL_CELLS => {:type => ::Thrift::Types::LIST, :name => 'serial_cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::FCellSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A Grouped Cells result for results of scan, determined by the request's CellsResult enum
      class CellsGroup
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CELLS = 1
        CCELLS = 2
        KCELLS = 3
        FCELLS = 4

        FIELDS = {
          # The Cells in a list, defined as Cell items in a list-container
          CELLS => {:type => ::Thrift::Types::STRUCT, :name => 'cells', :class => ::Swcdb::Thrift::Gen::Cells},
          # The Columns Cells in a map-container, defined as ColCells items by Column Name
          CCELLS => {:type => ::Thrift::Types::MAP, :name => 'ccells', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::ColCells}},
          # The Keys Cells in a list, defined as kCells items in a list-container
          KCELLS => {:type => ::Thrift::Types::LIST, :name => 'kcells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::KCells}},
          # The Fraction Cells in struct FCells
          FCELLS => {:type => ::Thrift::Types::STRUCT, :name => 'fcells', :class => ::Swcdb::Thrift::Gen::FCells}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Compact Result
      class CompactResult
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CID = 1
        ERR = 2

        FIELDS = {
          # Column ID
          CID => {:type => ::Thrift::Types::I64, :name => 'cid'},
          # Error
          ERR => {:type => ::Thrift::Types::I32, :name => 'err'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Result of 'exec_sql'
      class Result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SCHEMAS = 1
        CELLS = 2
        COMPACT = 3

        FIELDS = {
          # Set with result for 'list columns' query
          SCHEMAS => {:type => ::Thrift::Types::LIST, :name => 'schemas', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::Schema}},
          # Set with result for 'select' query
          CELLS => {:type => ::Thrift::Types::STRUCT, :name => 'cells', :class => ::Swcdb::Thrift::Gen::Cells},
          # Set with result for 'compact columns' query
          COMPACT => {:type => ::Thrift::Types::LIST, :name => 'compact', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CompactResult}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
