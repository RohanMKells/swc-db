/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Service_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace SWC { namespace Thrift {

int _kKeySeqValues[] = {
  /**
   * Unknown/Unrecognized Type
   */
  KeySeq::UNKNOWN,
  /**
   * The Lexical Key Order Sequence
   */
  KeySeq::LEXIC,
  /**
   * The Volumetric Key Order Sequence
   */
  KeySeq::VOLUME,
  /**
   * The by Fractions Count on Lexical Key Order Sequence
   */
  KeySeq::FC_LEXIC,
  /**
   * The by Fractions Count on Volumetric Key Order Sequence
   */
  KeySeq::FC_VOLUME
};
const char* _kKeySeqNames[] = {
  /**
   * Unknown/Unrecognized Type
   */
  "UNKNOWN",
  /**
   * The Lexical Key Order Sequence
   */
  "LEXIC",
  /**
   * The Volumetric Key Order Sequence
   */
  "VOLUME",
  /**
   * The by Fractions Count on Lexical Key Order Sequence
   */
  "FC_LEXIC",
  /**
   * The by Fractions Count on Volumetric Key Order Sequence
   */
  "FC_VOLUME"
};
const std::map<int, const char*> _KeySeq_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kKeySeqValues, _kKeySeqNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const KeySeq::type& val) {
  std::map<int, const char*>::const_iterator it = _KeySeq_VALUES_TO_NAMES.find(val);
  if (it != _KeySeq_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const KeySeq::type& val) {
  std::map<int, const char*>::const_iterator it = _KeySeq_VALUES_TO_NAMES.find(val);
  if (it != _KeySeq_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kColumnTypeValues[] = {
  /**
   * Unknown/Unrecognized Type
   */
  ColumnType::UNKNOWN,
  /**
   * A Plain Column Value
   */
  ColumnType::PLAIN,
  /**
   * A Counter Column Value with integrity of signed-64bit
   */
  ColumnType::COUNTER_I64,
  /**
   * A Counter Column Value with integrity of signed-32bit
   */
  ColumnType::COUNTER_I32,
  /**
   * A Counter Column Value with integrity of signed-16bit
   */
  ColumnType::COUNTER_I16,
  /**
   * A Counter Column Value with integrity of signed-8bit
   */
  ColumnType::COUNTER_I8,
  /**
   * A Serial Column Value
   */
  ColumnType::SERIAL,
  /**
   * Not used - experimental
   */
  ColumnType::CELL_DEFINED
};
const char* _kColumnTypeNames[] = {
  /**
   * Unknown/Unrecognized Type
   */
  "UNKNOWN",
  /**
   * A Plain Column Value
   */
  "PLAIN",
  /**
   * A Counter Column Value with integrity of signed-64bit
   */
  "COUNTER_I64",
  /**
   * A Counter Column Value with integrity of signed-32bit
   */
  "COUNTER_I32",
  /**
   * A Counter Column Value with integrity of signed-16bit
   */
  "COUNTER_I16",
  /**
   * A Counter Column Value with integrity of signed-8bit
   */
  "COUNTER_I8",
  /**
   * A Serial Column Value
   */
  "SERIAL",
  /**
   * Not used - experimental
   */
  "CELL_DEFINED"
};
const std::map<int, const char*> _ColumnType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kColumnTypeValues, _kColumnTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ColumnType::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnType_VALUES_TO_NAMES.find(val);
  if (it != _ColumnType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ColumnType::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnType_VALUES_TO_NAMES.find(val);
  if (it != _ColumnType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kEncodingTypeValues[] = {
  /**
   * Encoding by Ranger DEFAULT configurations
   */
  EncodingType::DEFAULT,
  /**
   * No Encoding
   */
  EncodingType::PLAIN,
  /**
   * Encode with zlib
   */
  EncodingType::ZLIB,
  /**
   * Encode with snappy
   */
  EncodingType::SNAPPY,
  /**
   * Encode with zstandard
   */
  EncodingType::ZSTD,
  /**
   * Unrecognized Type
   */
  EncodingType::UNKNOWN
};
const char* _kEncodingTypeNames[] = {
  /**
   * Encoding by Ranger DEFAULT configurations
   */
  "DEFAULT",
  /**
   * No Encoding
   */
  "PLAIN",
  /**
   * Encode with zlib
   */
  "ZLIB",
  /**
   * Encode with snappy
   */
  "SNAPPY",
  /**
   * Encode with zstandard
   */
  "ZSTD",
  /**
   * Unrecognized Type
   */
  "UNKNOWN"
};
const std::map<int, const char*> _EncodingType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kEncodingTypeValues, _kEncodingTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const EncodingType::type& val) {
  std::map<int, const char*>::const_iterator it = _EncodingType_VALUES_TO_NAMES.find(val);
  if (it != _EncodingType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const EncodingType::type& val) {
  std::map<int, const char*>::const_iterator it = _EncodingType_VALUES_TO_NAMES.find(val);
  if (it != _EncodingType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSchemaFuncValues[] = {
  /**
   * Create Column Function
   */
  SchemaFunc::CREATE,
  /**
   * Delete Column Function
   */
  SchemaFunc::DELETE,
  /**
   * Modify Column Function
   */
  SchemaFunc::MODIFY
};
const char* _kSchemaFuncNames[] = {
  /**
   * Create Column Function
   */
  "CREATE",
  /**
   * Delete Column Function
   */
  "DELETE",
  /**
   * Modify Column Function
   */
  "MODIFY"
};
const std::map<int, const char*> _SchemaFunc_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kSchemaFuncValues, _kSchemaFuncNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SchemaFunc::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaFunc_VALUES_TO_NAMES.find(val);
  if (it != _SchemaFunc_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SchemaFunc::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaFunc_VALUES_TO_NAMES.find(val);
  if (it != _SchemaFunc_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCompValues[] = {
  /**
   * [         ]  :   none               (no comparison applied)
   */
  Comp::NONE,
  /**
   * [  =^     ]  :   -pf [prefix]       (starts-with)
   */
  Comp::PF,
  /**
   * [ &gt;    ]  :   -gt                (greater-than)
   */
  Comp::GT,
  /**
   * [ &gt;=   ]  :   -ge                (greater-equal)
   */
  Comp::GE,
  /**
   * [  =      ]  :   -eq                (equal)
   */
  Comp::EQ,
  /**
   * [ &lt;=   ]  :   -le                (lower-equal)
   */
  Comp::LE,
  /**
   * [ &lt;    ]  :   -lt                (lower-than)
   */
  Comp::LT,
  /**
   * [  !=     ]  :   -ne                (not-equal)
   */
  Comp::NE,
  /**
   * [  re     ]  :   -re [r,regexp]     (regular-expression)
   */
  Comp::RE,
  /**
   * [ v&gt;   ]  :   -vgt               (vol greater-than)
   */
  Comp::VGT,
  /**
   * [ v&gt;=  ]  :   -vge               (vol greater-equal)
   */
  Comp::VGE,
  /**
   * [ v&lt;=  ]  :   -vle               (vol lower-equal)
   */
  Comp::VLE,
  /**
   * [ v&lt;   ]  :   -vlt               (vol lower-than)
   */
  Comp::VLT,
  /**
   * [ %&gt;   ]  :   -subset [sbs]      (subset)
   */
  Comp::SBS,
  /**
   * [ &lt;%   ]  :   -supset [sps]      (superset)
   */
  Comp::SPS,
  /**
   * [ ~&gt;   ]  :   -posubset [posbs]  (eq/part ordered subset)
   */
  Comp::POSBS,
  /**
   * [ &lt;~   ]  :   -posupset [posps]  (eq/part ordered superset)
   */
  Comp::POSPS,
  /**
   * [ -&gt;   ]  :   -fosubset [fosbs]  (eq/full ordered subset)
   */
  Comp::FOSBS,
  /**
   * [ &lt;-   ]  :   -fosupset [fosps]  (eq/full ordered superset)
   */
  Comp::FOSPS
};
const char* _kCompNames[] = {
  /**
   * [         ]  :   none               (no comparison applied)
   */
  "NONE",
  /**
   * [  =^     ]  :   -pf [prefix]       (starts-with)
   */
  "PF",
  /**
   * [ &gt;    ]  :   -gt                (greater-than)
   */
  "GT",
  /**
   * [ &gt;=   ]  :   -ge                (greater-equal)
   */
  "GE",
  /**
   * [  =      ]  :   -eq                (equal)
   */
  "EQ",
  /**
   * [ &lt;=   ]  :   -le                (lower-equal)
   */
  "LE",
  /**
   * [ &lt;    ]  :   -lt                (lower-than)
   */
  "LT",
  /**
   * [  !=     ]  :   -ne                (not-equal)
   */
  "NE",
  /**
   * [  re     ]  :   -re [r,regexp]     (regular-expression)
   */
  "RE",
  /**
   * [ v&gt;   ]  :   -vgt               (vol greater-than)
   */
  "VGT",
  /**
   * [ v&gt;=  ]  :   -vge               (vol greater-equal)
   */
  "VGE",
  /**
   * [ v&lt;=  ]  :   -vle               (vol lower-equal)
   */
  "VLE",
  /**
   * [ v&lt;   ]  :   -vlt               (vol lower-than)
   */
  "VLT",
  /**
   * [ %&gt;   ]  :   -subset [sbs]      (subset)
   */
  "SBS",
  /**
   * [ &lt;%   ]  :   -supset [sps]      (superset)
   */
  "SPS",
  /**
   * [ ~&gt;   ]  :   -posubset [posbs]  (eq/part ordered subset)
   */
  "POSBS",
  /**
   * [ &lt;~   ]  :   -posupset [posps]  (eq/part ordered superset)
   */
  "POSPS",
  /**
   * [ -&gt;   ]  :   -fosubset [fosbs]  (eq/full ordered subset)
   */
  "FOSBS",
  /**
   * [ &lt;-   ]  :   -fosupset [fosps]  (eq/full ordered superset)
   */
  "FOSPS"
};
const std::map<int, const char*> _Comp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(19, _kCompValues, _kCompNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Comp::type& val) {
  std::map<int, const char*>::const_iterator it = _Comp_VALUES_TO_NAMES.find(val);
  if (it != _Comp_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Comp::type& val) {
  std::map<int, const char*>::const_iterator it = _Comp_VALUES_TO_NAMES.find(val);
  if (it != _Comp_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSpecFlagsOptValues[] = {
  /**
   * No Flag Applied
   */
  SpecFlagsOpt::NONE,
  /**
   * Cells Limit by Keys
   */
  SpecFlagsOpt::LIMIT_BY_KEYS,
  /**
   * Cells Offset by Keys
   */
  SpecFlagsOpt::OFFSET_BY_KEYS,
  /**
   * Select Cells Only Keys without Value data
   */
  SpecFlagsOpt::ONLY_KEYS,
  /**
   * Select Cells Only with DELETE(cell-flag)
   */
  SpecFlagsOpt::ONLY_DELETES
};
const char* _kSpecFlagsOptNames[] = {
  /**
   * No Flag Applied
   */
  "NONE",
  /**
   * Cells Limit by Keys
   */
  "LIMIT_BY_KEYS",
  /**
   * Cells Offset by Keys
   */
  "OFFSET_BY_KEYS",
  /**
   * Select Cells Only Keys without Value data
   */
  "ONLY_KEYS",
  /**
   * Select Cells Only with DELETE(cell-flag)
   */
  "ONLY_DELETES"
};
const std::map<int, const char*> _SpecFlagsOpt_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kSpecFlagsOptValues, _kSpecFlagsOptNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SpecFlagsOpt::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecFlagsOpt_VALUES_TO_NAMES.find(val);
  if (it != _SpecFlagsOpt_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SpecFlagsOpt::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecFlagsOpt_VALUES_TO_NAMES.find(val);
  if (it != _SpecFlagsOpt_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFlagValues[] = {
  /**
   * Unknown/Undefined
   */
  Flag::NONE,
  /**
   * The Cell is an insert
   */
  Flag::INSERT,
  /**
   * The Cell is a delete
   */
  Flag::DELETE,
  /**
   * The Cell is a delete-version
   */
  Flag::DELETE_VERSION
};
const char* _kFlagNames[] = {
  /**
   * Unknown/Undefined
   */
  "NONE",
  /**
   * The Cell is an insert
   */
  "INSERT",
  /**
   * The Cell is a delete
   */
  "DELETE",
  /**
   * The Cell is a delete-version
   */
  "DELETE_VERSION"
};
const std::map<int, const char*> _Flag_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kFlagValues, _kFlagNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Flag::type& val) {
  std::map<int, const char*>::const_iterator it = _Flag_VALUES_TO_NAMES.find(val);
  if (it != _Flag_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Flag::type& val) {
  std::map<int, const char*>::const_iterator it = _Flag_VALUES_TO_NAMES.find(val);
  if (it != _Flag_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCellsResultValues[] = {
  /**
   * Correspond to result on Cells (Cells in list)
   */
  CellsResult::IN_LIST,
  /**
   * Correspond to result on CCells (Columns Cells)
   */
  CellsResult::ON_COLUMN,
  /**
   * Correspond to result on KCells (Keys Cells)
   */
  CellsResult::ON_KEY,
  /**
   * Correspond to result on FCells (Fraction Cells)
   */
  CellsResult::ON_FRACTION
};
const char* _kCellsResultNames[] = {
  /**
   * Correspond to result on Cells (Cells in list)
   */
  "IN_LIST",
  /**
   * Correspond to result on CCells (Columns Cells)
   */
  "ON_COLUMN",
  /**
   * Correspond to result on KCells (Keys Cells)
   */
  "ON_KEY",
  /**
   * Correspond to result on FCells (Fraction Cells)
   */
  "ON_FRACTION"
};
const std::map<int, const char*> _CellsResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kCellsResultValues, _kCellsResultNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const CellsResult::type& val) {
  std::map<int, const char*>::const_iterator it = _CellsResult_VALUES_TO_NAMES.find(val);
  if (it != _CellsResult_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CellsResult::type& val) {
  std::map<int, const char*>::const_iterator it = _CellsResult_VALUES_TO_NAMES.find(val);
  if (it != _CellsResult_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Exception::~Exception() noexcept {
}


void Exception::__set_code(const int32_t val) {
  this->code = val;
}

void Exception::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const Exception& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Exception::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Exception::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Exception");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Exception &a, Exception &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

Exception::Exception(const Exception& other0) : TException() {
  code = other0.code;
  message = other0.message;
  __isset = other0.__isset;
}
Exception::Exception(Exception&& other1) noexcept : TException() {
  code = other1.code;
  message = std::move(other1.message);
  __isset = other1.__isset;
}
Exception& Exception::operator=(const Exception& other2) {
  code = other2.code;
  message = other2.message;
  __isset = other2.__isset;
  return *this;
}
Exception& Exception::operator=(Exception&& other3) noexcept {
  code = other3.code;
  message = std::move(other3.message);
  __isset = other3.__isset;
  return *this;
}
void Exception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Exception(";
  out << "code=" << to_string(code);
  out << ", " << "message=" << to_string(message);
  out << ")";
}

const char* Exception::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: Exception";
  }
}


Schema::~Schema() noexcept {
}


void Schema::__set_cid(const int64_t val) {
  this->cid = val;
__isset.cid = true;
}

void Schema::__set_col_name(const std::string& val) {
  this->col_name = val;
__isset.col_name = true;
}

void Schema::__set_col_seq(const KeySeq::type val) {
  this->col_seq = val;
__isset.col_seq = true;
}

void Schema::__set_col_type(const ColumnType::type val) {
  this->col_type = val;
__isset.col_type = true;
}

void Schema::__set_cell_versions(const int32_t val) {
  this->cell_versions = val;
__isset.cell_versions = true;
}

void Schema::__set_cell_ttl(const int32_t val) {
  this->cell_ttl = val;
__isset.cell_ttl = true;
}

void Schema::__set_blk_encoding(const EncodingType::type val) {
  this->blk_encoding = val;
__isset.blk_encoding = true;
}

void Schema::__set_blk_size(const int32_t val) {
  this->blk_size = val;
__isset.blk_size = true;
}

void Schema::__set_blk_cells(const int32_t val) {
  this->blk_cells = val;
__isset.blk_cells = true;
}

void Schema::__set_cs_replication(const int8_t val) {
  this->cs_replication = val;
__isset.cs_replication = true;
}

void Schema::__set_cs_size(const int32_t val) {
  this->cs_size = val;
__isset.cs_size = true;
}

void Schema::__set_cs_max(const int8_t val) {
  this->cs_max = val;
__isset.cs_max = true;
}

void Schema::__set_log_rollout_ratio(const int8_t val) {
  this->log_rollout_ratio = val;
__isset.log_rollout_ratio = true;
}

void Schema::__set_log_compact_cointervaling(const int8_t val) {
  this->log_compact_cointervaling = val;
__isset.log_compact_cointervaling = true;
}

void Schema::__set_log_fragment_preload(const int8_t val) {
  this->log_fragment_preload = val;
__isset.log_fragment_preload = true;
}

void Schema::__set_compact_percent(const int8_t val) {
  this->compact_percent = val;
__isset.compact_percent = true;
}

void Schema::__set_revision(const int64_t val) {
  this->revision = val;
__isset.revision = true;
}
std::ostream& operator<<(std::ostream& out, const Schema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Schema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col_name);
          this->__isset.col_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->col_seq = static_cast<KeySeq::type>(ecast4);
          this->__isset.col_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->col_type = static_cast<ColumnType::type>(ecast5);
          this->__isset.col_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_versions);
          this->__isset.cell_versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_ttl);
          this->__isset.cell_ttl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast6;
          xfer += iprot->readI32(ecast6);
          this->blk_encoding = static_cast<EncodingType::type>(ecast6);
          this->__isset.blk_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blk_size);
          this->__isset.blk_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blk_cells);
          this->__isset.blk_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->cs_replication);
          this->__isset.cs_replication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cs_size);
          this->__isset.cs_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->cs_max);
          this->__isset.cs_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->log_rollout_ratio);
          this->__isset.log_rollout_ratio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->log_compact_cointervaling);
          this->__isset.log_compact_cointervaling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->log_fragment_preload);
          this->__isset.log_fragment_preload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->compact_percent);
          this->__isset.compact_percent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Schema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Schema");

  if (this->__isset.cid) {
    xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->cid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_name) {
    xfer += oprot->writeFieldBegin("col_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->col_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_seq) {
    xfer += oprot->writeFieldBegin("col_seq", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(static_cast<int32_t>(this->col_seq));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_type) {
    xfer += oprot->writeFieldBegin("col_type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->col_type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_versions) {
    xfer += oprot->writeFieldBegin("cell_versions", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->cell_versions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_ttl) {
    xfer += oprot->writeFieldBegin("cell_ttl", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->cell_ttl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_encoding) {
    xfer += oprot->writeFieldBegin("blk_encoding", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(static_cast<int32_t>(this->blk_encoding));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_size) {
    xfer += oprot->writeFieldBegin("blk_size", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->blk_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_cells) {
    xfer += oprot->writeFieldBegin("blk_cells", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->blk_cells);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_replication) {
    xfer += oprot->writeFieldBegin("cs_replication", ::apache::thrift::protocol::T_BYTE, 10);
    xfer += oprot->writeByte(this->cs_replication);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_size) {
    xfer += oprot->writeFieldBegin("cs_size", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->cs_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_max) {
    xfer += oprot->writeFieldBegin("cs_max", ::apache::thrift::protocol::T_BYTE, 12);
    xfer += oprot->writeByte(this->cs_max);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.log_rollout_ratio) {
    xfer += oprot->writeFieldBegin("log_rollout_ratio", ::apache::thrift::protocol::T_BYTE, 13);
    xfer += oprot->writeByte(this->log_rollout_ratio);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.log_compact_cointervaling) {
    xfer += oprot->writeFieldBegin("log_compact_cointervaling", ::apache::thrift::protocol::T_BYTE, 14);
    xfer += oprot->writeByte(this->log_compact_cointervaling);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.log_fragment_preload) {
    xfer += oprot->writeFieldBegin("log_fragment_preload", ::apache::thrift::protocol::T_BYTE, 15);
    xfer += oprot->writeByte(this->log_fragment_preload);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compact_percent) {
    xfer += oprot->writeFieldBegin("compact_percent", ::apache::thrift::protocol::T_BYTE, 16);
    xfer += oprot->writeByte(this->compact_percent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.revision) {
    xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 17);
    xfer += oprot->writeI64(this->revision);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Schema &a, Schema &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.col_name, b.col_name);
  swap(a.col_seq, b.col_seq);
  swap(a.col_type, b.col_type);
  swap(a.cell_versions, b.cell_versions);
  swap(a.cell_ttl, b.cell_ttl);
  swap(a.blk_encoding, b.blk_encoding);
  swap(a.blk_size, b.blk_size);
  swap(a.blk_cells, b.blk_cells);
  swap(a.cs_replication, b.cs_replication);
  swap(a.cs_size, b.cs_size);
  swap(a.cs_max, b.cs_max);
  swap(a.log_rollout_ratio, b.log_rollout_ratio);
  swap(a.log_compact_cointervaling, b.log_compact_cointervaling);
  swap(a.log_fragment_preload, b.log_fragment_preload);
  swap(a.compact_percent, b.compact_percent);
  swap(a.revision, b.revision);
  swap(a.__isset, b.__isset);
}

Schema::Schema(const Schema& other7) {
  cid = other7.cid;
  col_name = other7.col_name;
  col_seq = other7.col_seq;
  col_type = other7.col_type;
  cell_versions = other7.cell_versions;
  cell_ttl = other7.cell_ttl;
  blk_encoding = other7.blk_encoding;
  blk_size = other7.blk_size;
  blk_cells = other7.blk_cells;
  cs_replication = other7.cs_replication;
  cs_size = other7.cs_size;
  cs_max = other7.cs_max;
  log_rollout_ratio = other7.log_rollout_ratio;
  log_compact_cointervaling = other7.log_compact_cointervaling;
  log_fragment_preload = other7.log_fragment_preload;
  compact_percent = other7.compact_percent;
  revision = other7.revision;
  __isset = other7.__isset;
}
Schema::Schema(Schema&& other8) noexcept {
  cid = other8.cid;
  col_name = std::move(other8.col_name);
  col_seq = other8.col_seq;
  col_type = other8.col_type;
  cell_versions = other8.cell_versions;
  cell_ttl = other8.cell_ttl;
  blk_encoding = other8.blk_encoding;
  blk_size = other8.blk_size;
  blk_cells = other8.blk_cells;
  cs_replication = other8.cs_replication;
  cs_size = other8.cs_size;
  cs_max = other8.cs_max;
  log_rollout_ratio = other8.log_rollout_ratio;
  log_compact_cointervaling = other8.log_compact_cointervaling;
  log_fragment_preload = other8.log_fragment_preload;
  compact_percent = other8.compact_percent;
  revision = other8.revision;
  __isset = other8.__isset;
}
Schema& Schema::operator=(const Schema& other9) {
  cid = other9.cid;
  col_name = other9.col_name;
  col_seq = other9.col_seq;
  col_type = other9.col_type;
  cell_versions = other9.cell_versions;
  cell_ttl = other9.cell_ttl;
  blk_encoding = other9.blk_encoding;
  blk_size = other9.blk_size;
  blk_cells = other9.blk_cells;
  cs_replication = other9.cs_replication;
  cs_size = other9.cs_size;
  cs_max = other9.cs_max;
  log_rollout_ratio = other9.log_rollout_ratio;
  log_compact_cointervaling = other9.log_compact_cointervaling;
  log_fragment_preload = other9.log_fragment_preload;
  compact_percent = other9.compact_percent;
  revision = other9.revision;
  __isset = other9.__isset;
  return *this;
}
Schema& Schema::operator=(Schema&& other10) noexcept {
  cid = other10.cid;
  col_name = std::move(other10.col_name);
  col_seq = other10.col_seq;
  col_type = other10.col_type;
  cell_versions = other10.cell_versions;
  cell_ttl = other10.cell_ttl;
  blk_encoding = other10.blk_encoding;
  blk_size = other10.blk_size;
  blk_cells = other10.blk_cells;
  cs_replication = other10.cs_replication;
  cs_size = other10.cs_size;
  cs_max = other10.cs_max;
  log_rollout_ratio = other10.log_rollout_ratio;
  log_compact_cointervaling = other10.log_compact_cointervaling;
  log_fragment_preload = other10.log_fragment_preload;
  compact_percent = other10.compact_percent;
  revision = other10.revision;
  __isset = other10.__isset;
  return *this;
}
void Schema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Schema(";
  out << "cid="; (__isset.cid ? (out << to_string(cid)) : (out << "<null>"));
  out << ", " << "col_name="; (__isset.col_name ? (out << to_string(col_name)) : (out << "<null>"));
  out << ", " << "col_seq="; (__isset.col_seq ? (out << to_string(col_seq)) : (out << "<null>"));
  out << ", " << "col_type="; (__isset.col_type ? (out << to_string(col_type)) : (out << "<null>"));
  out << ", " << "cell_versions="; (__isset.cell_versions ? (out << to_string(cell_versions)) : (out << "<null>"));
  out << ", " << "cell_ttl="; (__isset.cell_ttl ? (out << to_string(cell_ttl)) : (out << "<null>"));
  out << ", " << "blk_encoding="; (__isset.blk_encoding ? (out << to_string(blk_encoding)) : (out << "<null>"));
  out << ", " << "blk_size="; (__isset.blk_size ? (out << to_string(blk_size)) : (out << "<null>"));
  out << ", " << "blk_cells="; (__isset.blk_cells ? (out << to_string(blk_cells)) : (out << "<null>"));
  out << ", " << "cs_replication="; (__isset.cs_replication ? (out << to_string(cs_replication)) : (out << "<null>"));
  out << ", " << "cs_size="; (__isset.cs_size ? (out << to_string(cs_size)) : (out << "<null>"));
  out << ", " << "cs_max="; (__isset.cs_max ? (out << to_string(cs_max)) : (out << "<null>"));
  out << ", " << "log_rollout_ratio="; (__isset.log_rollout_ratio ? (out << to_string(log_rollout_ratio)) : (out << "<null>"));
  out << ", " << "log_compact_cointervaling="; (__isset.log_compact_cointervaling ? (out << to_string(log_compact_cointervaling)) : (out << "<null>"));
  out << ", " << "log_fragment_preload="; (__isset.log_fragment_preload ? (out << to_string(log_fragment_preload)) : (out << "<null>"));
  out << ", " << "compact_percent="; (__isset.compact_percent ? (out << to_string(compact_percent)) : (out << "<null>"));
  out << ", " << "revision="; (__isset.revision ? (out << to_string(revision)) : (out << "<null>"));
  out << ")";
}


SchemaPattern::~SchemaPattern() noexcept {
}


void SchemaPattern::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SchemaPattern::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const SchemaPattern& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaPattern::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast11;
          xfer += iprot->readI32(ecast11);
          this->comp = static_cast<Comp::type>(ecast11);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaPattern::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaPattern");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaPattern &a, SchemaPattern &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

SchemaPattern::SchemaPattern(const SchemaPattern& other12) {
  comp = other12.comp;
  value = other12.value;
  __isset = other12.__isset;
}
SchemaPattern::SchemaPattern(SchemaPattern&& other13) noexcept {
  comp = other13.comp;
  value = std::move(other13.value);
  __isset = other13.__isset;
}
SchemaPattern& SchemaPattern::operator=(const SchemaPattern& other14) {
  comp = other14.comp;
  value = other14.value;
  __isset = other14.__isset;
  return *this;
}
SchemaPattern& SchemaPattern::operator=(SchemaPattern&& other15) noexcept {
  comp = other15.comp;
  value = std::move(other15.value);
  __isset = other15.__isset;
  return *this;
}
void SchemaPattern::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaPattern(";
  out << "comp=" << to_string(comp);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


SpecSchemas::~SpecSchemas() noexcept {
}


void SpecSchemas::__set_cids(const std::vector<int64_t> & val) {
  this->cids = val;
}

void SpecSchemas::__set_names(const std::vector<std::string> & val) {
  this->names = val;
}

void SpecSchemas::__set_patterns(const std::vector<SchemaPattern> & val) {
  this->patterns = val;
}
std::ostream& operator<<(std::ostream& out, const SpecSchemas& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecSchemas::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cids.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->cids.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += iprot->readI64(this->cids[_i20]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->names.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += iprot->readString(this->names[_i25]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->patterns.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->patterns.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->patterns[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.patterns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecSchemas::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecSchemas");

  xfer += oprot->writeFieldBegin("cids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->cids.size()));
    std::vector<int64_t> ::const_iterator _iter31;
    for (_iter31 = this->cids.begin(); _iter31 != this->cids.end(); ++_iter31)
    {
      xfer += oprot->writeI64((*_iter31));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
    std::vector<std::string> ::const_iterator _iter32;
    for (_iter32 = this->names.begin(); _iter32 != this->names.end(); ++_iter32)
    {
      xfer += oprot->writeString((*_iter32));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("patterns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->patterns.size()));
    std::vector<SchemaPattern> ::const_iterator _iter33;
    for (_iter33 = this->patterns.begin(); _iter33 != this->patterns.end(); ++_iter33)
    {
      xfer += (*_iter33).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecSchemas &a, SpecSchemas &b) {
  using ::std::swap;
  swap(a.cids, b.cids);
  swap(a.names, b.names);
  swap(a.patterns, b.patterns);
  swap(a.__isset, b.__isset);
}

SpecSchemas::SpecSchemas(const SpecSchemas& other34) {
  cids = other34.cids;
  names = other34.names;
  patterns = other34.patterns;
  __isset = other34.__isset;
}
SpecSchemas::SpecSchemas(SpecSchemas&& other35) noexcept {
  cids = std::move(other35.cids);
  names = std::move(other35.names);
  patterns = std::move(other35.patterns);
  __isset = other35.__isset;
}
SpecSchemas& SpecSchemas::operator=(const SpecSchemas& other36) {
  cids = other36.cids;
  names = other36.names;
  patterns = other36.patterns;
  __isset = other36.__isset;
  return *this;
}
SpecSchemas& SpecSchemas::operator=(SpecSchemas&& other37) noexcept {
  cids = std::move(other37.cids);
  names = std::move(other37.names);
  patterns = std::move(other37.patterns);
  __isset = other37.__isset;
  return *this;
}
void SpecSchemas::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecSchemas(";
  out << "cids=" << to_string(cids);
  out << ", " << "names=" << to_string(names);
  out << ", " << "patterns=" << to_string(patterns);
  out << ")";
}


SpecFlags::~SpecFlags() noexcept {
}


void SpecFlags::__set_limit(const int64_t val) {
  this->limit = val;
__isset.limit = true;
}

void SpecFlags::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}

void SpecFlags::__set_max_versions(const int32_t val) {
  this->max_versions = val;
__isset.max_versions = true;
}

void SpecFlags::__set_max_buffer(const int32_t val) {
  this->max_buffer = val;
__isset.max_buffer = true;
}

void SpecFlags::__set_options(const int8_t val) {
  this->options = val;
__isset.options = true;
}
std::ostream& operator<<(std::ostream& out, const SpecFlags& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecFlags::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_versions);
          this->__isset.max_versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_buffer);
          this->__isset.max_buffer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->options);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecFlags::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecFlags");

  if (this->__isset.limit) {
    xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_versions) {
    xfer += oprot->writeFieldBegin("max_versions", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->max_versions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_buffer) {
    xfer += oprot->writeFieldBegin("max_buffer", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->max_buffer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_BYTE, 5);
    xfer += oprot->writeByte(this->options);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecFlags &a, SpecFlags &b) {
  using ::std::swap;
  swap(a.limit, b.limit);
  swap(a.offset, b.offset);
  swap(a.max_versions, b.max_versions);
  swap(a.max_buffer, b.max_buffer);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

SpecFlags::SpecFlags(const SpecFlags& other38) noexcept {
  limit = other38.limit;
  offset = other38.offset;
  max_versions = other38.max_versions;
  max_buffer = other38.max_buffer;
  options = other38.options;
  __isset = other38.__isset;
}
SpecFlags::SpecFlags(SpecFlags&& other39) noexcept {
  limit = other39.limit;
  offset = other39.offset;
  max_versions = other39.max_versions;
  max_buffer = other39.max_buffer;
  options = other39.options;
  __isset = other39.__isset;
}
SpecFlags& SpecFlags::operator=(const SpecFlags& other40) noexcept {
  limit = other40.limit;
  offset = other40.offset;
  max_versions = other40.max_versions;
  max_buffer = other40.max_buffer;
  options = other40.options;
  __isset = other40.__isset;
  return *this;
}
SpecFlags& SpecFlags::operator=(SpecFlags&& other41) noexcept {
  limit = other41.limit;
  offset = other41.offset;
  max_versions = other41.max_versions;
  max_buffer = other41.max_buffer;
  options = other41.options;
  __isset = other41.__isset;
  return *this;
}
void SpecFlags::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecFlags(";
  out << "limit="; (__isset.limit ? (out << to_string(limit)) : (out << "<null>"));
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ", " << "max_versions="; (__isset.max_versions ? (out << to_string(max_versions)) : (out << "<null>"));
  out << ", " << "max_buffer="; (__isset.max_buffer ? (out << to_string(max_buffer)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ")";
}


SpecFraction::~SpecFraction() noexcept {
}


void SpecFraction::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecFraction::__set_f(const std::string& val) {
  this->f = val;
}
std::ostream& operator<<(std::ostream& out, const SpecFraction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecFraction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast42;
          xfer += iprot->readI32(ecast42);
          this->comp = static_cast<Comp::type>(ecast42);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->f);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecFraction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecFraction");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->f);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecFraction &a, SpecFraction &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.f, b.f);
  swap(a.__isset, b.__isset);
}

SpecFraction::SpecFraction(const SpecFraction& other43) {
  comp = other43.comp;
  f = other43.f;
  __isset = other43.__isset;
}
SpecFraction::SpecFraction(SpecFraction&& other44) noexcept {
  comp = other44.comp;
  f = std::move(other44.f);
  __isset = other44.__isset;
}
SpecFraction& SpecFraction::operator=(const SpecFraction& other45) {
  comp = other45.comp;
  f = other45.f;
  __isset = other45.__isset;
  return *this;
}
SpecFraction& SpecFraction::operator=(SpecFraction&& other46) noexcept {
  comp = other46.comp;
  f = std::move(other46.f);
  __isset = other46.__isset;
  return *this;
}
void SpecFraction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecFraction(";
  out << "comp=" << to_string(comp);
  out << ", " << "f=" << to_string(f);
  out << ")";
}


SpecTimestamp::~SpecTimestamp() noexcept {
}


void SpecTimestamp::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecTimestamp::__set_ts(const int64_t val) {
  this->ts = val;
}
std::ostream& operator<<(std::ostream& out, const SpecTimestamp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecTimestamp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast47;
          xfer += iprot->readI32(ecast47);
          this->comp = static_cast<Comp::type>(ecast47);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecTimestamp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecTimestamp");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecTimestamp &a, SpecTimestamp &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.ts, b.ts);
  swap(a.__isset, b.__isset);
}

SpecTimestamp::SpecTimestamp(const SpecTimestamp& other48) noexcept {
  comp = other48.comp;
  ts = other48.ts;
  __isset = other48.__isset;
}
SpecTimestamp::SpecTimestamp(SpecTimestamp&& other49) noexcept {
  comp = other49.comp;
  ts = other49.ts;
  __isset = other49.__isset;
}
SpecTimestamp& SpecTimestamp::operator=(const SpecTimestamp& other50) noexcept {
  comp = other50.comp;
  ts = other50.ts;
  __isset = other50.__isset;
  return *this;
}
SpecTimestamp& SpecTimestamp::operator=(SpecTimestamp&& other51) noexcept {
  comp = other51.comp;
  ts = other51.ts;
  __isset = other51.__isset;
  return *this;
}
void SpecTimestamp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecTimestamp(";
  out << "comp=" << to_string(comp);
  out << ", " << "ts=" << to_string(ts);
  out << ")";
}


SpecKeyInterval::~SpecKeyInterval() noexcept {
}


void SpecKeyInterval::__set_start(const SpecKey& val) {
  this->start = val;
}

void SpecKeyInterval::__set_finish(const SpecKey& val) {
  this->finish = val;
}
std::ostream& operator<<(std::ostream& out, const SpecKeyInterval& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecKeyInterval::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->start.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            xfer += iprot->readListBegin(_etype55, _size52);
            this->start.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += this->start[_i56].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->finish.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            xfer += iprot->readListBegin(_etype60, _size57);
            this->finish.resize(_size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              xfer += this->finish[_i61].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecKeyInterval::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecKeyInterval");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->start.size()));
    std::vector<SpecFraction> ::const_iterator _iter62;
    for (_iter62 = this->start.begin(); _iter62 != this->start.end(); ++_iter62)
    {
      xfer += (*_iter62).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("finish", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->finish.size()));
    std::vector<SpecFraction> ::const_iterator _iter63;
    for (_iter63 = this->finish.begin(); _iter63 != this->finish.end(); ++_iter63)
    {
      xfer += (*_iter63).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecKeyInterval &a, SpecKeyInterval &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.finish, b.finish);
  swap(a.__isset, b.__isset);
}

SpecKeyInterval::SpecKeyInterval(const SpecKeyInterval& other64) {
  start = other64.start;
  finish = other64.finish;
  __isset = other64.__isset;
}
SpecKeyInterval::SpecKeyInterval(SpecKeyInterval&& other65) noexcept {
  start = std::move(other65.start);
  finish = std::move(other65.finish);
  __isset = other65.__isset;
}
SpecKeyInterval& SpecKeyInterval::operator=(const SpecKeyInterval& other66) {
  start = other66.start;
  finish = other66.finish;
  __isset = other66.__isset;
  return *this;
}
SpecKeyInterval& SpecKeyInterval::operator=(SpecKeyInterval&& other67) noexcept {
  start = std::move(other67.start);
  finish = std::move(other67.finish);
  __isset = other67.__isset;
  return *this;
}
void SpecKeyInterval::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecKeyInterval(";
  out << "start=" << to_string(start);
  out << ", " << "finish=" << to_string(finish);
  out << ")";
}


SpecValue::~SpecValue() noexcept {
}


void SpecValue::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValue::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast68;
          xfer += iprot->readI32(ecast68);
          this->comp = static_cast<Comp::type>(ecast68);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValue");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValue &a, SpecValue &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValue::SpecValue(const SpecValue& other69) {
  comp = other69.comp;
  v = other69.v;
  __isset = other69.__isset;
}
SpecValue::SpecValue(SpecValue&& other70) noexcept {
  comp = other70.comp;
  v = std::move(other70.v);
  __isset = other70.__isset;
}
SpecValue& SpecValue::operator=(const SpecValue& other71) {
  comp = other71.comp;
  v = other71.v;
  __isset = other71.__isset;
  return *this;
}
SpecValue& SpecValue::operator=(SpecValue&& other72) noexcept {
  comp = other72.comp;
  v = std::move(other72.v);
  __isset = other72.__isset;
  return *this;
}
void SpecValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValue(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecInterval::~SpecInterval() noexcept {
}


void SpecInterval::__set_range_begin(const Key& val) {
  this->range_begin = val;
}

void SpecInterval::__set_range_end(const Key& val) {
  this->range_end = val;
}

void SpecInterval::__set_offset_key(const Key& val) {
  this->offset_key = val;
}

void SpecInterval::__set_offset_rev(const int64_t val) {
  this->offset_rev = val;
__isset.offset_rev = true;
}

void SpecInterval::__set_key_intervals(const SpecKeyIntervals& val) {
  this->key_intervals = val;
}

void SpecInterval::__set_values(const SpecValues& val) {
  this->values = val;
}

void SpecInterval::__set_ts_start(const SpecTimestamp& val) {
  this->ts_start = val;
__isset.ts_start = true;
}

void SpecInterval::__set_ts_finish(const SpecTimestamp& val) {
  this->ts_finish = val;
__isset.ts_finish = true;
}

void SpecInterval::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}
std::ostream& operator<<(std::ostream& out, const SpecInterval& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecInterval::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_begin.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _etype76;
            xfer += iprot->readListBegin(_etype76, _size73);
            this->range_begin.resize(_size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              xfer += iprot->readBinary(this->range_begin[_i77]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_end.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->range_end.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += iprot->readBinary(this->range_end[_i82]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->offset_key.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _etype86;
            xfer += iprot->readListBegin(_etype86, _size83);
            this->offset_key.resize(_size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              xfer += iprot->readBinary(this->offset_key[_i87]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.offset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset_rev);
          this->__isset.offset_rev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_intervals.clear();
            uint32_t _size88;
            ::apache::thrift::protocol::TType _etype91;
            xfer += iprot->readListBegin(_etype91, _size88);
            this->key_intervals.resize(_size88);
            uint32_t _i92;
            for (_i92 = 0; _i92 < _size88; ++_i92)
            {
              xfer += this->key_intervals[_i92].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readListBegin(_etype96, _size93);
            this->values.resize(_size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              xfer += this->values[_i97].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_start.read(iprot);
          this->__isset.ts_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_finish.read(iprot);
          this->__isset.ts_finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecInterval::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecInterval");

  xfer += oprot->writeFieldBegin("range_begin", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_begin.size()));
    std::vector<std::string> ::const_iterator _iter98;
    for (_iter98 = this->range_begin.begin(); _iter98 != this->range_begin.end(); ++_iter98)
    {
      xfer += oprot->writeBinary((*_iter98));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range_end", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_end.size()));
    std::vector<std::string> ::const_iterator _iter99;
    for (_iter99 = this->range_end.begin(); _iter99 != this->range_end.end(); ++_iter99)
    {
      xfer += oprot->writeBinary((*_iter99));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset_key", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->offset_key.size()));
    std::vector<std::string> ::const_iterator _iter100;
    for (_iter100 = this->offset_key.begin(); _iter100 != this->offset_key.end(); ++_iter100)
    {
      xfer += oprot->writeBinary((*_iter100));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offset_rev) {
    xfer += oprot->writeFieldBegin("offset_rev", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->offset_rev);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("key_intervals", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->key_intervals.size()));
    std::vector<SpecKeyInterval> ::const_iterator _iter101;
    for (_iter101 = this->key_intervals.begin(); _iter101 != this->key_intervals.end(); ++_iter101)
    {
      xfer += (*_iter101).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector<SpecValue> ::const_iterator _iter102;
    for (_iter102 = this->values.begin(); _iter102 != this->values.end(); ++_iter102)
    {
      xfer += (*_iter102).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts_start) {
    xfer += oprot->writeFieldBegin("ts_start", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->ts_start.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_finish) {
    xfer += oprot->writeFieldBegin("ts_finish", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->ts_finish.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecInterval &a, SpecInterval &b) {
  using ::std::swap;
  swap(a.range_begin, b.range_begin);
  swap(a.range_end, b.range_end);
  swap(a.offset_key, b.offset_key);
  swap(a.offset_rev, b.offset_rev);
  swap(a.key_intervals, b.key_intervals);
  swap(a.values, b.values);
  swap(a.ts_start, b.ts_start);
  swap(a.ts_finish, b.ts_finish);
  swap(a.flags, b.flags);
  swap(a.__isset, b.__isset);
}

SpecInterval::SpecInterval(const SpecInterval& other103) {
  range_begin = other103.range_begin;
  range_end = other103.range_end;
  offset_key = other103.offset_key;
  offset_rev = other103.offset_rev;
  key_intervals = other103.key_intervals;
  values = other103.values;
  ts_start = other103.ts_start;
  ts_finish = other103.ts_finish;
  flags = other103.flags;
  __isset = other103.__isset;
}
SpecInterval::SpecInterval(SpecInterval&& other104) noexcept {
  range_begin = std::move(other104.range_begin);
  range_end = std::move(other104.range_end);
  offset_key = std::move(other104.offset_key);
  offset_rev = other104.offset_rev;
  key_intervals = std::move(other104.key_intervals);
  values = std::move(other104.values);
  ts_start = std::move(other104.ts_start);
  ts_finish = std::move(other104.ts_finish);
  flags = std::move(other104.flags);
  __isset = other104.__isset;
}
SpecInterval& SpecInterval::operator=(const SpecInterval& other105) {
  range_begin = other105.range_begin;
  range_end = other105.range_end;
  offset_key = other105.offset_key;
  offset_rev = other105.offset_rev;
  key_intervals = other105.key_intervals;
  values = other105.values;
  ts_start = other105.ts_start;
  ts_finish = other105.ts_finish;
  flags = other105.flags;
  __isset = other105.__isset;
  return *this;
}
SpecInterval& SpecInterval::operator=(SpecInterval&& other106) noexcept {
  range_begin = std::move(other106.range_begin);
  range_end = std::move(other106.range_end);
  offset_key = std::move(other106.offset_key);
  offset_rev = other106.offset_rev;
  key_intervals = std::move(other106.key_intervals);
  values = std::move(other106.values);
  ts_start = std::move(other106.ts_start);
  ts_finish = std::move(other106.ts_finish);
  flags = std::move(other106.flags);
  __isset = other106.__isset;
  return *this;
}
void SpecInterval::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecInterval(";
  out << "range_begin=" << to_string(range_begin);
  out << ", " << "range_end=" << to_string(range_end);
  out << ", " << "offset_key=" << to_string(offset_key);
  out << ", " << "offset_rev="; (__isset.offset_rev ? (out << to_string(offset_rev)) : (out << "<null>"));
  out << ", " << "key_intervals=" << to_string(key_intervals);
  out << ", " << "values=" << to_string(values);
  out << ", " << "ts_start="; (__isset.ts_start ? (out << to_string(ts_start)) : (out << "<null>"));
  out << ", " << "ts_finish="; (__isset.ts_finish ? (out << to_string(ts_finish)) : (out << "<null>"));
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ")";
}


SpecColumn::~SpecColumn() noexcept {
}


void SpecColumn::__set_cid(const int64_t val) {
  this->cid = val;
}

void SpecColumn::__set_intervals(const std::vector<SpecInterval> & val) {
  this->intervals = val;
}
std::ostream& operator<<(std::ostream& out, const SpecColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->intervals.clear();
            uint32_t _size107;
            ::apache::thrift::protocol::TType _etype110;
            xfer += iprot->readListBegin(_etype110, _size107);
            this->intervals.resize(_size107);
            uint32_t _i111;
            for (_i111 = 0; _i111 < _size107; ++_i111)
            {
              xfer += this->intervals[_i111].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecColumn");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intervals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->intervals.size()));
    std::vector<SpecInterval> ::const_iterator _iter112;
    for (_iter112 = this->intervals.begin(); _iter112 != this->intervals.end(); ++_iter112)
    {
      xfer += (*_iter112).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecColumn &a, SpecColumn &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.intervals, b.intervals);
  swap(a.__isset, b.__isset);
}

SpecColumn::SpecColumn(const SpecColumn& other113) {
  cid = other113.cid;
  intervals = other113.intervals;
  __isset = other113.__isset;
}
SpecColumn::SpecColumn(SpecColumn&& other114) noexcept {
  cid = other114.cid;
  intervals = std::move(other114.intervals);
  __isset = other114.__isset;
}
SpecColumn& SpecColumn::operator=(const SpecColumn& other115) {
  cid = other115.cid;
  intervals = other115.intervals;
  __isset = other115.__isset;
  return *this;
}
SpecColumn& SpecColumn::operator=(SpecColumn&& other116) noexcept {
  cid = other116.cid;
  intervals = std::move(other116.intervals);
  __isset = other116.__isset;
  return *this;
}
void SpecColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecColumn(";
  out << "cid=" << to_string(cid);
  out << ", " << "intervals=" << to_string(intervals);
  out << ")";
}


SpecValueSerial_INT64::~SpecValueSerial_INT64() noexcept {
}


void SpecValueSerial_INT64::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_INT64::__set_v(const int64_t val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_INT64& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_INT64::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast117;
          xfer += iprot->readI32(ecast117);
          this->comp = static_cast<Comp::type>(ecast117);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_INT64::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_INT64");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_INT64 &a, SpecValueSerial_INT64 &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_INT64::SpecValueSerial_INT64(const SpecValueSerial_INT64& other118) noexcept {
  comp = other118.comp;
  v = other118.v;
  __isset = other118.__isset;
}
SpecValueSerial_INT64::SpecValueSerial_INT64(SpecValueSerial_INT64&& other119) noexcept {
  comp = other119.comp;
  v = other119.v;
  __isset = other119.__isset;
}
SpecValueSerial_INT64& SpecValueSerial_INT64::operator=(const SpecValueSerial_INT64& other120) noexcept {
  comp = other120.comp;
  v = other120.v;
  __isset = other120.__isset;
  return *this;
}
SpecValueSerial_INT64& SpecValueSerial_INT64::operator=(SpecValueSerial_INT64&& other121) noexcept {
  comp = other121.comp;
  v = other121.v;
  __isset = other121.__isset;
  return *this;
}
void SpecValueSerial_INT64::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_INT64(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_DOUBLE::~SpecValueSerial_DOUBLE() noexcept {
}


void SpecValueSerial_DOUBLE::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_DOUBLE::__set_v(const double val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_DOUBLE& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_DOUBLE::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast122;
          xfer += iprot->readI32(ecast122);
          this->comp = static_cast<Comp::type>(ecast122);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_DOUBLE::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_DOUBLE");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_DOUBLE &a, SpecValueSerial_DOUBLE &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_DOUBLE::SpecValueSerial_DOUBLE(const SpecValueSerial_DOUBLE& other123) noexcept {
  comp = other123.comp;
  v = other123.v;
  __isset = other123.__isset;
}
SpecValueSerial_DOUBLE::SpecValueSerial_DOUBLE(SpecValueSerial_DOUBLE&& other124) noexcept {
  comp = other124.comp;
  v = other124.v;
  __isset = other124.__isset;
}
SpecValueSerial_DOUBLE& SpecValueSerial_DOUBLE::operator=(const SpecValueSerial_DOUBLE& other125) noexcept {
  comp = other125.comp;
  v = other125.v;
  __isset = other125.__isset;
  return *this;
}
SpecValueSerial_DOUBLE& SpecValueSerial_DOUBLE::operator=(SpecValueSerial_DOUBLE&& other126) noexcept {
  comp = other126.comp;
  v = other126.v;
  __isset = other126.__isset;
  return *this;
}
void SpecValueSerial_DOUBLE::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_DOUBLE(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_BYTES::~SpecValueSerial_BYTES() noexcept {
}


void SpecValueSerial_BYTES::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_BYTES::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_BYTES& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_BYTES::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast127;
          xfer += iprot->readI32(ecast127);
          this->comp = static_cast<Comp::type>(ecast127);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_BYTES::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_BYTES");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_BYTES &a, SpecValueSerial_BYTES &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_BYTES::SpecValueSerial_BYTES(const SpecValueSerial_BYTES& other128) {
  comp = other128.comp;
  v = other128.v;
  __isset = other128.__isset;
}
SpecValueSerial_BYTES::SpecValueSerial_BYTES(SpecValueSerial_BYTES&& other129) noexcept {
  comp = other129.comp;
  v = std::move(other129.v);
  __isset = other129.__isset;
}
SpecValueSerial_BYTES& SpecValueSerial_BYTES::operator=(const SpecValueSerial_BYTES& other130) {
  comp = other130.comp;
  v = other130.v;
  __isset = other130.__isset;
  return *this;
}
SpecValueSerial_BYTES& SpecValueSerial_BYTES::operator=(SpecValueSerial_BYTES&& other131) noexcept {
  comp = other131.comp;
  v = std::move(other131.v);
  __isset = other131.__isset;
  return *this;
}
void SpecValueSerial_BYTES::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_BYTES(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_KEY::~SpecValueSerial_KEY() noexcept {
}


void SpecValueSerial_KEY::__set_seq(const KeySeq::type val) {
  this->seq = val;
}

void SpecValueSerial_KEY::__set_v(const SpecKey& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_KEY& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_KEY::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast132;
          xfer += iprot->readI32(ecast132);
          this->seq = static_cast<KeySeq::type>(ecast132);
          this->__isset.seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size133;
            ::apache::thrift::protocol::TType _etype136;
            xfer += iprot->readListBegin(_etype136, _size133);
            this->v.resize(_size133);
            uint32_t _i137;
            for (_i137 = 0; _i137 < _size133; ++_i137)
            {
              xfer += this->v[_i137].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_KEY::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_KEY");

  xfer += oprot->writeFieldBegin("seq", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->seq));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<SpecFraction> ::const_iterator _iter138;
    for (_iter138 = this->v.begin(); _iter138 != this->v.end(); ++_iter138)
    {
      xfer += (*_iter138).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_KEY &a, SpecValueSerial_KEY &b) {
  using ::std::swap;
  swap(a.seq, b.seq);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_KEY::SpecValueSerial_KEY(const SpecValueSerial_KEY& other139) {
  seq = other139.seq;
  v = other139.v;
  __isset = other139.__isset;
}
SpecValueSerial_KEY::SpecValueSerial_KEY(SpecValueSerial_KEY&& other140) noexcept {
  seq = other140.seq;
  v = std::move(other140.v);
  __isset = other140.__isset;
}
SpecValueSerial_KEY& SpecValueSerial_KEY::operator=(const SpecValueSerial_KEY& other141) {
  seq = other141.seq;
  v = other141.v;
  __isset = other141.__isset;
  return *this;
}
SpecValueSerial_KEY& SpecValueSerial_KEY::operator=(SpecValueSerial_KEY&& other142) noexcept {
  seq = other142.seq;
  v = std::move(other142.v);
  __isset = other142.__isset;
  return *this;
}
void SpecValueSerial_KEY::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_KEY(";
  out << "seq=" << to_string(seq);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_LI::~SpecValueSerial_LI() noexcept {
}


void SpecValueSerial_LI::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_LI::__set_v(const std::vector<SpecValueSerial_INT64> & val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_LI& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_LI::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast143;
          xfer += iprot->readI32(ecast143);
          this->comp = static_cast<Comp::type>(ecast143);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size144;
            ::apache::thrift::protocol::TType _etype147;
            xfer += iprot->readListBegin(_etype147, _size144);
            this->v.resize(_size144);
            uint32_t _i148;
            for (_i148 = 0; _i148 < _size144; ++_i148)
            {
              xfer += this->v[_i148].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_LI::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_LI");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<SpecValueSerial_INT64> ::const_iterator _iter149;
    for (_iter149 = this->v.begin(); _iter149 != this->v.end(); ++_iter149)
    {
      xfer += (*_iter149).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_LI &a, SpecValueSerial_LI &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_LI::SpecValueSerial_LI(const SpecValueSerial_LI& other150) {
  comp = other150.comp;
  v = other150.v;
  __isset = other150.__isset;
}
SpecValueSerial_LI::SpecValueSerial_LI(SpecValueSerial_LI&& other151) noexcept {
  comp = other151.comp;
  v = std::move(other151.v);
  __isset = other151.__isset;
}
SpecValueSerial_LI& SpecValueSerial_LI::operator=(const SpecValueSerial_LI& other152) {
  comp = other152.comp;
  v = other152.v;
  __isset = other152.__isset;
  return *this;
}
SpecValueSerial_LI& SpecValueSerial_LI::operator=(SpecValueSerial_LI&& other153) noexcept {
  comp = other153.comp;
  v = std::move(other153.v);
  __isset = other153.__isset;
  return *this;
}
void SpecValueSerial_LI::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_LI(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_LB::~SpecValueSerial_LB() noexcept {
}


void SpecValueSerial_LB::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_LB::__set_v(const std::vector<SpecValueSerial_BYTES> & val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_LB& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_LB::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast154;
          xfer += iprot->readI32(ecast154);
          this->comp = static_cast<Comp::type>(ecast154);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size155;
            ::apache::thrift::protocol::TType _etype158;
            xfer += iprot->readListBegin(_etype158, _size155);
            this->v.resize(_size155);
            uint32_t _i159;
            for (_i159 = 0; _i159 < _size155; ++_i159)
            {
              xfer += this->v[_i159].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_LB::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_LB");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<SpecValueSerial_BYTES> ::const_iterator _iter160;
    for (_iter160 = this->v.begin(); _iter160 != this->v.end(); ++_iter160)
    {
      xfer += (*_iter160).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_LB &a, SpecValueSerial_LB &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_LB::SpecValueSerial_LB(const SpecValueSerial_LB& other161) {
  comp = other161.comp;
  v = other161.v;
  __isset = other161.__isset;
}
SpecValueSerial_LB::SpecValueSerial_LB(SpecValueSerial_LB&& other162) noexcept {
  comp = other162.comp;
  v = std::move(other162.v);
  __isset = other162.__isset;
}
SpecValueSerial_LB& SpecValueSerial_LB::operator=(const SpecValueSerial_LB& other163) {
  comp = other163.comp;
  v = other163.v;
  __isset = other163.__isset;
  return *this;
}
SpecValueSerial_LB& SpecValueSerial_LB::operator=(SpecValueSerial_LB&& other164) noexcept {
  comp = other164.comp;
  v = std::move(other164.v);
  __isset = other164.__isset;
  return *this;
}
void SpecValueSerial_LB::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_LB(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerialField::~SpecValueSerialField() noexcept {
}


void SpecValueSerialField::__set_field_id(const int32_t val) {
  this->field_id = val;
}

void SpecValueSerialField::__set_spec_int64(const SpecValueSerial_INT64& val) {
  this->spec_int64 = val;
__isset.spec_int64 = true;
}

void SpecValueSerialField::__set_spec_double(const SpecValueSerial_DOUBLE& val) {
  this->spec_double = val;
__isset.spec_double = true;
}

void SpecValueSerialField::__set_spec_bytes(const SpecValueSerial_BYTES& val) {
  this->spec_bytes = val;
}

void SpecValueSerialField::__set_spec_key(const SpecValueSerial_KEY& val) {
  this->spec_key = val;
}

void SpecValueSerialField::__set_spec_li(const SpecValueSerial_LI& val) {
  this->spec_li = val;
}

void SpecValueSerialField::__set_spec_lb(const SpecValueSerial_LB& val) {
  this->spec_lb = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerialField& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerialField::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field_id);
          this->__isset.field_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_int64.read(iprot);
          this->__isset.spec_int64 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_double.read(iprot);
          this->__isset.spec_double = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_bytes.read(iprot);
          this->__isset.spec_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_key.read(iprot);
          this->__isset.spec_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_li.read(iprot);
          this->__isset.spec_li = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_lb.read(iprot);
          this->__isset.spec_lb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerialField::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerialField");

  xfer += oprot->writeFieldBegin("field_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.spec_int64) {
    xfer += oprot->writeFieldBegin("spec_int64", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->spec_int64.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.spec_double) {
    xfer += oprot->writeFieldBegin("spec_double", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->spec_double.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("spec_bytes", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->spec_bytes.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spec_key", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->spec_key.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spec_li", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->spec_li.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spec_lb", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->spec_lb.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerialField &a, SpecValueSerialField &b) {
  using ::std::swap;
  swap(a.field_id, b.field_id);
  swap(a.spec_int64, b.spec_int64);
  swap(a.spec_double, b.spec_double);
  swap(a.spec_bytes, b.spec_bytes);
  swap(a.spec_key, b.spec_key);
  swap(a.spec_li, b.spec_li);
  swap(a.spec_lb, b.spec_lb);
  swap(a.__isset, b.__isset);
}

SpecValueSerialField::SpecValueSerialField(const SpecValueSerialField& other165) {
  field_id = other165.field_id;
  spec_int64 = other165.spec_int64;
  spec_double = other165.spec_double;
  spec_bytes = other165.spec_bytes;
  spec_key = other165.spec_key;
  spec_li = other165.spec_li;
  spec_lb = other165.spec_lb;
  __isset = other165.__isset;
}
SpecValueSerialField::SpecValueSerialField(SpecValueSerialField&& other166) noexcept {
  field_id = other166.field_id;
  spec_int64 = std::move(other166.spec_int64);
  spec_double = std::move(other166.spec_double);
  spec_bytes = std::move(other166.spec_bytes);
  spec_key = std::move(other166.spec_key);
  spec_li = std::move(other166.spec_li);
  spec_lb = std::move(other166.spec_lb);
  __isset = other166.__isset;
}
SpecValueSerialField& SpecValueSerialField::operator=(const SpecValueSerialField& other167) {
  field_id = other167.field_id;
  spec_int64 = other167.spec_int64;
  spec_double = other167.spec_double;
  spec_bytes = other167.spec_bytes;
  spec_key = other167.spec_key;
  spec_li = other167.spec_li;
  spec_lb = other167.spec_lb;
  __isset = other167.__isset;
  return *this;
}
SpecValueSerialField& SpecValueSerialField::operator=(SpecValueSerialField&& other168) noexcept {
  field_id = other168.field_id;
  spec_int64 = std::move(other168.spec_int64);
  spec_double = std::move(other168.spec_double);
  spec_bytes = std::move(other168.spec_bytes);
  spec_key = std::move(other168.spec_key);
  spec_li = std::move(other168.spec_li);
  spec_lb = std::move(other168.spec_lb);
  __isset = other168.__isset;
  return *this;
}
void SpecValueSerialField::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerialField(";
  out << "field_id=" << to_string(field_id);
  out << ", " << "spec_int64="; (__isset.spec_int64 ? (out << to_string(spec_int64)) : (out << "<null>"));
  out << ", " << "spec_double="; (__isset.spec_double ? (out << to_string(spec_double)) : (out << "<null>"));
  out << ", " << "spec_bytes=" << to_string(spec_bytes);
  out << ", " << "spec_key=" << to_string(spec_key);
  out << ", " << "spec_li=" << to_string(spec_li);
  out << ", " << "spec_lb=" << to_string(spec_lb);
  out << ")";
}


SpecValueSerial::~SpecValueSerial() noexcept {
}


void SpecValueSerial::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial::__set_fields(const SpecValueSerialFields& val) {
  this->fields = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast169;
          xfer += iprot->readI32(ecast169);
          this->comp = static_cast<Comp::type>(ecast169);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size170;
            ::apache::thrift::protocol::TType _etype173;
            xfer += iprot->readListBegin(_etype173, _size170);
            this->fields.resize(_size170);
            uint32_t _i174;
            for (_i174 = 0; _i174 < _size170; ++_i174)
            {
              xfer += this->fields[_i174].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fields.size()));
    std::vector<SpecValueSerialField> ::const_iterator _iter175;
    for (_iter175 = this->fields.begin(); _iter175 != this->fields.end(); ++_iter175)
    {
      xfer += (*_iter175).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial &a, SpecValueSerial &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.fields, b.fields);
  swap(a.__isset, b.__isset);
}

SpecValueSerial::SpecValueSerial(const SpecValueSerial& other176) {
  comp = other176.comp;
  fields = other176.fields;
  __isset = other176.__isset;
}
SpecValueSerial::SpecValueSerial(SpecValueSerial&& other177) noexcept {
  comp = other177.comp;
  fields = std::move(other177.fields);
  __isset = other177.__isset;
}
SpecValueSerial& SpecValueSerial::operator=(const SpecValueSerial& other178) {
  comp = other178.comp;
  fields = other178.fields;
  __isset = other178.__isset;
  return *this;
}
SpecValueSerial& SpecValueSerial::operator=(SpecValueSerial&& other179) noexcept {
  comp = other179.comp;
  fields = std::move(other179.fields);
  __isset = other179.__isset;
  return *this;
}
void SpecValueSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial(";
  out << "comp=" << to_string(comp);
  out << ", " << "fields=" << to_string(fields);
  out << ")";
}


SpecIntervalSerial::~SpecIntervalSerial() noexcept {
}


void SpecIntervalSerial::__set_range_begin(const Key& val) {
  this->range_begin = val;
}

void SpecIntervalSerial::__set_range_end(const Key& val) {
  this->range_end = val;
}

void SpecIntervalSerial::__set_offset_key(const Key& val) {
  this->offset_key = val;
}

void SpecIntervalSerial::__set_offset_rev(const int64_t val) {
  this->offset_rev = val;
__isset.offset_rev = true;
}

void SpecIntervalSerial::__set_key_intervals(const SpecKeyIntervals& val) {
  this->key_intervals = val;
}

void SpecIntervalSerial::__set_values(const SpecValuesSerial& val) {
  this->values = val;
}

void SpecIntervalSerial::__set_ts_start(const SpecTimestamp& val) {
  this->ts_start = val;
__isset.ts_start = true;
}

void SpecIntervalSerial::__set_ts_finish(const SpecTimestamp& val) {
  this->ts_finish = val;
__isset.ts_finish = true;
}

void SpecIntervalSerial::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}
std::ostream& operator<<(std::ostream& out, const SpecIntervalSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecIntervalSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_begin.clear();
            uint32_t _size180;
            ::apache::thrift::protocol::TType _etype183;
            xfer += iprot->readListBegin(_etype183, _size180);
            this->range_begin.resize(_size180);
            uint32_t _i184;
            for (_i184 = 0; _i184 < _size180; ++_i184)
            {
              xfer += iprot->readBinary(this->range_begin[_i184]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_end.clear();
            uint32_t _size185;
            ::apache::thrift::protocol::TType _etype188;
            xfer += iprot->readListBegin(_etype188, _size185);
            this->range_end.resize(_size185);
            uint32_t _i189;
            for (_i189 = 0; _i189 < _size185; ++_i189)
            {
              xfer += iprot->readBinary(this->range_end[_i189]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->offset_key.clear();
            uint32_t _size190;
            ::apache::thrift::protocol::TType _etype193;
            xfer += iprot->readListBegin(_etype193, _size190);
            this->offset_key.resize(_size190);
            uint32_t _i194;
            for (_i194 = 0; _i194 < _size190; ++_i194)
            {
              xfer += iprot->readBinary(this->offset_key[_i194]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.offset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset_rev);
          this->__isset.offset_rev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_intervals.clear();
            uint32_t _size195;
            ::apache::thrift::protocol::TType _etype198;
            xfer += iprot->readListBegin(_etype198, _size195);
            this->key_intervals.resize(_size195);
            uint32_t _i199;
            for (_i199 = 0; _i199 < _size195; ++_i199)
            {
              xfer += this->key_intervals[_i199].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size200;
            ::apache::thrift::protocol::TType _etype203;
            xfer += iprot->readListBegin(_etype203, _size200);
            this->values.resize(_size200);
            uint32_t _i204;
            for (_i204 = 0; _i204 < _size200; ++_i204)
            {
              xfer += this->values[_i204].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_start.read(iprot);
          this->__isset.ts_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_finish.read(iprot);
          this->__isset.ts_finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecIntervalSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecIntervalSerial");

  xfer += oprot->writeFieldBegin("range_begin", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_begin.size()));
    std::vector<std::string> ::const_iterator _iter205;
    for (_iter205 = this->range_begin.begin(); _iter205 != this->range_begin.end(); ++_iter205)
    {
      xfer += oprot->writeBinary((*_iter205));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range_end", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_end.size()));
    std::vector<std::string> ::const_iterator _iter206;
    for (_iter206 = this->range_end.begin(); _iter206 != this->range_end.end(); ++_iter206)
    {
      xfer += oprot->writeBinary((*_iter206));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset_key", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->offset_key.size()));
    std::vector<std::string> ::const_iterator _iter207;
    for (_iter207 = this->offset_key.begin(); _iter207 != this->offset_key.end(); ++_iter207)
    {
      xfer += oprot->writeBinary((*_iter207));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offset_rev) {
    xfer += oprot->writeFieldBegin("offset_rev", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->offset_rev);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("key_intervals", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->key_intervals.size()));
    std::vector<SpecKeyInterval> ::const_iterator _iter208;
    for (_iter208 = this->key_intervals.begin(); _iter208 != this->key_intervals.end(); ++_iter208)
    {
      xfer += (*_iter208).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector<SpecValueSerial> ::const_iterator _iter209;
    for (_iter209 = this->values.begin(); _iter209 != this->values.end(); ++_iter209)
    {
      xfer += (*_iter209).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts_start) {
    xfer += oprot->writeFieldBegin("ts_start", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->ts_start.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_finish) {
    xfer += oprot->writeFieldBegin("ts_finish", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->ts_finish.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecIntervalSerial &a, SpecIntervalSerial &b) {
  using ::std::swap;
  swap(a.range_begin, b.range_begin);
  swap(a.range_end, b.range_end);
  swap(a.offset_key, b.offset_key);
  swap(a.offset_rev, b.offset_rev);
  swap(a.key_intervals, b.key_intervals);
  swap(a.values, b.values);
  swap(a.ts_start, b.ts_start);
  swap(a.ts_finish, b.ts_finish);
  swap(a.flags, b.flags);
  swap(a.__isset, b.__isset);
}

SpecIntervalSerial::SpecIntervalSerial(const SpecIntervalSerial& other210) {
  range_begin = other210.range_begin;
  range_end = other210.range_end;
  offset_key = other210.offset_key;
  offset_rev = other210.offset_rev;
  key_intervals = other210.key_intervals;
  values = other210.values;
  ts_start = other210.ts_start;
  ts_finish = other210.ts_finish;
  flags = other210.flags;
  __isset = other210.__isset;
}
SpecIntervalSerial::SpecIntervalSerial(SpecIntervalSerial&& other211) noexcept {
  range_begin = std::move(other211.range_begin);
  range_end = std::move(other211.range_end);
  offset_key = std::move(other211.offset_key);
  offset_rev = other211.offset_rev;
  key_intervals = std::move(other211.key_intervals);
  values = std::move(other211.values);
  ts_start = std::move(other211.ts_start);
  ts_finish = std::move(other211.ts_finish);
  flags = std::move(other211.flags);
  __isset = other211.__isset;
}
SpecIntervalSerial& SpecIntervalSerial::operator=(const SpecIntervalSerial& other212) {
  range_begin = other212.range_begin;
  range_end = other212.range_end;
  offset_key = other212.offset_key;
  offset_rev = other212.offset_rev;
  key_intervals = other212.key_intervals;
  values = other212.values;
  ts_start = other212.ts_start;
  ts_finish = other212.ts_finish;
  flags = other212.flags;
  __isset = other212.__isset;
  return *this;
}
SpecIntervalSerial& SpecIntervalSerial::operator=(SpecIntervalSerial&& other213) noexcept {
  range_begin = std::move(other213.range_begin);
  range_end = std::move(other213.range_end);
  offset_key = std::move(other213.offset_key);
  offset_rev = other213.offset_rev;
  key_intervals = std::move(other213.key_intervals);
  values = std::move(other213.values);
  ts_start = std::move(other213.ts_start);
  ts_finish = std::move(other213.ts_finish);
  flags = std::move(other213.flags);
  __isset = other213.__isset;
  return *this;
}
void SpecIntervalSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecIntervalSerial(";
  out << "range_begin=" << to_string(range_begin);
  out << ", " << "range_end=" << to_string(range_end);
  out << ", " << "offset_key=" << to_string(offset_key);
  out << ", " << "offset_rev="; (__isset.offset_rev ? (out << to_string(offset_rev)) : (out << "<null>"));
  out << ", " << "key_intervals=" << to_string(key_intervals);
  out << ", " << "values=" << to_string(values);
  out << ", " << "ts_start="; (__isset.ts_start ? (out << to_string(ts_start)) : (out << "<null>"));
  out << ", " << "ts_finish="; (__isset.ts_finish ? (out << to_string(ts_finish)) : (out << "<null>"));
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ")";
}


SpecColumnSerial::~SpecColumnSerial() noexcept {
}


void SpecColumnSerial::__set_cid(const int64_t val) {
  this->cid = val;
}

void SpecColumnSerial::__set_intervals(const std::vector<SpecIntervalSerial> & val) {
  this->intervals = val;
}
std::ostream& operator<<(std::ostream& out, const SpecColumnSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecColumnSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->intervals.clear();
            uint32_t _size214;
            ::apache::thrift::protocol::TType _etype217;
            xfer += iprot->readListBegin(_etype217, _size214);
            this->intervals.resize(_size214);
            uint32_t _i218;
            for (_i218 = 0; _i218 < _size214; ++_i218)
            {
              xfer += this->intervals[_i218].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecColumnSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecColumnSerial");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intervals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->intervals.size()));
    std::vector<SpecIntervalSerial> ::const_iterator _iter219;
    for (_iter219 = this->intervals.begin(); _iter219 != this->intervals.end(); ++_iter219)
    {
      xfer += (*_iter219).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecColumnSerial &a, SpecColumnSerial &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.intervals, b.intervals);
  swap(a.__isset, b.__isset);
}

SpecColumnSerial::SpecColumnSerial(const SpecColumnSerial& other220) {
  cid = other220.cid;
  intervals = other220.intervals;
  __isset = other220.__isset;
}
SpecColumnSerial::SpecColumnSerial(SpecColumnSerial&& other221) noexcept {
  cid = other221.cid;
  intervals = std::move(other221.intervals);
  __isset = other221.__isset;
}
SpecColumnSerial& SpecColumnSerial::operator=(const SpecColumnSerial& other222) {
  cid = other222.cid;
  intervals = other222.intervals;
  __isset = other222.__isset;
  return *this;
}
SpecColumnSerial& SpecColumnSerial::operator=(SpecColumnSerial&& other223) noexcept {
  cid = other223.cid;
  intervals = std::move(other223.intervals);
  __isset = other223.__isset;
  return *this;
}
void SpecColumnSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecColumnSerial(";
  out << "cid=" << to_string(cid);
  out << ", " << "intervals=" << to_string(intervals);
  out << ")";
}


SpecScan::~SpecScan() noexcept {
}


void SpecScan::__set_columns(const std::vector<SpecColumn> & val) {
  this->columns = val;
}

void SpecScan::__set_columns_serial(const std::vector<SpecColumnSerial> & val) {
  this->columns_serial = val;
}

void SpecScan::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}
std::ostream& operator<<(std::ostream& out, const SpecScan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecScan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size224;
            ::apache::thrift::protocol::TType _etype227;
            xfer += iprot->readListBegin(_etype227, _size224);
            this->columns.resize(_size224);
            uint32_t _i228;
            for (_i228 = 0; _i228 < _size224; ++_i228)
            {
              xfer += this->columns[_i228].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns_serial.clear();
            uint32_t _size229;
            ::apache::thrift::protocol::TType _etype232;
            xfer += iprot->readListBegin(_etype232, _size229);
            this->columns_serial.resize(_size229);
            uint32_t _i233;
            for (_i233 = 0; _i233 < _size229; ++_i233)
            {
              xfer += this->columns_serial[_i233].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns_serial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecScan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecScan");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<SpecColumn> ::const_iterator _iter234;
    for (_iter234 = this->columns.begin(); _iter234 != this->columns.end(); ++_iter234)
    {
      xfer += (*_iter234).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns_serial", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns_serial.size()));
    std::vector<SpecColumnSerial> ::const_iterator _iter235;
    for (_iter235 = this->columns_serial.begin(); _iter235 != this->columns_serial.end(); ++_iter235)
    {
      xfer += (*_iter235).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecScan &a, SpecScan &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.columns_serial, b.columns_serial);
  swap(a.flags, b.flags);
  swap(a.__isset, b.__isset);
}

SpecScan::SpecScan(const SpecScan& other236) {
  columns = other236.columns;
  columns_serial = other236.columns_serial;
  flags = other236.flags;
  __isset = other236.__isset;
}
SpecScan::SpecScan(SpecScan&& other237) noexcept {
  columns = std::move(other237.columns);
  columns_serial = std::move(other237.columns_serial);
  flags = std::move(other237.flags);
  __isset = other237.__isset;
}
SpecScan& SpecScan::operator=(const SpecScan& other238) {
  columns = other238.columns;
  columns_serial = other238.columns_serial;
  flags = other238.flags;
  __isset = other238.__isset;
  return *this;
}
SpecScan& SpecScan::operator=(SpecScan&& other239) noexcept {
  columns = std::move(other239.columns);
  columns_serial = std::move(other239.columns_serial);
  flags = std::move(other239.flags);
  __isset = other239.__isset;
  return *this;
}
void SpecScan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecScan(";
  out << "columns=" << to_string(columns);
  out << ", " << "columns_serial=" << to_string(columns_serial);
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ")";
}


UCell::~UCell() noexcept {
}


void UCell::__set_f(const Flag::type val) {
  this->f = val;
}

void UCell::__set_k(const Key& val) {
  this->k = val;
}

void UCell::__set_ts(const int64_t val) {
  this->ts = val;
__isset.ts = true;
}

void UCell::__set_ts_desc(const bool val) {
  this->ts_desc = val;
__isset.ts_desc = true;
}

void UCell::__set_v(const std::string& val) {
  this->v = val;
}

void UCell::__set_encoder(const EncodingType::type val) {
  this->encoder = val;
__isset.encoder = true;
}
std::ostream& operator<<(std::ostream& out, const UCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast240;
          xfer += iprot->readI32(ecast240);
          this->f = static_cast<Flag::type>(ecast240);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size241;
            ::apache::thrift::protocol::TType _etype244;
            xfer += iprot->readListBegin(_etype244, _size241);
            this->k.resize(_size241);
            uint32_t _i245;
            for (_i245 = 0; _i245 < _size241; ++_i245)
            {
              xfer += iprot->readBinary(this->k[_i245]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ts_desc);
          this->__isset.ts_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast246;
          xfer += iprot->readI32(ecast246);
          this->encoder = static_cast<EncodingType::type>(ecast246);
          this->__isset.encoder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UCell");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->f));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter247;
    for (_iter247 = this->k.begin(); _iter247 != this->k.end(); ++_iter247)
    {
      xfer += oprot->writeBinary((*_iter247));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts) {
    xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_desc) {
    xfer += oprot->writeFieldBegin("ts_desc", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->ts_desc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.encoder) {
    xfer += oprot->writeFieldBegin("encoder", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->encoder));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UCell &a, UCell &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.ts_desc, b.ts_desc);
  swap(a.v, b.v);
  swap(a.encoder, b.encoder);
  swap(a.__isset, b.__isset);
}

UCell::UCell(const UCell& other248) {
  f = other248.f;
  k = other248.k;
  ts = other248.ts;
  ts_desc = other248.ts_desc;
  v = other248.v;
  encoder = other248.encoder;
  __isset = other248.__isset;
}
UCell::UCell(UCell&& other249) noexcept {
  f = other249.f;
  k = std::move(other249.k);
  ts = other249.ts;
  ts_desc = other249.ts_desc;
  v = std::move(other249.v);
  encoder = other249.encoder;
  __isset = other249.__isset;
}
UCell& UCell::operator=(const UCell& other250) {
  f = other250.f;
  k = other250.k;
  ts = other250.ts;
  ts_desc = other250.ts_desc;
  v = other250.v;
  encoder = other250.encoder;
  __isset = other250.__isset;
  return *this;
}
UCell& UCell::operator=(UCell&& other251) noexcept {
  f = other251.f;
  k = std::move(other251.k);
  ts = other251.ts;
  ts_desc = other251.ts_desc;
  v = std::move(other251.v);
  encoder = other251.encoder;
  __isset = other251.__isset;
  return *this;
}
void UCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UCell(";
  out << "f=" << to_string(f);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts="; (__isset.ts ? (out << to_string(ts)) : (out << "<null>"));
  out << ", " << "ts_desc="; (__isset.ts_desc ? (out << to_string(ts_desc)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ", " << "encoder="; (__isset.encoder ? (out << to_string(encoder)) : (out << "<null>"));
  out << ")";
}


CellValueSerial::~CellValueSerial() noexcept {
}


void CellValueSerial::__set_field_id(const int32_t val) {
  this->field_id = val;
}

void CellValueSerial::__set_v_int64(const int64_t val) {
  this->v_int64 = val;
__isset.v_int64 = true;
}

void CellValueSerial::__set_v_double(const double val) {
  this->v_double = val;
__isset.v_double = true;
}

void CellValueSerial::__set_v_bytes(const std::string& val) {
  this->v_bytes = val;
}

void CellValueSerial::__set_v_key(const Key& val) {
  this->v_key = val;
}

void CellValueSerial::__set_v_li(const std::vector<int64_t> & val) {
  this->v_li = val;
}

void CellValueSerial::__set_v_lb(const std::vector<std::string> & val) {
  this->v_lb = val;
}
std::ostream& operator<<(std::ostream& out, const CellValueSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellValueSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field_id);
          this->__isset.field_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v_int64);
          this->__isset.v_int64 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v_double);
          this->__isset.v_double = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v_bytes);
          this->__isset.v_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_key.clear();
            uint32_t _size252;
            ::apache::thrift::protocol::TType _etype255;
            xfer += iprot->readListBegin(_etype255, _size252);
            this->v_key.resize(_size252);
            uint32_t _i256;
            for (_i256 = 0; _i256 < _size252; ++_i256)
            {
              xfer += iprot->readBinary(this->v_key[_i256]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_li.clear();
            uint32_t _size257;
            ::apache::thrift::protocol::TType _etype260;
            xfer += iprot->readListBegin(_etype260, _size257);
            this->v_li.resize(_size257);
            uint32_t _i261;
            for (_i261 = 0; _i261 < _size257; ++_i261)
            {
              xfer += iprot->readI64(this->v_li[_i261]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_li = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_lb.clear();
            uint32_t _size262;
            ::apache::thrift::protocol::TType _etype265;
            xfer += iprot->readListBegin(_etype265, _size262);
            this->v_lb.resize(_size262);
            uint32_t _i266;
            for (_i266 = 0; _i266 < _size262; ++_i266)
            {
              xfer += iprot->readBinary(this->v_lb[_i266]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_lb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellValueSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellValueSerial");

  xfer += oprot->writeFieldBegin("field_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.v_int64) {
    xfer += oprot->writeFieldBegin("v_int64", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->v_int64);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_double) {
    xfer += oprot->writeFieldBegin("v_double", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->v_double);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v_bytes", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->v_bytes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_key", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->v_key.size()));
    std::vector<std::string> ::const_iterator _iter267;
    for (_iter267 = this->v_key.begin(); _iter267 != this->v_key.end(); ++_iter267)
    {
      xfer += oprot->writeBinary((*_iter267));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_li", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->v_li.size()));
    std::vector<int64_t> ::const_iterator _iter268;
    for (_iter268 = this->v_li.begin(); _iter268 != this->v_li.end(); ++_iter268)
    {
      xfer += oprot->writeI64((*_iter268));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_lb", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->v_lb.size()));
    std::vector<std::string> ::const_iterator _iter269;
    for (_iter269 = this->v_lb.begin(); _iter269 != this->v_lb.end(); ++_iter269)
    {
      xfer += oprot->writeBinary((*_iter269));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellValueSerial &a, CellValueSerial &b) {
  using ::std::swap;
  swap(a.field_id, b.field_id);
  swap(a.v_int64, b.v_int64);
  swap(a.v_double, b.v_double);
  swap(a.v_bytes, b.v_bytes);
  swap(a.v_key, b.v_key);
  swap(a.v_li, b.v_li);
  swap(a.v_lb, b.v_lb);
  swap(a.__isset, b.__isset);
}

CellValueSerial::CellValueSerial(const CellValueSerial& other270) {
  field_id = other270.field_id;
  v_int64 = other270.v_int64;
  v_double = other270.v_double;
  v_bytes = other270.v_bytes;
  v_key = other270.v_key;
  v_li = other270.v_li;
  v_lb = other270.v_lb;
  __isset = other270.__isset;
}
CellValueSerial::CellValueSerial(CellValueSerial&& other271) noexcept {
  field_id = other271.field_id;
  v_int64 = other271.v_int64;
  v_double = other271.v_double;
  v_bytes = std::move(other271.v_bytes);
  v_key = std::move(other271.v_key);
  v_li = std::move(other271.v_li);
  v_lb = std::move(other271.v_lb);
  __isset = other271.__isset;
}
CellValueSerial& CellValueSerial::operator=(const CellValueSerial& other272) {
  field_id = other272.field_id;
  v_int64 = other272.v_int64;
  v_double = other272.v_double;
  v_bytes = other272.v_bytes;
  v_key = other272.v_key;
  v_li = other272.v_li;
  v_lb = other272.v_lb;
  __isset = other272.__isset;
  return *this;
}
CellValueSerial& CellValueSerial::operator=(CellValueSerial&& other273) noexcept {
  field_id = other273.field_id;
  v_int64 = other273.v_int64;
  v_double = other273.v_double;
  v_bytes = std::move(other273.v_bytes);
  v_key = std::move(other273.v_key);
  v_li = std::move(other273.v_li);
  v_lb = std::move(other273.v_lb);
  __isset = other273.__isset;
  return *this;
}
void CellValueSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellValueSerial(";
  out << "field_id=" << to_string(field_id);
  out << ", " << "v_int64="; (__isset.v_int64 ? (out << to_string(v_int64)) : (out << "<null>"));
  out << ", " << "v_double="; (__isset.v_double ? (out << to_string(v_double)) : (out << "<null>"));
  out << ", " << "v_bytes=" << to_string(v_bytes);
  out << ", " << "v_key=" << to_string(v_key);
  out << ", " << "v_li=" << to_string(v_li);
  out << ", " << "v_lb=" << to_string(v_lb);
  out << ")";
}


UCellSerial::~UCellSerial() noexcept {
}


void UCellSerial::__set_f(const Flag::type val) {
  this->f = val;
}

void UCellSerial::__set_k(const Key& val) {
  this->k = val;
}

void UCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
__isset.ts = true;
}

void UCellSerial::__set_ts_desc(const bool val) {
  this->ts_desc = val;
__isset.ts_desc = true;
}

void UCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}

void UCellSerial::__set_encoder(const EncodingType::type val) {
  this->encoder = val;
__isset.encoder = true;
}
std::ostream& operator<<(std::ostream& out, const UCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast274;
          xfer += iprot->readI32(ecast274);
          this->f = static_cast<Flag::type>(ecast274);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size275;
            ::apache::thrift::protocol::TType _etype278;
            xfer += iprot->readListBegin(_etype278, _size275);
            this->k.resize(_size275);
            uint32_t _i279;
            for (_i279 = 0; _i279 < _size275; ++_i279)
            {
              xfer += iprot->readBinary(this->k[_i279]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ts_desc);
          this->__isset.ts_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size280;
            ::apache::thrift::protocol::TType _etype283;
            xfer += iprot->readListBegin(_etype283, _size280);
            this->v.resize(_size280);
            uint32_t _i284;
            for (_i284 = 0; _i284 < _size280; ++_i284)
            {
              xfer += this->v[_i284].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast285;
          xfer += iprot->readI32(ecast285);
          this->encoder = static_cast<EncodingType::type>(ecast285);
          this->__isset.encoder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UCellSerial");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->f));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter286;
    for (_iter286 = this->k.begin(); _iter286 != this->k.end(); ++_iter286)
    {
      xfer += oprot->writeBinary((*_iter286));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts) {
    xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_desc) {
    xfer += oprot->writeFieldBegin("ts_desc", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->ts_desc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter287;
    for (_iter287 = this->v.begin(); _iter287 != this->v.end(); ++_iter287)
    {
      xfer += (*_iter287).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.encoder) {
    xfer += oprot->writeFieldBegin("encoder", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->encoder));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UCellSerial &a, UCellSerial &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.ts_desc, b.ts_desc);
  swap(a.v, b.v);
  swap(a.encoder, b.encoder);
  swap(a.__isset, b.__isset);
}

UCellSerial::UCellSerial(const UCellSerial& other288) {
  f = other288.f;
  k = other288.k;
  ts = other288.ts;
  ts_desc = other288.ts_desc;
  v = other288.v;
  encoder = other288.encoder;
  __isset = other288.__isset;
}
UCellSerial::UCellSerial(UCellSerial&& other289) noexcept {
  f = other289.f;
  k = std::move(other289.k);
  ts = other289.ts;
  ts_desc = other289.ts_desc;
  v = std::move(other289.v);
  encoder = other289.encoder;
  __isset = other289.__isset;
}
UCellSerial& UCellSerial::operator=(const UCellSerial& other290) {
  f = other290.f;
  k = other290.k;
  ts = other290.ts;
  ts_desc = other290.ts_desc;
  v = other290.v;
  encoder = other290.encoder;
  __isset = other290.__isset;
  return *this;
}
UCellSerial& UCellSerial::operator=(UCellSerial&& other291) noexcept {
  f = other291.f;
  k = std::move(other291.k);
  ts = other291.ts;
  ts_desc = other291.ts_desc;
  v = std::move(other291.v);
  encoder = other291.encoder;
  __isset = other291.__isset;
  return *this;
}
void UCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UCellSerial(";
  out << "f=" << to_string(f);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts="; (__isset.ts ? (out << to_string(ts)) : (out << "<null>"));
  out << ", " << "ts_desc="; (__isset.ts_desc ? (out << to_string(ts_desc)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ", " << "encoder="; (__isset.encoder ? (out << to_string(encoder)) : (out << "<null>"));
  out << ")";
}


Cell::~Cell() noexcept {
}


void Cell::__set_c(const std::string& val) {
  this->c = val;
}

void Cell::__set_k(const Key& val) {
  this->k = val;
}

void Cell::__set_ts(const int64_t val) {
  this->ts = val;
}

void Cell::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const Cell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size292;
            ::apache::thrift::protocol::TType _etype295;
            xfer += iprot->readListBegin(_etype295, _size292);
            this->k.resize(_size292);
            uint32_t _i296;
            for (_i296 = 0; _i296 < _size292; ++_i296)
            {
              xfer += iprot->readBinary(this->k[_i296]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cell");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter297;
    for (_iter297 = this->k.begin(); _iter297 != this->k.end(); ++_iter297)
    {
      xfer += oprot->writeBinary((*_iter297));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cell &a, Cell &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

Cell::Cell(const Cell& other298) {
  c = other298.c;
  k = other298.k;
  ts = other298.ts;
  v = other298.v;
  __isset = other298.__isset;
}
Cell::Cell(Cell&& other299) noexcept {
  c = std::move(other299.c);
  k = std::move(other299.k);
  ts = other299.ts;
  v = std::move(other299.v);
  __isset = other299.__isset;
}
Cell& Cell::operator=(const Cell& other300) {
  c = other300.c;
  k = other300.k;
  ts = other300.ts;
  v = other300.v;
  __isset = other300.__isset;
  return *this;
}
Cell& Cell::operator=(Cell&& other301) noexcept {
  c = std::move(other301.c);
  k = std::move(other301.k);
  ts = other301.ts;
  v = std::move(other301.v);
  __isset = other301.__isset;
  return *this;
}
void Cell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cell(";
  out << "c=" << to_string(c);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


CellSerial::~CellSerial() noexcept {
}


void CellSerial::__set_c(const std::string& val) {
  this->c = val;
}

void CellSerial::__set_k(const Key& val) {
  this->k = val;
}

void CellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void CellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const CellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size302;
            ::apache::thrift::protocol::TType _etype305;
            xfer += iprot->readListBegin(_etype305, _size302);
            this->k.resize(_size302);
            uint32_t _i306;
            for (_i306 = 0; _i306 < _size302; ++_i306)
            {
              xfer += iprot->readBinary(this->k[_i306]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size307;
            ::apache::thrift::protocol::TType _etype310;
            xfer += iprot->readListBegin(_etype310, _size307);
            this->v.resize(_size307);
            uint32_t _i311;
            for (_i311 = 0; _i311 < _size307; ++_i311)
            {
              xfer += this->v[_i311].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellSerial");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter312;
    for (_iter312 = this->k.begin(); _iter312 != this->k.end(); ++_iter312)
    {
      xfer += oprot->writeBinary((*_iter312));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter313;
    for (_iter313 = this->v.begin(); _iter313 != this->v.end(); ++_iter313)
    {
      xfer += (*_iter313).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellSerial &a, CellSerial &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CellSerial::CellSerial(const CellSerial& other314) {
  c = other314.c;
  k = other314.k;
  ts = other314.ts;
  v = other314.v;
  __isset = other314.__isset;
}
CellSerial::CellSerial(CellSerial&& other315) noexcept {
  c = std::move(other315.c);
  k = std::move(other315.k);
  ts = other315.ts;
  v = std::move(other315.v);
  __isset = other315.__isset;
}
CellSerial& CellSerial::operator=(const CellSerial& other316) {
  c = other316.c;
  k = other316.k;
  ts = other316.ts;
  v = other316.v;
  __isset = other316.__isset;
  return *this;
}
CellSerial& CellSerial::operator=(CellSerial&& other317) noexcept {
  c = std::move(other317.c);
  k = std::move(other317.k);
  ts = other317.ts;
  v = std::move(other317.v);
  __isset = other317.__isset;
  return *this;
}
void CellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellSerial(";
  out << "c=" << to_string(c);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


Cells::~Cells() noexcept {
}


void Cells::__set_cells(const std::vector<Cell> & val) {
  this->cells = val;
}

void Cells::__set_serial_cells(const std::vector<CellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const Cells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size318;
            ::apache::thrift::protocol::TType _etype321;
            xfer += iprot->readListBegin(_etype321, _size318);
            this->cells.resize(_size318);
            uint32_t _i322;
            for (_i322 = 0; _i322 < _size318; ++_i322)
            {
              xfer += this->cells[_i322].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size323;
            ::apache::thrift::protocol::TType _etype326;
            xfer += iprot->readListBegin(_etype326, _size323);
            this->serial_cells.resize(_size323);
            uint32_t _i327;
            for (_i327 = 0; _i327 < _size323; ++_i327)
            {
              xfer += this->serial_cells[_i327].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cells");

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<Cell> ::const_iterator _iter328;
    for (_iter328 = this->cells.begin(); _iter328 != this->cells.end(); ++_iter328)
    {
      xfer += (*_iter328).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<CellSerial> ::const_iterator _iter329;
    for (_iter329 = this->serial_cells.begin(); _iter329 != this->serial_cells.end(); ++_iter329)
    {
      xfer += (*_iter329).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cells &a, Cells &b) {
  using ::std::swap;
  swap(a.cells, b.cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

Cells::Cells(const Cells& other330) {
  cells = other330.cells;
  serial_cells = other330.serial_cells;
  __isset = other330.__isset;
}
Cells::Cells(Cells&& other331) noexcept {
  cells = std::move(other331.cells);
  serial_cells = std::move(other331.serial_cells);
  __isset = other331.__isset;
}
Cells& Cells::operator=(const Cells& other332) {
  cells = other332.cells;
  serial_cells = other332.serial_cells;
  __isset = other332.__isset;
  return *this;
}
Cells& Cells::operator=(Cells&& other333) noexcept {
  cells = std::move(other333.cells);
  serial_cells = std::move(other333.serial_cells);
  __isset = other333.__isset;
  return *this;
}
void Cells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cells(";
  out << "cells=" << to_string(cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


CCell::~CCell() noexcept {
}


void CCell::__set_k(const Key& val) {
  this->k = val;
}

void CCell::__set_ts(const int64_t val) {
  this->ts = val;
}

void CCell::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const CCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size334;
            ::apache::thrift::protocol::TType _etype337;
            xfer += iprot->readListBegin(_etype337, _size334);
            this->k.resize(_size334);
            uint32_t _i338;
            for (_i338 = 0; _i338 < _size334; ++_i338)
            {
              xfer += iprot->readBinary(this->k[_i338]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCell");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter339;
    for (_iter339 = this->k.begin(); _iter339 != this->k.end(); ++_iter339)
    {
      xfer += oprot->writeBinary((*_iter339));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCell &a, CCell &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CCell::CCell(const CCell& other340) {
  k = other340.k;
  ts = other340.ts;
  v = other340.v;
  __isset = other340.__isset;
}
CCell::CCell(CCell&& other341) noexcept {
  k = std::move(other341.k);
  ts = other341.ts;
  v = std::move(other341.v);
  __isset = other341.__isset;
}
CCell& CCell::operator=(const CCell& other342) {
  k = other342.k;
  ts = other342.ts;
  v = other342.v;
  __isset = other342.__isset;
  return *this;
}
CCell& CCell::operator=(CCell&& other343) noexcept {
  k = std::move(other343.k);
  ts = other343.ts;
  v = std::move(other343.v);
  __isset = other343.__isset;
  return *this;
}
void CCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCell(";
  out << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


CCellSerial::~CCellSerial() noexcept {
}


void CCellSerial::__set_k(const Key& val) {
  this->k = val;
}

void CCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void CCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const CCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size344;
            ::apache::thrift::protocol::TType _etype347;
            xfer += iprot->readListBegin(_etype347, _size344);
            this->k.resize(_size344);
            uint32_t _i348;
            for (_i348 = 0; _i348 < _size344; ++_i348)
            {
              xfer += iprot->readBinary(this->k[_i348]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size349;
            ::apache::thrift::protocol::TType _etype352;
            xfer += iprot->readListBegin(_etype352, _size349);
            this->v.resize(_size349);
            uint32_t _i353;
            for (_i353 = 0; _i353 < _size349; ++_i353)
            {
              xfer += this->v[_i353].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCellSerial");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter354;
    for (_iter354 = this->k.begin(); _iter354 != this->k.end(); ++_iter354)
    {
      xfer += oprot->writeBinary((*_iter354));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter355;
    for (_iter355 = this->v.begin(); _iter355 != this->v.end(); ++_iter355)
    {
      xfer += (*_iter355).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCellSerial &a, CCellSerial &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CCellSerial::CCellSerial(const CCellSerial& other356) {
  k = other356.k;
  ts = other356.ts;
  v = other356.v;
  __isset = other356.__isset;
}
CCellSerial::CCellSerial(CCellSerial&& other357) noexcept {
  k = std::move(other357.k);
  ts = other357.ts;
  v = std::move(other357.v);
  __isset = other357.__isset;
}
CCellSerial& CCellSerial::operator=(const CCellSerial& other358) {
  k = other358.k;
  ts = other358.ts;
  v = other358.v;
  __isset = other358.__isset;
  return *this;
}
CCellSerial& CCellSerial::operator=(CCellSerial&& other359) noexcept {
  k = std::move(other359.k);
  ts = other359.ts;
  v = std::move(other359.v);
  __isset = other359.__isset;
  return *this;
}
void CCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCellSerial(";
  out << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


ColCells::~ColCells() noexcept {
}


void ColCells::__set_cells(const std::vector<CCell> & val) {
  this->cells = val;
}

void ColCells::__set_serial_cells(const std::vector<CCellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const ColCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size360;
            ::apache::thrift::protocol::TType _etype363;
            xfer += iprot->readListBegin(_etype363, _size360);
            this->cells.resize(_size360);
            uint32_t _i364;
            for (_i364 = 0; _i364 < _size360; ++_i364)
            {
              xfer += this->cells[_i364].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size365;
            ::apache::thrift::protocol::TType _etype368;
            xfer += iprot->readListBegin(_etype368, _size365);
            this->serial_cells.resize(_size365);
            uint32_t _i369;
            for (_i369 = 0; _i369 < _size365; ++_i369)
            {
              xfer += this->serial_cells[_i369].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColCells");

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<CCell> ::const_iterator _iter370;
    for (_iter370 = this->cells.begin(); _iter370 != this->cells.end(); ++_iter370)
    {
      xfer += (*_iter370).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<CCellSerial> ::const_iterator _iter371;
    for (_iter371 = this->serial_cells.begin(); _iter371 != this->serial_cells.end(); ++_iter371)
    {
      xfer += (*_iter371).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColCells &a, ColCells &b) {
  using ::std::swap;
  swap(a.cells, b.cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

ColCells::ColCells(const ColCells& other372) {
  cells = other372.cells;
  serial_cells = other372.serial_cells;
  __isset = other372.__isset;
}
ColCells::ColCells(ColCells&& other373) noexcept {
  cells = std::move(other373.cells);
  serial_cells = std::move(other373.serial_cells);
  __isset = other373.__isset;
}
ColCells& ColCells::operator=(const ColCells& other374) {
  cells = other374.cells;
  serial_cells = other374.serial_cells;
  __isset = other374.__isset;
  return *this;
}
ColCells& ColCells::operator=(ColCells&& other375) noexcept {
  cells = std::move(other375.cells);
  serial_cells = std::move(other375.serial_cells);
  __isset = other375.__isset;
  return *this;
}
void ColCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColCells(";
  out << "cells=" << to_string(cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


KCell::~KCell() noexcept {
}


void KCell::__set_c(const std::string& val) {
  this->c = val;
}

void KCell::__set_ts(const int64_t val) {
  this->ts = val;
}

void KCell::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const KCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KCell");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KCell &a, KCell &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

KCell::KCell(const KCell& other376) {
  c = other376.c;
  ts = other376.ts;
  v = other376.v;
  __isset = other376.__isset;
}
KCell::KCell(KCell&& other377) noexcept {
  c = std::move(other377.c);
  ts = other377.ts;
  v = std::move(other377.v);
  __isset = other377.__isset;
}
KCell& KCell::operator=(const KCell& other378) {
  c = other378.c;
  ts = other378.ts;
  v = other378.v;
  __isset = other378.__isset;
  return *this;
}
KCell& KCell::operator=(KCell&& other379) noexcept {
  c = std::move(other379.c);
  ts = other379.ts;
  v = std::move(other379.v);
  __isset = other379.__isset;
  return *this;
}
void KCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KCell(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


KCellSerial::~KCellSerial() noexcept {
}


void KCellSerial::__set_c(const std::string& val) {
  this->c = val;
}

void KCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void KCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const KCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size380;
            ::apache::thrift::protocol::TType _etype383;
            xfer += iprot->readListBegin(_etype383, _size380);
            this->v.resize(_size380);
            uint32_t _i384;
            for (_i384 = 0; _i384 < _size380; ++_i384)
            {
              xfer += this->v[_i384].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KCellSerial");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter385;
    for (_iter385 = this->v.begin(); _iter385 != this->v.end(); ++_iter385)
    {
      xfer += (*_iter385).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KCellSerial &a, KCellSerial &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

KCellSerial::KCellSerial(const KCellSerial& other386) {
  c = other386.c;
  ts = other386.ts;
  v = other386.v;
  __isset = other386.__isset;
}
KCellSerial::KCellSerial(KCellSerial&& other387) noexcept {
  c = std::move(other387.c);
  ts = other387.ts;
  v = std::move(other387.v);
  __isset = other387.__isset;
}
KCellSerial& KCellSerial::operator=(const KCellSerial& other388) {
  c = other388.c;
  ts = other388.ts;
  v = other388.v;
  __isset = other388.__isset;
  return *this;
}
KCellSerial& KCellSerial::operator=(KCellSerial&& other389) noexcept {
  c = std::move(other389.c);
  ts = other389.ts;
  v = std::move(other389.v);
  __isset = other389.__isset;
  return *this;
}
void KCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KCellSerial(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


kCells::~kCells() noexcept {
}


void kCells::__set_k(const Key& val) {
  this->k = val;
}

void kCells::__set_cells(const std::vector<KCell> & val) {
  this->cells = val;
}

void kCells::__set_serial_cells(const std::vector<KCellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const kCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t kCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size390;
            ::apache::thrift::protocol::TType _etype393;
            xfer += iprot->readListBegin(_etype393, _size390);
            this->k.resize(_size390);
            uint32_t _i394;
            for (_i394 = 0; _i394 < _size390; ++_i394)
            {
              xfer += iprot->readBinary(this->k[_i394]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size395;
            ::apache::thrift::protocol::TType _etype398;
            xfer += iprot->readListBegin(_etype398, _size395);
            this->cells.resize(_size395);
            uint32_t _i399;
            for (_i399 = 0; _i399 < _size395; ++_i399)
            {
              xfer += this->cells[_i399].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size400;
            ::apache::thrift::protocol::TType _etype403;
            xfer += iprot->readListBegin(_etype403, _size400);
            this->serial_cells.resize(_size400);
            uint32_t _i404;
            for (_i404 = 0; _i404 < _size400; ++_i404)
            {
              xfer += this->serial_cells[_i404].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kCells");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter405;
    for (_iter405 = this->k.begin(); _iter405 != this->k.end(); ++_iter405)
    {
      xfer += oprot->writeBinary((*_iter405));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<KCell> ::const_iterator _iter406;
    for (_iter406 = this->cells.begin(); _iter406 != this->cells.end(); ++_iter406)
    {
      xfer += (*_iter406).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<KCellSerial> ::const_iterator _iter407;
    for (_iter407 = this->serial_cells.begin(); _iter407 != this->serial_cells.end(); ++_iter407)
    {
      xfer += (*_iter407).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(kCells &a, kCells &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.cells, b.cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

kCells::kCells(const kCells& other408) {
  k = other408.k;
  cells = other408.cells;
  serial_cells = other408.serial_cells;
  __isset = other408.__isset;
}
kCells::kCells(kCells&& other409) noexcept {
  k = std::move(other409.k);
  cells = std::move(other409.cells);
  serial_cells = std::move(other409.serial_cells);
  __isset = other409.__isset;
}
kCells& kCells::operator=(const kCells& other410) {
  k = other410.k;
  cells = other410.cells;
  serial_cells = other410.serial_cells;
  __isset = other410.__isset;
  return *this;
}
kCells& kCells::operator=(kCells&& other411) noexcept {
  k = std::move(other411.k);
  cells = std::move(other411.cells);
  serial_cells = std::move(other411.serial_cells);
  __isset = other411.__isset;
  return *this;
}
void kCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "kCells(";
  out << "k=" << to_string(k);
  out << ", " << "cells=" << to_string(cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


FCell::~FCell() noexcept {
}


void FCell::__set_c(const std::string& val) {
  this->c = val;
}

void FCell::__set_ts(const int64_t val) {
  this->ts = val;
}

void FCell::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCell");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCell &a, FCell &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FCell::FCell(const FCell& other412) {
  c = other412.c;
  ts = other412.ts;
  v = other412.v;
  __isset = other412.__isset;
}
FCell::FCell(FCell&& other413) noexcept {
  c = std::move(other413.c);
  ts = other413.ts;
  v = std::move(other413.v);
  __isset = other413.__isset;
}
FCell& FCell::operator=(const FCell& other414) {
  c = other414.c;
  ts = other414.ts;
  v = other414.v;
  __isset = other414.__isset;
  return *this;
}
FCell& FCell::operator=(FCell&& other415) noexcept {
  c = std::move(other415.c);
  ts = other415.ts;
  v = std::move(other415.v);
  __isset = other415.__isset;
  return *this;
}
void FCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCell(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FCellSerial::~FCellSerial() noexcept {
}


void FCellSerial::__set_c(const std::string& val) {
  this->c = val;
}

void FCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void FCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size416;
            ::apache::thrift::protocol::TType _etype419;
            xfer += iprot->readListBegin(_etype419, _size416);
            this->v.resize(_size416);
            uint32_t _i420;
            for (_i420 = 0; _i420 < _size416; ++_i420)
            {
              xfer += this->v[_i420].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCellSerial");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter421;
    for (_iter421 = this->v.begin(); _iter421 != this->v.end(); ++_iter421)
    {
      xfer += (*_iter421).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCellSerial &a, FCellSerial &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FCellSerial::FCellSerial(const FCellSerial& other422) {
  c = other422.c;
  ts = other422.ts;
  v = other422.v;
  __isset = other422.__isset;
}
FCellSerial::FCellSerial(FCellSerial&& other423) noexcept {
  c = std::move(other423.c);
  ts = other423.ts;
  v = std::move(other423.v);
  __isset = other423.__isset;
}
FCellSerial& FCellSerial::operator=(const FCellSerial& other424) {
  c = other424.c;
  ts = other424.ts;
  v = other424.v;
  __isset = other424.__isset;
  return *this;
}
FCellSerial& FCellSerial::operator=(FCellSerial&& other425) noexcept {
  c = std::move(other425.c);
  ts = other425.ts;
  v = std::move(other425.v);
  __isset = other425.__isset;
  return *this;
}
void FCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCellSerial(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FCells::~FCells() noexcept {
}


void FCells::__set_f(const std::map<std::string, FCells> & val) {
  this->f = val;
}

void FCells::__set_cells(const std::vector<FCell> & val) {
  this->cells = val;
}

void FCells::__set_serial_cells(const std::vector<FCellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const FCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->f.clear();
            uint32_t _size426;
            ::apache::thrift::protocol::TType _ktype427;
            ::apache::thrift::protocol::TType _vtype428;
            xfer += iprot->readMapBegin(_ktype427, _vtype428, _size426);
            uint32_t _i430;
            for (_i430 = 0; _i430 < _size426; ++_i430)
            {
              std::string _key431;
              xfer += iprot->readBinary(_key431);
              FCells& _val432 = this->f[_key431];
              xfer += _val432.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size433;
            ::apache::thrift::protocol::TType _etype436;
            xfer += iprot->readListBegin(_etype436, _size433);
            this->cells.resize(_size433);
            uint32_t _i437;
            for (_i437 = 0; _i437 < _size433; ++_i437)
            {
              xfer += this->cells[_i437].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size438;
            ::apache::thrift::protocol::TType _etype441;
            xfer += iprot->readListBegin(_etype441, _size438);
            this->serial_cells.resize(_size438);
            uint32_t _i442;
            for (_i442 = 0; _i442 < _size438; ++_i442)
            {
              xfer += this->serial_cells[_i442].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCells");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->f.size()));
    std::map<std::string, FCells> ::const_iterator _iter443;
    for (_iter443 = this->f.begin(); _iter443 != this->f.end(); ++_iter443)
    {
      xfer += oprot->writeBinary(_iter443->first);
      xfer += _iter443->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<FCell> ::const_iterator _iter444;
    for (_iter444 = this->cells.begin(); _iter444 != this->cells.end(); ++_iter444)
    {
      xfer += (*_iter444).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<FCellSerial> ::const_iterator _iter445;
    for (_iter445 = this->serial_cells.begin(); _iter445 != this->serial_cells.end(); ++_iter445)
    {
      xfer += (*_iter445).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCells &a, FCells &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.cells, b.cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

FCells::FCells(const FCells& other446) {
  f = other446.f;
  cells = other446.cells;
  serial_cells = other446.serial_cells;
  __isset = other446.__isset;
}
FCells::FCells(FCells&& other447) noexcept {
  f = std::move(other447.f);
  cells = std::move(other447.cells);
  serial_cells = std::move(other447.serial_cells);
  __isset = other447.__isset;
}
FCells& FCells::operator=(const FCells& other448) {
  f = other448.f;
  cells = other448.cells;
  serial_cells = other448.serial_cells;
  __isset = other448.__isset;
  return *this;
}
FCells& FCells::operator=(FCells&& other449) noexcept {
  f = std::move(other449.f);
  cells = std::move(other449.cells);
  serial_cells = std::move(other449.serial_cells);
  __isset = other449.__isset;
  return *this;
}
void FCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCells(";
  out << "f=" << to_string(f);
  out << ", " << "cells=" << to_string(cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


CellsGroup::~CellsGroup() noexcept {
}


void CellsGroup::__set_cells(const Cells& val) {
  this->cells = val;
}

void CellsGroup::__set_ccells(const CCells& val) {
  this->ccells = val;
}

void CellsGroup::__set_kcells(const KCells& val) {
  this->kcells = val;
}

void CellsGroup::__set_fcells(const FCells& val) {
  this->fcells = val;
}
std::ostream& operator<<(std::ostream& out, const CellsGroup& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellsGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cells.read(iprot);
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ccells.clear();
            uint32_t _size450;
            ::apache::thrift::protocol::TType _ktype451;
            ::apache::thrift::protocol::TType _vtype452;
            xfer += iprot->readMapBegin(_ktype451, _vtype452, _size450);
            uint32_t _i454;
            for (_i454 = 0; _i454 < _size450; ++_i454)
            {
              std::string _key455;
              xfer += iprot->readString(_key455);
              ColCells& _val456 = this->ccells[_key455];
              xfer += _val456.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ccells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->kcells.clear();
            uint32_t _size457;
            ::apache::thrift::protocol::TType _etype460;
            xfer += iprot->readListBegin(_etype460, _size457);
            this->kcells.resize(_size457);
            uint32_t _i461;
            for (_i461 = 0; _i461 < _size457; ++_i461)
            {
              xfer += this->kcells[_i461].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.kcells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fcells.read(iprot);
          this->__isset.fcells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellsGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellsGroup");

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cells.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ccells", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ccells.size()));
    std::map<std::string, ColCells> ::const_iterator _iter462;
    for (_iter462 = this->ccells.begin(); _iter462 != this->ccells.end(); ++_iter462)
    {
      xfer += oprot->writeString(_iter462->first);
      xfer += _iter462->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("kcells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->kcells.size()));
    std::vector<kCells> ::const_iterator _iter463;
    for (_iter463 = this->kcells.begin(); _iter463 != this->kcells.end(); ++_iter463)
    {
      xfer += (*_iter463).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fcells", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->fcells.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellsGroup &a, CellsGroup &b) {
  using ::std::swap;
  swap(a.cells, b.cells);
  swap(a.ccells, b.ccells);
  swap(a.kcells, b.kcells);
  swap(a.fcells, b.fcells);
  swap(a.__isset, b.__isset);
}

CellsGroup::CellsGroup(const CellsGroup& other464) {
  cells = other464.cells;
  ccells = other464.ccells;
  kcells = other464.kcells;
  fcells = other464.fcells;
  __isset = other464.__isset;
}
CellsGroup::CellsGroup(CellsGroup&& other465) noexcept {
  cells = std::move(other465.cells);
  ccells = std::move(other465.ccells);
  kcells = std::move(other465.kcells);
  fcells = std::move(other465.fcells);
  __isset = other465.__isset;
}
CellsGroup& CellsGroup::operator=(const CellsGroup& other466) {
  cells = other466.cells;
  ccells = other466.ccells;
  kcells = other466.kcells;
  fcells = other466.fcells;
  __isset = other466.__isset;
  return *this;
}
CellsGroup& CellsGroup::operator=(CellsGroup&& other467) noexcept {
  cells = std::move(other467.cells);
  ccells = std::move(other467.ccells);
  kcells = std::move(other467.kcells);
  fcells = std::move(other467.fcells);
  __isset = other467.__isset;
  return *this;
}
void CellsGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellsGroup(";
  out << "cells=" << to_string(cells);
  out << ", " << "ccells=" << to_string(ccells);
  out << ", " << "kcells=" << to_string(kcells);
  out << ", " << "fcells=" << to_string(fcells);
  out << ")";
}


CompactResult::~CompactResult() noexcept {
}


void CompactResult::__set_cid(const int64_t val) {
  this->cid = val;
}

void CompactResult::__set_err(const int32_t val) {
  this->err = val;
}
std::ostream& operator<<(std::ostream& out, const CompactResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->err);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CompactResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactResult");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->err);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactResult &a, CompactResult &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

CompactResult::CompactResult(const CompactResult& other468) noexcept {
  cid = other468.cid;
  err = other468.err;
  __isset = other468.__isset;
}
CompactResult::CompactResult(CompactResult&& other469) noexcept {
  cid = other469.cid;
  err = other469.err;
  __isset = other469.__isset;
}
CompactResult& CompactResult::operator=(const CompactResult& other470) noexcept {
  cid = other470.cid;
  err = other470.err;
  __isset = other470.__isset;
  return *this;
}
CompactResult& CompactResult::operator=(CompactResult&& other471) noexcept {
  cid = other471.cid;
  err = other471.err;
  __isset = other471.__isset;
  return *this;
}
void CompactResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactResult(";
  out << "cid=" << to_string(cid);
  out << ", " << "err=" << to_string(err);
  out << ")";
}


Result::~Result() noexcept {
}


void Result::__set_schemas(const Schemas& val) {
  this->schemas = val;
}

void Result::__set_cells(const Cells& val) {
  this->cells = val;
}

void Result::__set_compact(const CompactResults& val) {
  this->compact = val;
}
std::ostream& operator<<(std::ostream& out, const Result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->schemas.clear();
            uint32_t _size472;
            ::apache::thrift::protocol::TType _etype475;
            xfer += iprot->readListBegin(_etype475, _size472);
            this->schemas.resize(_size472);
            uint32_t _i476;
            for (_i476 = 0; _i476 < _size472; ++_i476)
            {
              xfer += this->schemas[_i476].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.schemas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cells.read(iprot);
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compact.clear();
            uint32_t _size477;
            ::apache::thrift::protocol::TType _etype480;
            xfer += iprot->readListBegin(_etype480, _size477);
            this->compact.resize(_size477);
            uint32_t _i481;
            for (_i481 = 0; _i481 < _size477; ++_i481)
            {
              xfer += this->compact[_i481].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.compact = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Result");

  xfer += oprot->writeFieldBegin("schemas", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->schemas.size()));
    std::vector<Schema> ::const_iterator _iter482;
    for (_iter482 = this->schemas.begin(); _iter482 != this->schemas.end(); ++_iter482)
    {
      xfer += (*_iter482).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->cells.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compact", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->compact.size()));
    std::vector<CompactResult> ::const_iterator _iter483;
    for (_iter483 = this->compact.begin(); _iter483 != this->compact.end(); ++_iter483)
    {
      xfer += (*_iter483).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Result &a, Result &b) {
  using ::std::swap;
  swap(a.schemas, b.schemas);
  swap(a.cells, b.cells);
  swap(a.compact, b.compact);
  swap(a.__isset, b.__isset);
}

Result::Result(const Result& other484) {
  schemas = other484.schemas;
  cells = other484.cells;
  compact = other484.compact;
  __isset = other484.__isset;
}
Result::Result(Result&& other485) noexcept {
  schemas = std::move(other485.schemas);
  cells = std::move(other485.cells);
  compact = std::move(other485.compact);
  __isset = other485.__isset;
}
Result& Result::operator=(const Result& other486) {
  schemas = other486.schemas;
  cells = other486.cells;
  compact = other486.compact;
  __isset = other486.__isset;
  return *this;
}
Result& Result::operator=(Result&& other487) noexcept {
  schemas = std::move(other487.schemas);
  cells = std::move(other487.cells);
  compact = std::move(other487.compact);
  __isset = other487.__isset;
  return *this;
}
void Result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Result(";
  out << "schemas=" << to_string(schemas);
  out << ", " << "cells=" << to_string(cells);
  out << ", " << "compact=" << to_string(compact);
  out << ")";
}

}} // namespace
