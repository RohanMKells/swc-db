/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Service_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace SWC { namespace Thrift {

int _kKeySeqValues[] = {
  /**
   * Unknown/Unrecognized Type
   */
  KeySeq::UNKNOWN,
  /**
   * The Lexical Key Order Sequence
   */
  KeySeq::LEXIC,
  /**
   * The Volumetric Key Order Sequence
   */
  KeySeq::VOLUME,
  /**
   * The by Fractions Count on Lexical Key Order Sequence
   */
  KeySeq::FC_LEXIC,
  /**
   * The by Fractions Count on Volumetric Key Order Sequence
   */
  KeySeq::FC_VOLUME
};
const char* _kKeySeqNames[] = {
  /**
   * Unknown/Unrecognized Type
   */
  "UNKNOWN",
  /**
   * The Lexical Key Order Sequence
   */
  "LEXIC",
  /**
   * The Volumetric Key Order Sequence
   */
  "VOLUME",
  /**
   * The by Fractions Count on Lexical Key Order Sequence
   */
  "FC_LEXIC",
  /**
   * The by Fractions Count on Volumetric Key Order Sequence
   */
  "FC_VOLUME"
};
const std::map<int, const char*> _KeySeq_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kKeySeqValues, _kKeySeqNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const KeySeq::type& val) {
  std::map<int, const char*>::const_iterator it = _KeySeq_VALUES_TO_NAMES.find(val);
  if (it != _KeySeq_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const KeySeq::type& val) {
  std::map<int, const char*>::const_iterator it = _KeySeq_VALUES_TO_NAMES.find(val);
  if (it != _KeySeq_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kColumnTypeValues[] = {
  /**
   * Unknown/Unrecognized Type
   */
  ColumnType::UNKNOWN,
  /**
   * A Plain Column Value
   */
  ColumnType::PLAIN,
  /**
   * A Counter Column Value with integrity of signed-64bit
   */
  ColumnType::COUNTER_I64,
  /**
   * A Counter Column Value with integrity of signed-32bit
   */
  ColumnType::COUNTER_I32,
  /**
   * A Counter Column Value with integrity of signed-16bit
   */
  ColumnType::COUNTER_I16,
  /**
   * A Counter Column Value with integrity of signed-8bit
   */
  ColumnType::COUNTER_I8,
  /**
   * A Serial Column Value
   */
  ColumnType::SERIAL,
  /**
   * Not used - experimental
   */
  ColumnType::CELL_DEFINED
};
const char* _kColumnTypeNames[] = {
  /**
   * Unknown/Unrecognized Type
   */
  "UNKNOWN",
  /**
   * A Plain Column Value
   */
  "PLAIN",
  /**
   * A Counter Column Value with integrity of signed-64bit
   */
  "COUNTER_I64",
  /**
   * A Counter Column Value with integrity of signed-32bit
   */
  "COUNTER_I32",
  /**
   * A Counter Column Value with integrity of signed-16bit
   */
  "COUNTER_I16",
  /**
   * A Counter Column Value with integrity of signed-8bit
   */
  "COUNTER_I8",
  /**
   * A Serial Column Value
   */
  "SERIAL",
  /**
   * Not used - experimental
   */
  "CELL_DEFINED"
};
const std::map<int, const char*> _ColumnType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kColumnTypeValues, _kColumnTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ColumnType::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnType_VALUES_TO_NAMES.find(val);
  if (it != _ColumnType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ColumnType::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnType_VALUES_TO_NAMES.find(val);
  if (it != _ColumnType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kEncodingTypeValues[] = {
  /**
   * Encoding by Ranger DEFAULT configurations
   */
  EncodingType::DEFAULT,
  /**
   * No Encoding
   */
  EncodingType::PLAIN,
  /**
   * Encode with zlib
   */
  EncodingType::ZLIB,
  /**
   * Encode with snappy
   */
  EncodingType::SNAPPY,
  /**
   * Encode with zstandard
   */
  EncodingType::ZSTD,
  /**
   * Unrecognized Type
   */
  EncodingType::UNKNOWN
};
const char* _kEncodingTypeNames[] = {
  /**
   * Encoding by Ranger DEFAULT configurations
   */
  "DEFAULT",
  /**
   * No Encoding
   */
  "PLAIN",
  /**
   * Encode with zlib
   */
  "ZLIB",
  /**
   * Encode with snappy
   */
  "SNAPPY",
  /**
   * Encode with zstandard
   */
  "ZSTD",
  /**
   * Unrecognized Type
   */
  "UNKNOWN"
};
const std::map<int, const char*> _EncodingType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kEncodingTypeValues, _kEncodingTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const EncodingType::type& val) {
  std::map<int, const char*>::const_iterator it = _EncodingType_VALUES_TO_NAMES.find(val);
  if (it != _EncodingType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const EncodingType::type& val) {
  std::map<int, const char*>::const_iterator it = _EncodingType_VALUES_TO_NAMES.find(val);
  if (it != _EncodingType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSchemaFuncValues[] = {
  /**
   * Create Column Function
   */
  SchemaFunc::CREATE,
  /**
   * Delete Column Function
   */
  SchemaFunc::DELETE,
  /**
   * Modify Column Function
   */
  SchemaFunc::MODIFY
};
const char* _kSchemaFuncNames[] = {
  /**
   * Create Column Function
   */
  "CREATE",
  /**
   * Delete Column Function
   */
  "DELETE",
  /**
   * Modify Column Function
   */
  "MODIFY"
};
const std::map<int, const char*> _SchemaFunc_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kSchemaFuncValues, _kSchemaFuncNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SchemaFunc::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaFunc_VALUES_TO_NAMES.find(val);
  if (it != _SchemaFunc_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SchemaFunc::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaFunc_VALUES_TO_NAMES.find(val);
  if (it != _SchemaFunc_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCompValues[] = {
  /**
   * [         ]  :   none               (no comparison applied)
   */
  Comp::NONE,
  /**
   * [  =^     ]  :   -pf [prefix]       (starts-with)
   */
  Comp::PF,
  /**
   * [ &gt;    ]  :   -gt                (greater-than)
   */
  Comp::GT,
  /**
   * [ &gt;=   ]  :   -ge                (greater-equal)
   */
  Comp::GE,
  /**
   * [  =      ]  :   -eq                (equal)
   */
  Comp::EQ,
  /**
   * [ &lt;=   ]  :   -le                (lower-equal)
   */
  Comp::LE,
  /**
   * [ &lt;    ]  :   -lt                (lower-than)
   */
  Comp::LT,
  /**
   * [  !=     ]  :   -ne                (not-equal)
   */
  Comp::NE,
  /**
   * [  re     ]  :   -re [r,regexp]     (regular-expression)
   */
  Comp::RE,
  /**
   * [ v&gt;   ]  :   -vgt               (vol greater-than)
   */
  Comp::VGT,
  /**
   * [ v&gt;=  ]  :   -vge               (vol greater-equal)
   */
  Comp::VGE,
  /**
   * [ v&lt;=  ]  :   -vle               (vol lower-equal)
   */
  Comp::VLE,
  /**
   * [ v&lt;   ]  :   -vlt               (vol lower-than)
   */
  Comp::VLT,
  /**
   * [ %&gt;   ]  :   -subset [sbs]      (subset)
   */
  Comp::SBS,
  /**
   * [ &lt;%   ]  :   -supset [sps]      (superset)
   */
  Comp::SPS,
  /**
   * [ ~&gt;   ]  :   -posubset [posbs]  (eq/part ordered subset)
   */
  Comp::POSBS,
  /**
   * [ &lt;~   ]  :   -posupset [posps]  (eq/part ordered superset)
   */
  Comp::POSPS,
  /**
   * [ -&gt;   ]  :   -fosubset [fosbs]  (eq/full ordered subset)
   */
  Comp::FOSBS,
  /**
   * [ &lt;-   ]  :   -fosupset [fosps]  (eq/full ordered superset)
   */
  Comp::FOSPS
};
const char* _kCompNames[] = {
  /**
   * [         ]  :   none               (no comparison applied)
   */
  "NONE",
  /**
   * [  =^     ]  :   -pf [prefix]       (starts-with)
   */
  "PF",
  /**
   * [ &gt;    ]  :   -gt                (greater-than)
   */
  "GT",
  /**
   * [ &gt;=   ]  :   -ge                (greater-equal)
   */
  "GE",
  /**
   * [  =      ]  :   -eq                (equal)
   */
  "EQ",
  /**
   * [ &lt;=   ]  :   -le                (lower-equal)
   */
  "LE",
  /**
   * [ &lt;    ]  :   -lt                (lower-than)
   */
  "LT",
  /**
   * [  !=     ]  :   -ne                (not-equal)
   */
  "NE",
  /**
   * [  re     ]  :   -re [r,regexp]     (regular-expression)
   */
  "RE",
  /**
   * [ v&gt;   ]  :   -vgt               (vol greater-than)
   */
  "VGT",
  /**
   * [ v&gt;=  ]  :   -vge               (vol greater-equal)
   */
  "VGE",
  /**
   * [ v&lt;=  ]  :   -vle               (vol lower-equal)
   */
  "VLE",
  /**
   * [ v&lt;   ]  :   -vlt               (vol lower-than)
   */
  "VLT",
  /**
   * [ %&gt;   ]  :   -subset [sbs]      (subset)
   */
  "SBS",
  /**
   * [ &lt;%   ]  :   -supset [sps]      (superset)
   */
  "SPS",
  /**
   * [ ~&gt;   ]  :   -posubset [posbs]  (eq/part ordered subset)
   */
  "POSBS",
  /**
   * [ &lt;~   ]  :   -posupset [posps]  (eq/part ordered superset)
   */
  "POSPS",
  /**
   * [ -&gt;   ]  :   -fosubset [fosbs]  (eq/full ordered subset)
   */
  "FOSBS",
  /**
   * [ &lt;-   ]  :   -fosupset [fosps]  (eq/full ordered superset)
   */
  "FOSPS"
};
const std::map<int, const char*> _Comp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(19, _kCompValues, _kCompNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Comp::type& val) {
  std::map<int, const char*>::const_iterator it = _Comp_VALUES_TO_NAMES.find(val);
  if (it != _Comp_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Comp::type& val) {
  std::map<int, const char*>::const_iterator it = _Comp_VALUES_TO_NAMES.find(val);
  if (it != _Comp_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSpecFlagsOptValues[] = {
  /**
   * No Flag Applied
   */
  SpecFlagsOpt::NONE,
  /**
   * Cells Limit by Keys
   */
  SpecFlagsOpt::LIMIT_BY_KEYS,
  /**
   * Cells Offset by Keys
   */
  SpecFlagsOpt::OFFSET_BY_KEYS,
  /**
   * Select Cells Only Keys without Value data
   */
  SpecFlagsOpt::ONLY_KEYS,
  /**
   * Select Cells Only with DELETE(cell-flag)
   */
  SpecFlagsOpt::ONLY_DELETES
};
const char* _kSpecFlagsOptNames[] = {
  /**
   * No Flag Applied
   */
  "NONE",
  /**
   * Cells Limit by Keys
   */
  "LIMIT_BY_KEYS",
  /**
   * Cells Offset by Keys
   */
  "OFFSET_BY_KEYS",
  /**
   * Select Cells Only Keys without Value data
   */
  "ONLY_KEYS",
  /**
   * Select Cells Only with DELETE(cell-flag)
   */
  "ONLY_DELETES"
};
const std::map<int, const char*> _SpecFlagsOpt_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kSpecFlagsOptValues, _kSpecFlagsOptNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SpecFlagsOpt::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecFlagsOpt_VALUES_TO_NAMES.find(val);
  if (it != _SpecFlagsOpt_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SpecFlagsOpt::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecFlagsOpt_VALUES_TO_NAMES.find(val);
  if (it != _SpecFlagsOpt_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFlagValues[] = {
  /**
   * Unknown/Undefined
   */
  Flag::NONE,
  /**
   * The Cell is an insert
   */
  Flag::INSERT,
  /**
   * The Cell is a delete
   */
  Flag::DELETE,
  /**
   * The Cell is a delete-version
   */
  Flag::DELETE_VERSION
};
const char* _kFlagNames[] = {
  /**
   * Unknown/Undefined
   */
  "NONE",
  /**
   * The Cell is an insert
   */
  "INSERT",
  /**
   * The Cell is a delete
   */
  "DELETE",
  /**
   * The Cell is a delete-version
   */
  "DELETE_VERSION"
};
const std::map<int, const char*> _Flag_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kFlagValues, _kFlagNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Flag::type& val) {
  std::map<int, const char*>::const_iterator it = _Flag_VALUES_TO_NAMES.find(val);
  if (it != _Flag_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Flag::type& val) {
  std::map<int, const char*>::const_iterator it = _Flag_VALUES_TO_NAMES.find(val);
  if (it != _Flag_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCellsResultValues[] = {
  /**
   * Correspond to result on Cells (Cells in list)
   */
  CellsResult::IN_LIST,
  /**
   * Correspond to result on CCells (Columns Cells)
   */
  CellsResult::ON_COLUMN,
  /**
   * Correspond to result on KCells (Keys Cells)
   */
  CellsResult::ON_KEY,
  /**
   * Correspond to result on FCells (Fraction Cells)
   */
  CellsResult::ON_FRACTION
};
const char* _kCellsResultNames[] = {
  /**
   * Correspond to result on Cells (Cells in list)
   */
  "IN_LIST",
  /**
   * Correspond to result on CCells (Columns Cells)
   */
  "ON_COLUMN",
  /**
   * Correspond to result on KCells (Keys Cells)
   */
  "ON_KEY",
  /**
   * Correspond to result on FCells (Fraction Cells)
   */
  "ON_FRACTION"
};
const std::map<int, const char*> _CellsResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kCellsResultValues, _kCellsResultNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const CellsResult::type& val) {
  std::map<int, const char*>::const_iterator it = _CellsResult_VALUES_TO_NAMES.find(val);
  if (it != _CellsResult_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CellsResult::type& val) {
  std::map<int, const char*>::const_iterator it = _CellsResult_VALUES_TO_NAMES.find(val);
  if (it != _CellsResult_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Exception::~Exception() noexcept {
}


void Exception::__set_code(const int32_t val) {
  this->code = val;
}

void Exception::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const Exception& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Exception::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Exception::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Exception");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Exception &a, Exception &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

Exception::Exception(const Exception& other0) : TException() {
  code = other0.code;
  message = other0.message;
  __isset = other0.__isset;
}
Exception::Exception(Exception&& other1) noexcept : TException() {
  code = other1.code;
  message = std::move(other1.message);
  __isset = other1.__isset;
}
Exception& Exception::operator=(const Exception& other2) {
  code = other2.code;
  message = other2.message;
  __isset = other2.__isset;
  return *this;
}
Exception& Exception::operator=(Exception&& other3) noexcept {
  code = other3.code;
  message = std::move(other3.message);
  __isset = other3.__isset;
  return *this;
}
void Exception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Exception(";
  out << "code=" << to_string(code);
  out << ", " << "message=" << to_string(message);
  out << ")";
}

const char* Exception::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: Exception";
  }
}


Schema::~Schema() noexcept {
}


void Schema::__set_cid(const int64_t val) {
  this->cid = val;
__isset.cid = true;
}

void Schema::__set_col_name(const std::string& val) {
  this->col_name = val;
__isset.col_name = true;
}

void Schema::__set_col_seq(const KeySeq::type val) {
  this->col_seq = val;
__isset.col_seq = true;
}

void Schema::__set_col_type(const ColumnType::type val) {
  this->col_type = val;
__isset.col_type = true;
}

void Schema::__set_cell_versions(const int32_t val) {
  this->cell_versions = val;
__isset.cell_versions = true;
}

void Schema::__set_cell_ttl(const int32_t val) {
  this->cell_ttl = val;
__isset.cell_ttl = true;
}

void Schema::__set_blk_encoding(const EncodingType::type val) {
  this->blk_encoding = val;
__isset.blk_encoding = true;
}

void Schema::__set_blk_size(const int32_t val) {
  this->blk_size = val;
__isset.blk_size = true;
}

void Schema::__set_blk_cells(const int32_t val) {
  this->blk_cells = val;
__isset.blk_cells = true;
}

void Schema::__set_cs_replication(const int8_t val) {
  this->cs_replication = val;
__isset.cs_replication = true;
}

void Schema::__set_cs_size(const int32_t val) {
  this->cs_size = val;
__isset.cs_size = true;
}

void Schema::__set_cs_max(const int8_t val) {
  this->cs_max = val;
__isset.cs_max = true;
}

void Schema::__set_log_rollout_ratio(const int8_t val) {
  this->log_rollout_ratio = val;
__isset.log_rollout_ratio = true;
}

void Schema::__set_log_compact_cointervaling(const int8_t val) {
  this->log_compact_cointervaling = val;
__isset.log_compact_cointervaling = true;
}

void Schema::__set_log_fragment_preload(const int8_t val) {
  this->log_fragment_preload = val;
__isset.log_fragment_preload = true;
}

void Schema::__set_compact_percent(const int8_t val) {
  this->compact_percent = val;
__isset.compact_percent = true;
}

void Schema::__set_revision(const int64_t val) {
  this->revision = val;
__isset.revision = true;
}
std::ostream& operator<<(std::ostream& out, const Schema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Schema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col_name);
          this->__isset.col_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->col_seq = static_cast<KeySeq::type>(ecast4);
          this->__isset.col_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->col_type = static_cast<ColumnType::type>(ecast5);
          this->__isset.col_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_versions);
          this->__isset.cell_versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_ttl);
          this->__isset.cell_ttl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast6;
          xfer += iprot->readI32(ecast6);
          this->blk_encoding = static_cast<EncodingType::type>(ecast6);
          this->__isset.blk_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blk_size);
          this->__isset.blk_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blk_cells);
          this->__isset.blk_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->cs_replication);
          this->__isset.cs_replication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cs_size);
          this->__isset.cs_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->cs_max);
          this->__isset.cs_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->log_rollout_ratio);
          this->__isset.log_rollout_ratio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->log_compact_cointervaling);
          this->__isset.log_compact_cointervaling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->log_fragment_preload);
          this->__isset.log_fragment_preload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->compact_percent);
          this->__isset.compact_percent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Schema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Schema");

  if (this->__isset.cid) {
    xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->cid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_name) {
    xfer += oprot->writeFieldBegin("col_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->col_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_seq) {
    xfer += oprot->writeFieldBegin("col_seq", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(static_cast<int32_t>(this->col_seq));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_type) {
    xfer += oprot->writeFieldBegin("col_type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->col_type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_versions) {
    xfer += oprot->writeFieldBegin("cell_versions", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->cell_versions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_ttl) {
    xfer += oprot->writeFieldBegin("cell_ttl", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->cell_ttl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_encoding) {
    xfer += oprot->writeFieldBegin("blk_encoding", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(static_cast<int32_t>(this->blk_encoding));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_size) {
    xfer += oprot->writeFieldBegin("blk_size", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->blk_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_cells) {
    xfer += oprot->writeFieldBegin("blk_cells", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->blk_cells);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_replication) {
    xfer += oprot->writeFieldBegin("cs_replication", ::apache::thrift::protocol::T_BYTE, 10);
    xfer += oprot->writeByte(this->cs_replication);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_size) {
    xfer += oprot->writeFieldBegin("cs_size", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->cs_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_max) {
    xfer += oprot->writeFieldBegin("cs_max", ::apache::thrift::protocol::T_BYTE, 12);
    xfer += oprot->writeByte(this->cs_max);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.log_rollout_ratio) {
    xfer += oprot->writeFieldBegin("log_rollout_ratio", ::apache::thrift::protocol::T_BYTE, 13);
    xfer += oprot->writeByte(this->log_rollout_ratio);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.log_compact_cointervaling) {
    xfer += oprot->writeFieldBegin("log_compact_cointervaling", ::apache::thrift::protocol::T_BYTE, 14);
    xfer += oprot->writeByte(this->log_compact_cointervaling);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.log_fragment_preload) {
    xfer += oprot->writeFieldBegin("log_fragment_preload", ::apache::thrift::protocol::T_BYTE, 15);
    xfer += oprot->writeByte(this->log_fragment_preload);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compact_percent) {
    xfer += oprot->writeFieldBegin("compact_percent", ::apache::thrift::protocol::T_BYTE, 16);
    xfer += oprot->writeByte(this->compact_percent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.revision) {
    xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 17);
    xfer += oprot->writeI64(this->revision);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Schema &a, Schema &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.col_name, b.col_name);
  swap(a.col_seq, b.col_seq);
  swap(a.col_type, b.col_type);
  swap(a.cell_versions, b.cell_versions);
  swap(a.cell_ttl, b.cell_ttl);
  swap(a.blk_encoding, b.blk_encoding);
  swap(a.blk_size, b.blk_size);
  swap(a.blk_cells, b.blk_cells);
  swap(a.cs_replication, b.cs_replication);
  swap(a.cs_size, b.cs_size);
  swap(a.cs_max, b.cs_max);
  swap(a.log_rollout_ratio, b.log_rollout_ratio);
  swap(a.log_compact_cointervaling, b.log_compact_cointervaling);
  swap(a.log_fragment_preload, b.log_fragment_preload);
  swap(a.compact_percent, b.compact_percent);
  swap(a.revision, b.revision);
  swap(a.__isset, b.__isset);
}

Schema::Schema(const Schema& other7) {
  cid = other7.cid;
  col_name = other7.col_name;
  col_seq = other7.col_seq;
  col_type = other7.col_type;
  cell_versions = other7.cell_versions;
  cell_ttl = other7.cell_ttl;
  blk_encoding = other7.blk_encoding;
  blk_size = other7.blk_size;
  blk_cells = other7.blk_cells;
  cs_replication = other7.cs_replication;
  cs_size = other7.cs_size;
  cs_max = other7.cs_max;
  log_rollout_ratio = other7.log_rollout_ratio;
  log_compact_cointervaling = other7.log_compact_cointervaling;
  log_fragment_preload = other7.log_fragment_preload;
  compact_percent = other7.compact_percent;
  revision = other7.revision;
  __isset = other7.__isset;
}
Schema::Schema(Schema&& other8) noexcept {
  cid = other8.cid;
  col_name = std::move(other8.col_name);
  col_seq = other8.col_seq;
  col_type = other8.col_type;
  cell_versions = other8.cell_versions;
  cell_ttl = other8.cell_ttl;
  blk_encoding = other8.blk_encoding;
  blk_size = other8.blk_size;
  blk_cells = other8.blk_cells;
  cs_replication = other8.cs_replication;
  cs_size = other8.cs_size;
  cs_max = other8.cs_max;
  log_rollout_ratio = other8.log_rollout_ratio;
  log_compact_cointervaling = other8.log_compact_cointervaling;
  log_fragment_preload = other8.log_fragment_preload;
  compact_percent = other8.compact_percent;
  revision = other8.revision;
  __isset = other8.__isset;
}
Schema& Schema::operator=(const Schema& other9) {
  cid = other9.cid;
  col_name = other9.col_name;
  col_seq = other9.col_seq;
  col_type = other9.col_type;
  cell_versions = other9.cell_versions;
  cell_ttl = other9.cell_ttl;
  blk_encoding = other9.blk_encoding;
  blk_size = other9.blk_size;
  blk_cells = other9.blk_cells;
  cs_replication = other9.cs_replication;
  cs_size = other9.cs_size;
  cs_max = other9.cs_max;
  log_rollout_ratio = other9.log_rollout_ratio;
  log_compact_cointervaling = other9.log_compact_cointervaling;
  log_fragment_preload = other9.log_fragment_preload;
  compact_percent = other9.compact_percent;
  revision = other9.revision;
  __isset = other9.__isset;
  return *this;
}
Schema& Schema::operator=(Schema&& other10) noexcept {
  cid = other10.cid;
  col_name = std::move(other10.col_name);
  col_seq = other10.col_seq;
  col_type = other10.col_type;
  cell_versions = other10.cell_versions;
  cell_ttl = other10.cell_ttl;
  blk_encoding = other10.blk_encoding;
  blk_size = other10.blk_size;
  blk_cells = other10.blk_cells;
  cs_replication = other10.cs_replication;
  cs_size = other10.cs_size;
  cs_max = other10.cs_max;
  log_rollout_ratio = other10.log_rollout_ratio;
  log_compact_cointervaling = other10.log_compact_cointervaling;
  log_fragment_preload = other10.log_fragment_preload;
  compact_percent = other10.compact_percent;
  revision = other10.revision;
  __isset = other10.__isset;
  return *this;
}
void Schema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Schema(";
  out << "cid="; (__isset.cid ? (out << to_string(cid)) : (out << "<null>"));
  out << ", " << "col_name="; (__isset.col_name ? (out << to_string(col_name)) : (out << "<null>"));
  out << ", " << "col_seq="; (__isset.col_seq ? (out << to_string(col_seq)) : (out << "<null>"));
  out << ", " << "col_type="; (__isset.col_type ? (out << to_string(col_type)) : (out << "<null>"));
  out << ", " << "cell_versions="; (__isset.cell_versions ? (out << to_string(cell_versions)) : (out << "<null>"));
  out << ", " << "cell_ttl="; (__isset.cell_ttl ? (out << to_string(cell_ttl)) : (out << "<null>"));
  out << ", " << "blk_encoding="; (__isset.blk_encoding ? (out << to_string(blk_encoding)) : (out << "<null>"));
  out << ", " << "blk_size="; (__isset.blk_size ? (out << to_string(blk_size)) : (out << "<null>"));
  out << ", " << "blk_cells="; (__isset.blk_cells ? (out << to_string(blk_cells)) : (out << "<null>"));
  out << ", " << "cs_replication="; (__isset.cs_replication ? (out << to_string(cs_replication)) : (out << "<null>"));
  out << ", " << "cs_size="; (__isset.cs_size ? (out << to_string(cs_size)) : (out << "<null>"));
  out << ", " << "cs_max="; (__isset.cs_max ? (out << to_string(cs_max)) : (out << "<null>"));
  out << ", " << "log_rollout_ratio="; (__isset.log_rollout_ratio ? (out << to_string(log_rollout_ratio)) : (out << "<null>"));
  out << ", " << "log_compact_cointervaling="; (__isset.log_compact_cointervaling ? (out << to_string(log_compact_cointervaling)) : (out << "<null>"));
  out << ", " << "log_fragment_preload="; (__isset.log_fragment_preload ? (out << to_string(log_fragment_preload)) : (out << "<null>"));
  out << ", " << "compact_percent="; (__isset.compact_percent ? (out << to_string(compact_percent)) : (out << "<null>"));
  out << ", " << "revision="; (__isset.revision ? (out << to_string(revision)) : (out << "<null>"));
  out << ")";
}


SchemaPattern::~SchemaPattern() noexcept {
}


void SchemaPattern::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SchemaPattern::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const SchemaPattern& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaPattern::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast11;
          xfer += iprot->readI32(ecast11);
          this->comp = static_cast<Comp::type>(ecast11);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaPattern::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaPattern");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaPattern &a, SchemaPattern &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

SchemaPattern::SchemaPattern(const SchemaPattern& other12) {
  comp = other12.comp;
  value = other12.value;
  __isset = other12.__isset;
}
SchemaPattern::SchemaPattern(SchemaPattern&& other13) noexcept {
  comp = other13.comp;
  value = std::move(other13.value);
  __isset = other13.__isset;
}
SchemaPattern& SchemaPattern::operator=(const SchemaPattern& other14) {
  comp = other14.comp;
  value = other14.value;
  __isset = other14.__isset;
  return *this;
}
SchemaPattern& SchemaPattern::operator=(SchemaPattern&& other15) noexcept {
  comp = other15.comp;
  value = std::move(other15.value);
  __isset = other15.__isset;
  return *this;
}
void SchemaPattern::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaPattern(";
  out << "comp=" << to_string(comp);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


SpecSchemas::~SpecSchemas() noexcept {
}


void SpecSchemas::__set_cids(const std::vector<int64_t> & val) {
  this->cids = val;
}

void SpecSchemas::__set_names(const std::vector<std::string> & val) {
  this->names = val;
}

void SpecSchemas::__set_patterns(const std::vector<SchemaPattern> & val) {
  this->patterns = val;
}
std::ostream& operator<<(std::ostream& out, const SpecSchemas& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecSchemas::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cids.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->cids.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              xfer += iprot->readI64(this->cids[_i20]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->names.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += iprot->readString(this->names[_i25]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->patterns.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->patterns.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->patterns[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.patterns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecSchemas::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecSchemas");

  xfer += oprot->writeFieldBegin("cids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->cids.size()));
    std::vector<int64_t> ::const_iterator _iter31;
    for (_iter31 = this->cids.begin(); _iter31 != this->cids.end(); ++_iter31)
    {
      xfer += oprot->writeI64((*_iter31));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
    std::vector<std::string> ::const_iterator _iter32;
    for (_iter32 = this->names.begin(); _iter32 != this->names.end(); ++_iter32)
    {
      xfer += oprot->writeString((*_iter32));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("patterns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->patterns.size()));
    std::vector<SchemaPattern> ::const_iterator _iter33;
    for (_iter33 = this->patterns.begin(); _iter33 != this->patterns.end(); ++_iter33)
    {
      xfer += (*_iter33).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecSchemas &a, SpecSchemas &b) {
  using ::std::swap;
  swap(a.cids, b.cids);
  swap(a.names, b.names);
  swap(a.patterns, b.patterns);
  swap(a.__isset, b.__isset);
}

SpecSchemas::SpecSchemas(const SpecSchemas& other34) {
  cids = other34.cids;
  names = other34.names;
  patterns = other34.patterns;
  __isset = other34.__isset;
}
SpecSchemas::SpecSchemas(SpecSchemas&& other35) noexcept {
  cids = std::move(other35.cids);
  names = std::move(other35.names);
  patterns = std::move(other35.patterns);
  __isset = other35.__isset;
}
SpecSchemas& SpecSchemas::operator=(const SpecSchemas& other36) {
  cids = other36.cids;
  names = other36.names;
  patterns = other36.patterns;
  __isset = other36.__isset;
  return *this;
}
SpecSchemas& SpecSchemas::operator=(SpecSchemas&& other37) noexcept {
  cids = std::move(other37.cids);
  names = std::move(other37.names);
  patterns = std::move(other37.patterns);
  __isset = other37.__isset;
  return *this;
}
void SpecSchemas::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecSchemas(";
  out << "cids=" << to_string(cids);
  out << ", " << "names=" << to_string(names);
  out << ", " << "patterns=" << to_string(patterns);
  out << ")";
}


SpecFlags::~SpecFlags() noexcept {
}


void SpecFlags::__set_limit(const int64_t val) {
  this->limit = val;
__isset.limit = true;
}

void SpecFlags::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}

void SpecFlags::__set_max_versions(const int32_t val) {
  this->max_versions = val;
__isset.max_versions = true;
}

void SpecFlags::__set_max_buffer(const int32_t val) {
  this->max_buffer = val;
__isset.max_buffer = true;
}

void SpecFlags::__set_options(const int8_t val) {
  this->options = val;
__isset.options = true;
}
std::ostream& operator<<(std::ostream& out, const SpecFlags& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecFlags::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_versions);
          this->__isset.max_versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_buffer);
          this->__isset.max_buffer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->options);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecFlags::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecFlags");

  if (this->__isset.limit) {
    xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_versions) {
    xfer += oprot->writeFieldBegin("max_versions", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->max_versions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_buffer) {
    xfer += oprot->writeFieldBegin("max_buffer", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->max_buffer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_BYTE, 5);
    xfer += oprot->writeByte(this->options);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecFlags &a, SpecFlags &b) {
  using ::std::swap;
  swap(a.limit, b.limit);
  swap(a.offset, b.offset);
  swap(a.max_versions, b.max_versions);
  swap(a.max_buffer, b.max_buffer);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

SpecFlags::SpecFlags(const SpecFlags& other38) noexcept {
  limit = other38.limit;
  offset = other38.offset;
  max_versions = other38.max_versions;
  max_buffer = other38.max_buffer;
  options = other38.options;
  __isset = other38.__isset;
}
SpecFlags::SpecFlags(SpecFlags&& other39) noexcept {
  limit = other39.limit;
  offset = other39.offset;
  max_versions = other39.max_versions;
  max_buffer = other39.max_buffer;
  options = other39.options;
  __isset = other39.__isset;
}
SpecFlags& SpecFlags::operator=(const SpecFlags& other40) noexcept {
  limit = other40.limit;
  offset = other40.offset;
  max_versions = other40.max_versions;
  max_buffer = other40.max_buffer;
  options = other40.options;
  __isset = other40.__isset;
  return *this;
}
SpecFlags& SpecFlags::operator=(SpecFlags&& other41) noexcept {
  limit = other41.limit;
  offset = other41.offset;
  max_versions = other41.max_versions;
  max_buffer = other41.max_buffer;
  options = other41.options;
  __isset = other41.__isset;
  return *this;
}
void SpecFlags::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecFlags(";
  out << "limit="; (__isset.limit ? (out << to_string(limit)) : (out << "<null>"));
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ", " << "max_versions="; (__isset.max_versions ? (out << to_string(max_versions)) : (out << "<null>"));
  out << ", " << "max_buffer="; (__isset.max_buffer ? (out << to_string(max_buffer)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ")";
}


SpecFraction::~SpecFraction() noexcept {
}


void SpecFraction::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecFraction::__set_f(const std::string& val) {
  this->f = val;
}
std::ostream& operator<<(std::ostream& out, const SpecFraction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecFraction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast42;
          xfer += iprot->readI32(ecast42);
          this->comp = static_cast<Comp::type>(ecast42);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->f);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecFraction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecFraction");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->f);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecFraction &a, SpecFraction &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.f, b.f);
  swap(a.__isset, b.__isset);
}

SpecFraction::SpecFraction(const SpecFraction& other43) {
  comp = other43.comp;
  f = other43.f;
  __isset = other43.__isset;
}
SpecFraction::SpecFraction(SpecFraction&& other44) noexcept {
  comp = other44.comp;
  f = std::move(other44.f);
  __isset = other44.__isset;
}
SpecFraction& SpecFraction::operator=(const SpecFraction& other45) {
  comp = other45.comp;
  f = other45.f;
  __isset = other45.__isset;
  return *this;
}
SpecFraction& SpecFraction::operator=(SpecFraction&& other46) noexcept {
  comp = other46.comp;
  f = std::move(other46.f);
  __isset = other46.__isset;
  return *this;
}
void SpecFraction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecFraction(";
  out << "comp=" << to_string(comp);
  out << ", " << "f=" << to_string(f);
  out << ")";
}


SpecTimestamp::~SpecTimestamp() noexcept {
}


void SpecTimestamp::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecTimestamp::__set_ts(const int64_t val) {
  this->ts = val;
}
std::ostream& operator<<(std::ostream& out, const SpecTimestamp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecTimestamp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast47;
          xfer += iprot->readI32(ecast47);
          this->comp = static_cast<Comp::type>(ecast47);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecTimestamp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecTimestamp");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecTimestamp &a, SpecTimestamp &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.ts, b.ts);
  swap(a.__isset, b.__isset);
}

SpecTimestamp::SpecTimestamp(const SpecTimestamp& other48) noexcept {
  comp = other48.comp;
  ts = other48.ts;
  __isset = other48.__isset;
}
SpecTimestamp::SpecTimestamp(SpecTimestamp&& other49) noexcept {
  comp = other49.comp;
  ts = other49.ts;
  __isset = other49.__isset;
}
SpecTimestamp& SpecTimestamp::operator=(const SpecTimestamp& other50) noexcept {
  comp = other50.comp;
  ts = other50.ts;
  __isset = other50.__isset;
  return *this;
}
SpecTimestamp& SpecTimestamp::operator=(SpecTimestamp&& other51) noexcept {
  comp = other51.comp;
  ts = other51.ts;
  __isset = other51.__isset;
  return *this;
}
void SpecTimestamp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecTimestamp(";
  out << "comp=" << to_string(comp);
  out << ", " << "ts=" << to_string(ts);
  out << ")";
}


SpecKeyInterval::~SpecKeyInterval() noexcept {
}


void SpecKeyInterval::__set_start(const SpecKey& val) {
  this->start = val;
}

void SpecKeyInterval::__set_finish(const SpecKey& val) {
  this->finish = val;
}
std::ostream& operator<<(std::ostream& out, const SpecKeyInterval& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecKeyInterval::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->start.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            xfer += iprot->readListBegin(_etype55, _size52);
            this->start.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += this->start[_i56].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->finish.clear();
            uint32_t _size57;
            ::apache::thrift::protocol::TType _etype60;
            xfer += iprot->readListBegin(_etype60, _size57);
            this->finish.resize(_size57);
            uint32_t _i61;
            for (_i61 = 0; _i61 < _size57; ++_i61)
            {
              xfer += this->finish[_i61].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecKeyInterval::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecKeyInterval");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->start.size()));
    std::vector<SpecFraction> ::const_iterator _iter62;
    for (_iter62 = this->start.begin(); _iter62 != this->start.end(); ++_iter62)
    {
      xfer += (*_iter62).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("finish", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->finish.size()));
    std::vector<SpecFraction> ::const_iterator _iter63;
    for (_iter63 = this->finish.begin(); _iter63 != this->finish.end(); ++_iter63)
    {
      xfer += (*_iter63).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecKeyInterval &a, SpecKeyInterval &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.finish, b.finish);
  swap(a.__isset, b.__isset);
}

SpecKeyInterval::SpecKeyInterval(const SpecKeyInterval& other64) {
  start = other64.start;
  finish = other64.finish;
  __isset = other64.__isset;
}
SpecKeyInterval::SpecKeyInterval(SpecKeyInterval&& other65) noexcept {
  start = std::move(other65.start);
  finish = std::move(other65.finish);
  __isset = other65.__isset;
}
SpecKeyInterval& SpecKeyInterval::operator=(const SpecKeyInterval& other66) {
  start = other66.start;
  finish = other66.finish;
  __isset = other66.__isset;
  return *this;
}
SpecKeyInterval& SpecKeyInterval::operator=(SpecKeyInterval&& other67) noexcept {
  start = std::move(other67.start);
  finish = std::move(other67.finish);
  __isset = other67.__isset;
  return *this;
}
void SpecKeyInterval::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecKeyInterval(";
  out << "start=" << to_string(start);
  out << ", " << "finish=" << to_string(finish);
  out << ")";
}


SpecValue::~SpecValue() noexcept {
}


void SpecValue::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValue::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast68;
          xfer += iprot->readI32(ecast68);
          this->comp = static_cast<Comp::type>(ecast68);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValue");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValue &a, SpecValue &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValue::SpecValue(const SpecValue& other69) {
  comp = other69.comp;
  v = other69.v;
  __isset = other69.__isset;
}
SpecValue::SpecValue(SpecValue&& other70) noexcept {
  comp = other70.comp;
  v = std::move(other70.v);
  __isset = other70.__isset;
}
SpecValue& SpecValue::operator=(const SpecValue& other71) {
  comp = other71.comp;
  v = other71.v;
  __isset = other71.__isset;
  return *this;
}
SpecValue& SpecValue::operator=(SpecValue&& other72) noexcept {
  comp = other72.comp;
  v = std::move(other72.v);
  __isset = other72.__isset;
  return *this;
}
void SpecValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValue(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecInterval::~SpecInterval() noexcept {
}


void SpecInterval::__set_range_begin(const Key& val) {
  this->range_begin = val;
}

void SpecInterval::__set_range_end(const Key& val) {
  this->range_end = val;
}

void SpecInterval::__set_range_offset(const Key& val) {
  this->range_offset = val;
}

void SpecInterval::__set_offset_key(const Key& val) {
  this->offset_key = val;
}

void SpecInterval::__set_offset_rev(const int64_t val) {
  this->offset_rev = val;
__isset.offset_rev = true;
}

void SpecInterval::__set_key_intervals(const SpecKeyIntervals& val) {
  this->key_intervals = val;
}

void SpecInterval::__set_values(const SpecValues& val) {
  this->values = val;
}

void SpecInterval::__set_ts_start(const SpecTimestamp& val) {
  this->ts_start = val;
__isset.ts_start = true;
}

void SpecInterval::__set_ts_finish(const SpecTimestamp& val) {
  this->ts_finish = val;
__isset.ts_finish = true;
}

void SpecInterval::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}
std::ostream& operator<<(std::ostream& out, const SpecInterval& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecInterval::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_begin.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _etype76;
            xfer += iprot->readListBegin(_etype76, _size73);
            this->range_begin.resize(_size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              xfer += iprot->readBinary(this->range_begin[_i77]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_end.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->range_end.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += iprot->readBinary(this->range_end[_i82]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_offset.clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _etype86;
            xfer += iprot->readListBegin(_etype86, _size83);
            this->range_offset.resize(_size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              xfer += iprot->readBinary(this->range_offset[_i87]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->offset_key.clear();
            uint32_t _size88;
            ::apache::thrift::protocol::TType _etype91;
            xfer += iprot->readListBegin(_etype91, _size88);
            this->offset_key.resize(_size88);
            uint32_t _i92;
            for (_i92 = 0; _i92 < _size88; ++_i92)
            {
              xfer += iprot->readBinary(this->offset_key[_i92]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.offset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset_rev);
          this->__isset.offset_rev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_intervals.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readListBegin(_etype96, _size93);
            this->key_intervals.resize(_size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              xfer += this->key_intervals[_i97].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size98;
            ::apache::thrift::protocol::TType _etype101;
            xfer += iprot->readListBegin(_etype101, _size98);
            this->values.resize(_size98);
            uint32_t _i102;
            for (_i102 = 0; _i102 < _size98; ++_i102)
            {
              xfer += this->values[_i102].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_start.read(iprot);
          this->__isset.ts_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_finish.read(iprot);
          this->__isset.ts_finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecInterval::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecInterval");

  xfer += oprot->writeFieldBegin("range_begin", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_begin.size()));
    std::vector<std::string> ::const_iterator _iter103;
    for (_iter103 = this->range_begin.begin(); _iter103 != this->range_begin.end(); ++_iter103)
    {
      xfer += oprot->writeBinary((*_iter103));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range_end", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_end.size()));
    std::vector<std::string> ::const_iterator _iter104;
    for (_iter104 = this->range_end.begin(); _iter104 != this->range_end.end(); ++_iter104)
    {
      xfer += oprot->writeBinary((*_iter104));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range_offset", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_offset.size()));
    std::vector<std::string> ::const_iterator _iter105;
    for (_iter105 = this->range_offset.begin(); _iter105 != this->range_offset.end(); ++_iter105)
    {
      xfer += oprot->writeBinary((*_iter105));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset_key", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->offset_key.size()));
    std::vector<std::string> ::const_iterator _iter106;
    for (_iter106 = this->offset_key.begin(); _iter106 != this->offset_key.end(); ++_iter106)
    {
      xfer += oprot->writeBinary((*_iter106));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offset_rev) {
    xfer += oprot->writeFieldBegin("offset_rev", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->offset_rev);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("key_intervals", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->key_intervals.size()));
    std::vector<SpecKeyInterval> ::const_iterator _iter107;
    for (_iter107 = this->key_intervals.begin(); _iter107 != this->key_intervals.end(); ++_iter107)
    {
      xfer += (*_iter107).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector<SpecValue> ::const_iterator _iter108;
    for (_iter108 = this->values.begin(); _iter108 != this->values.end(); ++_iter108)
    {
      xfer += (*_iter108).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts_start) {
    xfer += oprot->writeFieldBegin("ts_start", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->ts_start.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_finish) {
    xfer += oprot->writeFieldBegin("ts_finish", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->ts_finish.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecInterval &a, SpecInterval &b) {
  using ::std::swap;
  swap(a.range_begin, b.range_begin);
  swap(a.range_end, b.range_end);
  swap(a.range_offset, b.range_offset);
  swap(a.offset_key, b.offset_key);
  swap(a.offset_rev, b.offset_rev);
  swap(a.key_intervals, b.key_intervals);
  swap(a.values, b.values);
  swap(a.ts_start, b.ts_start);
  swap(a.ts_finish, b.ts_finish);
  swap(a.flags, b.flags);
  swap(a.__isset, b.__isset);
}

SpecInterval::SpecInterval(const SpecInterval& other109) {
  range_begin = other109.range_begin;
  range_end = other109.range_end;
  range_offset = other109.range_offset;
  offset_key = other109.offset_key;
  offset_rev = other109.offset_rev;
  key_intervals = other109.key_intervals;
  values = other109.values;
  ts_start = other109.ts_start;
  ts_finish = other109.ts_finish;
  flags = other109.flags;
  __isset = other109.__isset;
}
SpecInterval::SpecInterval(SpecInterval&& other110) noexcept {
  range_begin = std::move(other110.range_begin);
  range_end = std::move(other110.range_end);
  range_offset = std::move(other110.range_offset);
  offset_key = std::move(other110.offset_key);
  offset_rev = other110.offset_rev;
  key_intervals = std::move(other110.key_intervals);
  values = std::move(other110.values);
  ts_start = std::move(other110.ts_start);
  ts_finish = std::move(other110.ts_finish);
  flags = std::move(other110.flags);
  __isset = other110.__isset;
}
SpecInterval& SpecInterval::operator=(const SpecInterval& other111) {
  range_begin = other111.range_begin;
  range_end = other111.range_end;
  range_offset = other111.range_offset;
  offset_key = other111.offset_key;
  offset_rev = other111.offset_rev;
  key_intervals = other111.key_intervals;
  values = other111.values;
  ts_start = other111.ts_start;
  ts_finish = other111.ts_finish;
  flags = other111.flags;
  __isset = other111.__isset;
  return *this;
}
SpecInterval& SpecInterval::operator=(SpecInterval&& other112) noexcept {
  range_begin = std::move(other112.range_begin);
  range_end = std::move(other112.range_end);
  range_offset = std::move(other112.range_offset);
  offset_key = std::move(other112.offset_key);
  offset_rev = other112.offset_rev;
  key_intervals = std::move(other112.key_intervals);
  values = std::move(other112.values);
  ts_start = std::move(other112.ts_start);
  ts_finish = std::move(other112.ts_finish);
  flags = std::move(other112.flags);
  __isset = other112.__isset;
  return *this;
}
void SpecInterval::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecInterval(";
  out << "range_begin=" << to_string(range_begin);
  out << ", " << "range_end=" << to_string(range_end);
  out << ", " << "range_offset=" << to_string(range_offset);
  out << ", " << "offset_key=" << to_string(offset_key);
  out << ", " << "offset_rev="; (__isset.offset_rev ? (out << to_string(offset_rev)) : (out << "<null>"));
  out << ", " << "key_intervals=" << to_string(key_intervals);
  out << ", " << "values=" << to_string(values);
  out << ", " << "ts_start="; (__isset.ts_start ? (out << to_string(ts_start)) : (out << "<null>"));
  out << ", " << "ts_finish="; (__isset.ts_finish ? (out << to_string(ts_finish)) : (out << "<null>"));
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ")";
}


SpecColumn::~SpecColumn() noexcept {
}


void SpecColumn::__set_cid(const int64_t val) {
  this->cid = val;
}

void SpecColumn::__set_intervals(const std::vector<SpecInterval> & val) {
  this->intervals = val;
}
std::ostream& operator<<(std::ostream& out, const SpecColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->intervals.clear();
            uint32_t _size113;
            ::apache::thrift::protocol::TType _etype116;
            xfer += iprot->readListBegin(_etype116, _size113);
            this->intervals.resize(_size113);
            uint32_t _i117;
            for (_i117 = 0; _i117 < _size113; ++_i117)
            {
              xfer += this->intervals[_i117].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecColumn");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intervals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->intervals.size()));
    std::vector<SpecInterval> ::const_iterator _iter118;
    for (_iter118 = this->intervals.begin(); _iter118 != this->intervals.end(); ++_iter118)
    {
      xfer += (*_iter118).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecColumn &a, SpecColumn &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.intervals, b.intervals);
  swap(a.__isset, b.__isset);
}

SpecColumn::SpecColumn(const SpecColumn& other119) {
  cid = other119.cid;
  intervals = other119.intervals;
  __isset = other119.__isset;
}
SpecColumn::SpecColumn(SpecColumn&& other120) noexcept {
  cid = other120.cid;
  intervals = std::move(other120.intervals);
  __isset = other120.__isset;
}
SpecColumn& SpecColumn::operator=(const SpecColumn& other121) {
  cid = other121.cid;
  intervals = other121.intervals;
  __isset = other121.__isset;
  return *this;
}
SpecColumn& SpecColumn::operator=(SpecColumn&& other122) noexcept {
  cid = other122.cid;
  intervals = std::move(other122.intervals);
  __isset = other122.__isset;
  return *this;
}
void SpecColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecColumn(";
  out << "cid=" << to_string(cid);
  out << ", " << "intervals=" << to_string(intervals);
  out << ")";
}


SpecValueSerial_INT64::~SpecValueSerial_INT64() noexcept {
}


void SpecValueSerial_INT64::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_INT64::__set_v(const int64_t val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_INT64& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_INT64::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast123;
          xfer += iprot->readI32(ecast123);
          this->comp = static_cast<Comp::type>(ecast123);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_INT64::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_INT64");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_INT64 &a, SpecValueSerial_INT64 &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_INT64::SpecValueSerial_INT64(const SpecValueSerial_INT64& other124) noexcept {
  comp = other124.comp;
  v = other124.v;
  __isset = other124.__isset;
}
SpecValueSerial_INT64::SpecValueSerial_INT64(SpecValueSerial_INT64&& other125) noexcept {
  comp = other125.comp;
  v = other125.v;
  __isset = other125.__isset;
}
SpecValueSerial_INT64& SpecValueSerial_INT64::operator=(const SpecValueSerial_INT64& other126) noexcept {
  comp = other126.comp;
  v = other126.v;
  __isset = other126.__isset;
  return *this;
}
SpecValueSerial_INT64& SpecValueSerial_INT64::operator=(SpecValueSerial_INT64&& other127) noexcept {
  comp = other127.comp;
  v = other127.v;
  __isset = other127.__isset;
  return *this;
}
void SpecValueSerial_INT64::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_INT64(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_DOUBLE::~SpecValueSerial_DOUBLE() noexcept {
}


void SpecValueSerial_DOUBLE::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_DOUBLE::__set_v(const double val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_DOUBLE& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_DOUBLE::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast128;
          xfer += iprot->readI32(ecast128);
          this->comp = static_cast<Comp::type>(ecast128);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_DOUBLE::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_DOUBLE");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_DOUBLE &a, SpecValueSerial_DOUBLE &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_DOUBLE::SpecValueSerial_DOUBLE(const SpecValueSerial_DOUBLE& other129) noexcept {
  comp = other129.comp;
  v = other129.v;
  __isset = other129.__isset;
}
SpecValueSerial_DOUBLE::SpecValueSerial_DOUBLE(SpecValueSerial_DOUBLE&& other130) noexcept {
  comp = other130.comp;
  v = other130.v;
  __isset = other130.__isset;
}
SpecValueSerial_DOUBLE& SpecValueSerial_DOUBLE::operator=(const SpecValueSerial_DOUBLE& other131) noexcept {
  comp = other131.comp;
  v = other131.v;
  __isset = other131.__isset;
  return *this;
}
SpecValueSerial_DOUBLE& SpecValueSerial_DOUBLE::operator=(SpecValueSerial_DOUBLE&& other132) noexcept {
  comp = other132.comp;
  v = other132.v;
  __isset = other132.__isset;
  return *this;
}
void SpecValueSerial_DOUBLE::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_DOUBLE(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_BYTES::~SpecValueSerial_BYTES() noexcept {
}


void SpecValueSerial_BYTES::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_BYTES::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_BYTES& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_BYTES::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast133;
          xfer += iprot->readI32(ecast133);
          this->comp = static_cast<Comp::type>(ecast133);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_BYTES::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_BYTES");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_BYTES &a, SpecValueSerial_BYTES &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_BYTES::SpecValueSerial_BYTES(const SpecValueSerial_BYTES& other134) {
  comp = other134.comp;
  v = other134.v;
  __isset = other134.__isset;
}
SpecValueSerial_BYTES::SpecValueSerial_BYTES(SpecValueSerial_BYTES&& other135) noexcept {
  comp = other135.comp;
  v = std::move(other135.v);
  __isset = other135.__isset;
}
SpecValueSerial_BYTES& SpecValueSerial_BYTES::operator=(const SpecValueSerial_BYTES& other136) {
  comp = other136.comp;
  v = other136.v;
  __isset = other136.__isset;
  return *this;
}
SpecValueSerial_BYTES& SpecValueSerial_BYTES::operator=(SpecValueSerial_BYTES&& other137) noexcept {
  comp = other137.comp;
  v = std::move(other137.v);
  __isset = other137.__isset;
  return *this;
}
void SpecValueSerial_BYTES::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_BYTES(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_KEY::~SpecValueSerial_KEY() noexcept {
}


void SpecValueSerial_KEY::__set_seq(const KeySeq::type val) {
  this->seq = val;
}

void SpecValueSerial_KEY::__set_v(const SpecKey& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_KEY& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_KEY::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast138;
          xfer += iprot->readI32(ecast138);
          this->seq = static_cast<KeySeq::type>(ecast138);
          this->__isset.seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size139;
            ::apache::thrift::protocol::TType _etype142;
            xfer += iprot->readListBegin(_etype142, _size139);
            this->v.resize(_size139);
            uint32_t _i143;
            for (_i143 = 0; _i143 < _size139; ++_i143)
            {
              xfer += this->v[_i143].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_KEY::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_KEY");

  xfer += oprot->writeFieldBegin("seq", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->seq));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<SpecFraction> ::const_iterator _iter144;
    for (_iter144 = this->v.begin(); _iter144 != this->v.end(); ++_iter144)
    {
      xfer += (*_iter144).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_KEY &a, SpecValueSerial_KEY &b) {
  using ::std::swap;
  swap(a.seq, b.seq);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_KEY::SpecValueSerial_KEY(const SpecValueSerial_KEY& other145) {
  seq = other145.seq;
  v = other145.v;
  __isset = other145.__isset;
}
SpecValueSerial_KEY::SpecValueSerial_KEY(SpecValueSerial_KEY&& other146) noexcept {
  seq = other146.seq;
  v = std::move(other146.v);
  __isset = other146.__isset;
}
SpecValueSerial_KEY& SpecValueSerial_KEY::operator=(const SpecValueSerial_KEY& other147) {
  seq = other147.seq;
  v = other147.v;
  __isset = other147.__isset;
  return *this;
}
SpecValueSerial_KEY& SpecValueSerial_KEY::operator=(SpecValueSerial_KEY&& other148) noexcept {
  seq = other148.seq;
  v = std::move(other148.v);
  __isset = other148.__isset;
  return *this;
}
void SpecValueSerial_KEY::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_KEY(";
  out << "seq=" << to_string(seq);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_LI::~SpecValueSerial_LI() noexcept {
}


void SpecValueSerial_LI::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_LI::__set_v(const std::vector<SpecValueSerial_INT64> & val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_LI& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_LI::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast149;
          xfer += iprot->readI32(ecast149);
          this->comp = static_cast<Comp::type>(ecast149);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size150;
            ::apache::thrift::protocol::TType _etype153;
            xfer += iprot->readListBegin(_etype153, _size150);
            this->v.resize(_size150);
            uint32_t _i154;
            for (_i154 = 0; _i154 < _size150; ++_i154)
            {
              xfer += this->v[_i154].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_LI::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_LI");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<SpecValueSerial_INT64> ::const_iterator _iter155;
    for (_iter155 = this->v.begin(); _iter155 != this->v.end(); ++_iter155)
    {
      xfer += (*_iter155).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_LI &a, SpecValueSerial_LI &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_LI::SpecValueSerial_LI(const SpecValueSerial_LI& other156) {
  comp = other156.comp;
  v = other156.v;
  __isset = other156.__isset;
}
SpecValueSerial_LI::SpecValueSerial_LI(SpecValueSerial_LI&& other157) noexcept {
  comp = other157.comp;
  v = std::move(other157.v);
  __isset = other157.__isset;
}
SpecValueSerial_LI& SpecValueSerial_LI::operator=(const SpecValueSerial_LI& other158) {
  comp = other158.comp;
  v = other158.v;
  __isset = other158.__isset;
  return *this;
}
SpecValueSerial_LI& SpecValueSerial_LI::operator=(SpecValueSerial_LI&& other159) noexcept {
  comp = other159.comp;
  v = std::move(other159.v);
  __isset = other159.__isset;
  return *this;
}
void SpecValueSerial_LI::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_LI(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_LB::~SpecValueSerial_LB() noexcept {
}


void SpecValueSerial_LB::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_LB::__set_v(const std::vector<SpecValueSerial_BYTES> & val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_LB& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_LB::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast160;
          xfer += iprot->readI32(ecast160);
          this->comp = static_cast<Comp::type>(ecast160);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size161;
            ::apache::thrift::protocol::TType _etype164;
            xfer += iprot->readListBegin(_etype164, _size161);
            this->v.resize(_size161);
            uint32_t _i165;
            for (_i165 = 0; _i165 < _size161; ++_i165)
            {
              xfer += this->v[_i165].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_LB::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_LB");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<SpecValueSerial_BYTES> ::const_iterator _iter166;
    for (_iter166 = this->v.begin(); _iter166 != this->v.end(); ++_iter166)
    {
      xfer += (*_iter166).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_LB &a, SpecValueSerial_LB &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_LB::SpecValueSerial_LB(const SpecValueSerial_LB& other167) {
  comp = other167.comp;
  v = other167.v;
  __isset = other167.__isset;
}
SpecValueSerial_LB::SpecValueSerial_LB(SpecValueSerial_LB&& other168) noexcept {
  comp = other168.comp;
  v = std::move(other168.v);
  __isset = other168.__isset;
}
SpecValueSerial_LB& SpecValueSerial_LB::operator=(const SpecValueSerial_LB& other169) {
  comp = other169.comp;
  v = other169.v;
  __isset = other169.__isset;
  return *this;
}
SpecValueSerial_LB& SpecValueSerial_LB::operator=(SpecValueSerial_LB&& other170) noexcept {
  comp = other170.comp;
  v = std::move(other170.v);
  __isset = other170.__isset;
  return *this;
}
void SpecValueSerial_LB::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_LB(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerialField::~SpecValueSerialField() noexcept {
}


void SpecValueSerialField::__set_field_id(const int32_t val) {
  this->field_id = val;
}

void SpecValueSerialField::__set_spec_int64(const SpecValueSerial_INT64& val) {
  this->spec_int64 = val;
__isset.spec_int64 = true;
}

void SpecValueSerialField::__set_spec_double(const SpecValueSerial_DOUBLE& val) {
  this->spec_double = val;
__isset.spec_double = true;
}

void SpecValueSerialField::__set_spec_bytes(const SpecValueSerial_BYTES& val) {
  this->spec_bytes = val;
}

void SpecValueSerialField::__set_spec_key(const SpecValueSerial_KEY& val) {
  this->spec_key = val;
}

void SpecValueSerialField::__set_spec_li(const SpecValueSerial_LI& val) {
  this->spec_li = val;
}

void SpecValueSerialField::__set_spec_lb(const SpecValueSerial_LB& val) {
  this->spec_lb = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerialField& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerialField::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field_id);
          this->__isset.field_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_int64.read(iprot);
          this->__isset.spec_int64 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_double.read(iprot);
          this->__isset.spec_double = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_bytes.read(iprot);
          this->__isset.spec_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_key.read(iprot);
          this->__isset.spec_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_li.read(iprot);
          this->__isset.spec_li = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_lb.read(iprot);
          this->__isset.spec_lb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerialField::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerialField");

  xfer += oprot->writeFieldBegin("field_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.spec_int64) {
    xfer += oprot->writeFieldBegin("spec_int64", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->spec_int64.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.spec_double) {
    xfer += oprot->writeFieldBegin("spec_double", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->spec_double.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("spec_bytes", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->spec_bytes.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spec_key", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->spec_key.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spec_li", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->spec_li.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spec_lb", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->spec_lb.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerialField &a, SpecValueSerialField &b) {
  using ::std::swap;
  swap(a.field_id, b.field_id);
  swap(a.spec_int64, b.spec_int64);
  swap(a.spec_double, b.spec_double);
  swap(a.spec_bytes, b.spec_bytes);
  swap(a.spec_key, b.spec_key);
  swap(a.spec_li, b.spec_li);
  swap(a.spec_lb, b.spec_lb);
  swap(a.__isset, b.__isset);
}

SpecValueSerialField::SpecValueSerialField(const SpecValueSerialField& other171) {
  field_id = other171.field_id;
  spec_int64 = other171.spec_int64;
  spec_double = other171.spec_double;
  spec_bytes = other171.spec_bytes;
  spec_key = other171.spec_key;
  spec_li = other171.spec_li;
  spec_lb = other171.spec_lb;
  __isset = other171.__isset;
}
SpecValueSerialField::SpecValueSerialField(SpecValueSerialField&& other172) noexcept {
  field_id = other172.field_id;
  spec_int64 = std::move(other172.spec_int64);
  spec_double = std::move(other172.spec_double);
  spec_bytes = std::move(other172.spec_bytes);
  spec_key = std::move(other172.spec_key);
  spec_li = std::move(other172.spec_li);
  spec_lb = std::move(other172.spec_lb);
  __isset = other172.__isset;
}
SpecValueSerialField& SpecValueSerialField::operator=(const SpecValueSerialField& other173) {
  field_id = other173.field_id;
  spec_int64 = other173.spec_int64;
  spec_double = other173.spec_double;
  spec_bytes = other173.spec_bytes;
  spec_key = other173.spec_key;
  spec_li = other173.spec_li;
  spec_lb = other173.spec_lb;
  __isset = other173.__isset;
  return *this;
}
SpecValueSerialField& SpecValueSerialField::operator=(SpecValueSerialField&& other174) noexcept {
  field_id = other174.field_id;
  spec_int64 = std::move(other174.spec_int64);
  spec_double = std::move(other174.spec_double);
  spec_bytes = std::move(other174.spec_bytes);
  spec_key = std::move(other174.spec_key);
  spec_li = std::move(other174.spec_li);
  spec_lb = std::move(other174.spec_lb);
  __isset = other174.__isset;
  return *this;
}
void SpecValueSerialField::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerialField(";
  out << "field_id=" << to_string(field_id);
  out << ", " << "spec_int64="; (__isset.spec_int64 ? (out << to_string(spec_int64)) : (out << "<null>"));
  out << ", " << "spec_double="; (__isset.spec_double ? (out << to_string(spec_double)) : (out << "<null>"));
  out << ", " << "spec_bytes=" << to_string(spec_bytes);
  out << ", " << "spec_key=" << to_string(spec_key);
  out << ", " << "spec_li=" << to_string(spec_li);
  out << ", " << "spec_lb=" << to_string(spec_lb);
  out << ")";
}


SpecValueSerial::~SpecValueSerial() noexcept {
}


void SpecValueSerial::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial::__set_fields(const SpecValueSerialFields& val) {
  this->fields = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast175;
          xfer += iprot->readI32(ecast175);
          this->comp = static_cast<Comp::type>(ecast175);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size176;
            ::apache::thrift::protocol::TType _etype179;
            xfer += iprot->readListBegin(_etype179, _size176);
            this->fields.resize(_size176);
            uint32_t _i180;
            for (_i180 = 0; _i180 < _size176; ++_i180)
            {
              xfer += this->fields[_i180].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fields.size()));
    std::vector<SpecValueSerialField> ::const_iterator _iter181;
    for (_iter181 = this->fields.begin(); _iter181 != this->fields.end(); ++_iter181)
    {
      xfer += (*_iter181).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial &a, SpecValueSerial &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.fields, b.fields);
  swap(a.__isset, b.__isset);
}

SpecValueSerial::SpecValueSerial(const SpecValueSerial& other182) {
  comp = other182.comp;
  fields = other182.fields;
  __isset = other182.__isset;
}
SpecValueSerial::SpecValueSerial(SpecValueSerial&& other183) noexcept {
  comp = other183.comp;
  fields = std::move(other183.fields);
  __isset = other183.__isset;
}
SpecValueSerial& SpecValueSerial::operator=(const SpecValueSerial& other184) {
  comp = other184.comp;
  fields = other184.fields;
  __isset = other184.__isset;
  return *this;
}
SpecValueSerial& SpecValueSerial::operator=(SpecValueSerial&& other185) noexcept {
  comp = other185.comp;
  fields = std::move(other185.fields);
  __isset = other185.__isset;
  return *this;
}
void SpecValueSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial(";
  out << "comp=" << to_string(comp);
  out << ", " << "fields=" << to_string(fields);
  out << ")";
}


SpecIntervalSerial::~SpecIntervalSerial() noexcept {
}


void SpecIntervalSerial::__set_range_begin(const Key& val) {
  this->range_begin = val;
}

void SpecIntervalSerial::__set_range_end(const Key& val) {
  this->range_end = val;
}

void SpecIntervalSerial::__set_range_offset(const Key& val) {
  this->range_offset = val;
}

void SpecIntervalSerial::__set_offset_key(const Key& val) {
  this->offset_key = val;
}

void SpecIntervalSerial::__set_offset_rev(const int64_t val) {
  this->offset_rev = val;
__isset.offset_rev = true;
}

void SpecIntervalSerial::__set_key_intervals(const SpecKeyIntervals& val) {
  this->key_intervals = val;
}

void SpecIntervalSerial::__set_values(const SpecValuesSerial& val) {
  this->values = val;
}

void SpecIntervalSerial::__set_ts_start(const SpecTimestamp& val) {
  this->ts_start = val;
__isset.ts_start = true;
}

void SpecIntervalSerial::__set_ts_finish(const SpecTimestamp& val) {
  this->ts_finish = val;
__isset.ts_finish = true;
}

void SpecIntervalSerial::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}
std::ostream& operator<<(std::ostream& out, const SpecIntervalSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecIntervalSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_begin.clear();
            uint32_t _size186;
            ::apache::thrift::protocol::TType _etype189;
            xfer += iprot->readListBegin(_etype189, _size186);
            this->range_begin.resize(_size186);
            uint32_t _i190;
            for (_i190 = 0; _i190 < _size186; ++_i190)
            {
              xfer += iprot->readBinary(this->range_begin[_i190]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_end.clear();
            uint32_t _size191;
            ::apache::thrift::protocol::TType _etype194;
            xfer += iprot->readListBegin(_etype194, _size191);
            this->range_end.resize(_size191);
            uint32_t _i195;
            for (_i195 = 0; _i195 < _size191; ++_i195)
            {
              xfer += iprot->readBinary(this->range_end[_i195]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_offset.clear();
            uint32_t _size196;
            ::apache::thrift::protocol::TType _etype199;
            xfer += iprot->readListBegin(_etype199, _size196);
            this->range_offset.resize(_size196);
            uint32_t _i200;
            for (_i200 = 0; _i200 < _size196; ++_i200)
            {
              xfer += iprot->readBinary(this->range_offset[_i200]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->offset_key.clear();
            uint32_t _size201;
            ::apache::thrift::protocol::TType _etype204;
            xfer += iprot->readListBegin(_etype204, _size201);
            this->offset_key.resize(_size201);
            uint32_t _i205;
            for (_i205 = 0; _i205 < _size201; ++_i205)
            {
              xfer += iprot->readBinary(this->offset_key[_i205]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.offset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset_rev);
          this->__isset.offset_rev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_intervals.clear();
            uint32_t _size206;
            ::apache::thrift::protocol::TType _etype209;
            xfer += iprot->readListBegin(_etype209, _size206);
            this->key_intervals.resize(_size206);
            uint32_t _i210;
            for (_i210 = 0; _i210 < _size206; ++_i210)
            {
              xfer += this->key_intervals[_i210].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size211;
            ::apache::thrift::protocol::TType _etype214;
            xfer += iprot->readListBegin(_etype214, _size211);
            this->values.resize(_size211);
            uint32_t _i215;
            for (_i215 = 0; _i215 < _size211; ++_i215)
            {
              xfer += this->values[_i215].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_start.read(iprot);
          this->__isset.ts_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_finish.read(iprot);
          this->__isset.ts_finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecIntervalSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecIntervalSerial");

  xfer += oprot->writeFieldBegin("range_begin", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_begin.size()));
    std::vector<std::string> ::const_iterator _iter216;
    for (_iter216 = this->range_begin.begin(); _iter216 != this->range_begin.end(); ++_iter216)
    {
      xfer += oprot->writeBinary((*_iter216));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range_end", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_end.size()));
    std::vector<std::string> ::const_iterator _iter217;
    for (_iter217 = this->range_end.begin(); _iter217 != this->range_end.end(); ++_iter217)
    {
      xfer += oprot->writeBinary((*_iter217));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range_offset", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_offset.size()));
    std::vector<std::string> ::const_iterator _iter218;
    for (_iter218 = this->range_offset.begin(); _iter218 != this->range_offset.end(); ++_iter218)
    {
      xfer += oprot->writeBinary((*_iter218));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset_key", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->offset_key.size()));
    std::vector<std::string> ::const_iterator _iter219;
    for (_iter219 = this->offset_key.begin(); _iter219 != this->offset_key.end(); ++_iter219)
    {
      xfer += oprot->writeBinary((*_iter219));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offset_rev) {
    xfer += oprot->writeFieldBegin("offset_rev", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->offset_rev);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("key_intervals", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->key_intervals.size()));
    std::vector<SpecKeyInterval> ::const_iterator _iter220;
    for (_iter220 = this->key_intervals.begin(); _iter220 != this->key_intervals.end(); ++_iter220)
    {
      xfer += (*_iter220).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector<SpecValueSerial> ::const_iterator _iter221;
    for (_iter221 = this->values.begin(); _iter221 != this->values.end(); ++_iter221)
    {
      xfer += (*_iter221).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts_start) {
    xfer += oprot->writeFieldBegin("ts_start", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->ts_start.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_finish) {
    xfer += oprot->writeFieldBegin("ts_finish", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->ts_finish.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecIntervalSerial &a, SpecIntervalSerial &b) {
  using ::std::swap;
  swap(a.range_begin, b.range_begin);
  swap(a.range_end, b.range_end);
  swap(a.range_offset, b.range_offset);
  swap(a.offset_key, b.offset_key);
  swap(a.offset_rev, b.offset_rev);
  swap(a.key_intervals, b.key_intervals);
  swap(a.values, b.values);
  swap(a.ts_start, b.ts_start);
  swap(a.ts_finish, b.ts_finish);
  swap(a.flags, b.flags);
  swap(a.__isset, b.__isset);
}

SpecIntervalSerial::SpecIntervalSerial(const SpecIntervalSerial& other222) {
  range_begin = other222.range_begin;
  range_end = other222.range_end;
  range_offset = other222.range_offset;
  offset_key = other222.offset_key;
  offset_rev = other222.offset_rev;
  key_intervals = other222.key_intervals;
  values = other222.values;
  ts_start = other222.ts_start;
  ts_finish = other222.ts_finish;
  flags = other222.flags;
  __isset = other222.__isset;
}
SpecIntervalSerial::SpecIntervalSerial(SpecIntervalSerial&& other223) noexcept {
  range_begin = std::move(other223.range_begin);
  range_end = std::move(other223.range_end);
  range_offset = std::move(other223.range_offset);
  offset_key = std::move(other223.offset_key);
  offset_rev = other223.offset_rev;
  key_intervals = std::move(other223.key_intervals);
  values = std::move(other223.values);
  ts_start = std::move(other223.ts_start);
  ts_finish = std::move(other223.ts_finish);
  flags = std::move(other223.flags);
  __isset = other223.__isset;
}
SpecIntervalSerial& SpecIntervalSerial::operator=(const SpecIntervalSerial& other224) {
  range_begin = other224.range_begin;
  range_end = other224.range_end;
  range_offset = other224.range_offset;
  offset_key = other224.offset_key;
  offset_rev = other224.offset_rev;
  key_intervals = other224.key_intervals;
  values = other224.values;
  ts_start = other224.ts_start;
  ts_finish = other224.ts_finish;
  flags = other224.flags;
  __isset = other224.__isset;
  return *this;
}
SpecIntervalSerial& SpecIntervalSerial::operator=(SpecIntervalSerial&& other225) noexcept {
  range_begin = std::move(other225.range_begin);
  range_end = std::move(other225.range_end);
  range_offset = std::move(other225.range_offset);
  offset_key = std::move(other225.offset_key);
  offset_rev = other225.offset_rev;
  key_intervals = std::move(other225.key_intervals);
  values = std::move(other225.values);
  ts_start = std::move(other225.ts_start);
  ts_finish = std::move(other225.ts_finish);
  flags = std::move(other225.flags);
  __isset = other225.__isset;
  return *this;
}
void SpecIntervalSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecIntervalSerial(";
  out << "range_begin=" << to_string(range_begin);
  out << ", " << "range_end=" << to_string(range_end);
  out << ", " << "range_offset=" << to_string(range_offset);
  out << ", " << "offset_key=" << to_string(offset_key);
  out << ", " << "offset_rev="; (__isset.offset_rev ? (out << to_string(offset_rev)) : (out << "<null>"));
  out << ", " << "key_intervals=" << to_string(key_intervals);
  out << ", " << "values=" << to_string(values);
  out << ", " << "ts_start="; (__isset.ts_start ? (out << to_string(ts_start)) : (out << "<null>"));
  out << ", " << "ts_finish="; (__isset.ts_finish ? (out << to_string(ts_finish)) : (out << "<null>"));
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ")";
}


SpecColumnSerial::~SpecColumnSerial() noexcept {
}


void SpecColumnSerial::__set_cid(const int64_t val) {
  this->cid = val;
}

void SpecColumnSerial::__set_intervals(const std::vector<SpecIntervalSerial> & val) {
  this->intervals = val;
}
std::ostream& operator<<(std::ostream& out, const SpecColumnSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecColumnSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->intervals.clear();
            uint32_t _size226;
            ::apache::thrift::protocol::TType _etype229;
            xfer += iprot->readListBegin(_etype229, _size226);
            this->intervals.resize(_size226);
            uint32_t _i230;
            for (_i230 = 0; _i230 < _size226; ++_i230)
            {
              xfer += this->intervals[_i230].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecColumnSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecColumnSerial");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intervals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->intervals.size()));
    std::vector<SpecIntervalSerial> ::const_iterator _iter231;
    for (_iter231 = this->intervals.begin(); _iter231 != this->intervals.end(); ++_iter231)
    {
      xfer += (*_iter231).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecColumnSerial &a, SpecColumnSerial &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.intervals, b.intervals);
  swap(a.__isset, b.__isset);
}

SpecColumnSerial::SpecColumnSerial(const SpecColumnSerial& other232) {
  cid = other232.cid;
  intervals = other232.intervals;
  __isset = other232.__isset;
}
SpecColumnSerial::SpecColumnSerial(SpecColumnSerial&& other233) noexcept {
  cid = other233.cid;
  intervals = std::move(other233.intervals);
  __isset = other233.__isset;
}
SpecColumnSerial& SpecColumnSerial::operator=(const SpecColumnSerial& other234) {
  cid = other234.cid;
  intervals = other234.intervals;
  __isset = other234.__isset;
  return *this;
}
SpecColumnSerial& SpecColumnSerial::operator=(SpecColumnSerial&& other235) noexcept {
  cid = other235.cid;
  intervals = std::move(other235.intervals);
  __isset = other235.__isset;
  return *this;
}
void SpecColumnSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecColumnSerial(";
  out << "cid=" << to_string(cid);
  out << ", " << "intervals=" << to_string(intervals);
  out << ")";
}


SpecScan::~SpecScan() noexcept {
}


void SpecScan::__set_columns(const std::vector<SpecColumn> & val) {
  this->columns = val;
}

void SpecScan::__set_columns_serial(const std::vector<SpecColumnSerial> & val) {
  this->columns_serial = val;
}

void SpecScan::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}
std::ostream& operator<<(std::ostream& out, const SpecScan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecScan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size236;
            ::apache::thrift::protocol::TType _etype239;
            xfer += iprot->readListBegin(_etype239, _size236);
            this->columns.resize(_size236);
            uint32_t _i240;
            for (_i240 = 0; _i240 < _size236; ++_i240)
            {
              xfer += this->columns[_i240].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns_serial.clear();
            uint32_t _size241;
            ::apache::thrift::protocol::TType _etype244;
            xfer += iprot->readListBegin(_etype244, _size241);
            this->columns_serial.resize(_size241);
            uint32_t _i245;
            for (_i245 = 0; _i245 < _size241; ++_i245)
            {
              xfer += this->columns_serial[_i245].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns_serial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecScan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecScan");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<SpecColumn> ::const_iterator _iter246;
    for (_iter246 = this->columns.begin(); _iter246 != this->columns.end(); ++_iter246)
    {
      xfer += (*_iter246).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns_serial", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns_serial.size()));
    std::vector<SpecColumnSerial> ::const_iterator _iter247;
    for (_iter247 = this->columns_serial.begin(); _iter247 != this->columns_serial.end(); ++_iter247)
    {
      xfer += (*_iter247).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecScan &a, SpecScan &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.columns_serial, b.columns_serial);
  swap(a.flags, b.flags);
  swap(a.__isset, b.__isset);
}

SpecScan::SpecScan(const SpecScan& other248) {
  columns = other248.columns;
  columns_serial = other248.columns_serial;
  flags = other248.flags;
  __isset = other248.__isset;
}
SpecScan::SpecScan(SpecScan&& other249) noexcept {
  columns = std::move(other249.columns);
  columns_serial = std::move(other249.columns_serial);
  flags = std::move(other249.flags);
  __isset = other249.__isset;
}
SpecScan& SpecScan::operator=(const SpecScan& other250) {
  columns = other250.columns;
  columns_serial = other250.columns_serial;
  flags = other250.flags;
  __isset = other250.__isset;
  return *this;
}
SpecScan& SpecScan::operator=(SpecScan&& other251) noexcept {
  columns = std::move(other251.columns);
  columns_serial = std::move(other251.columns_serial);
  flags = std::move(other251.flags);
  __isset = other251.__isset;
  return *this;
}
void SpecScan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecScan(";
  out << "columns=" << to_string(columns);
  out << ", " << "columns_serial=" << to_string(columns_serial);
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ")";
}


UCell::~UCell() noexcept {
}


void UCell::__set_f(const Flag::type val) {
  this->f = val;
}

void UCell::__set_k(const Key& val) {
  this->k = val;
}

void UCell::__set_ts(const int64_t val) {
  this->ts = val;
__isset.ts = true;
}

void UCell::__set_ts_desc(const bool val) {
  this->ts_desc = val;
__isset.ts_desc = true;
}

void UCell::__set_v(const std::string& val) {
  this->v = val;
}

void UCell::__set_encoder(const EncodingType::type val) {
  this->encoder = val;
__isset.encoder = true;
}
std::ostream& operator<<(std::ostream& out, const UCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast252;
          xfer += iprot->readI32(ecast252);
          this->f = static_cast<Flag::type>(ecast252);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size253;
            ::apache::thrift::protocol::TType _etype256;
            xfer += iprot->readListBegin(_etype256, _size253);
            this->k.resize(_size253);
            uint32_t _i257;
            for (_i257 = 0; _i257 < _size253; ++_i257)
            {
              xfer += iprot->readBinary(this->k[_i257]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ts_desc);
          this->__isset.ts_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast258;
          xfer += iprot->readI32(ecast258);
          this->encoder = static_cast<EncodingType::type>(ecast258);
          this->__isset.encoder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UCell");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->f));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter259;
    for (_iter259 = this->k.begin(); _iter259 != this->k.end(); ++_iter259)
    {
      xfer += oprot->writeBinary((*_iter259));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts) {
    xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_desc) {
    xfer += oprot->writeFieldBegin("ts_desc", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->ts_desc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.encoder) {
    xfer += oprot->writeFieldBegin("encoder", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->encoder));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UCell &a, UCell &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.ts_desc, b.ts_desc);
  swap(a.v, b.v);
  swap(a.encoder, b.encoder);
  swap(a.__isset, b.__isset);
}

UCell::UCell(const UCell& other260) {
  f = other260.f;
  k = other260.k;
  ts = other260.ts;
  ts_desc = other260.ts_desc;
  v = other260.v;
  encoder = other260.encoder;
  __isset = other260.__isset;
}
UCell::UCell(UCell&& other261) noexcept {
  f = other261.f;
  k = std::move(other261.k);
  ts = other261.ts;
  ts_desc = other261.ts_desc;
  v = std::move(other261.v);
  encoder = other261.encoder;
  __isset = other261.__isset;
}
UCell& UCell::operator=(const UCell& other262) {
  f = other262.f;
  k = other262.k;
  ts = other262.ts;
  ts_desc = other262.ts_desc;
  v = other262.v;
  encoder = other262.encoder;
  __isset = other262.__isset;
  return *this;
}
UCell& UCell::operator=(UCell&& other263) noexcept {
  f = other263.f;
  k = std::move(other263.k);
  ts = other263.ts;
  ts_desc = other263.ts_desc;
  v = std::move(other263.v);
  encoder = other263.encoder;
  __isset = other263.__isset;
  return *this;
}
void UCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UCell(";
  out << "f=" << to_string(f);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts="; (__isset.ts ? (out << to_string(ts)) : (out << "<null>"));
  out << ", " << "ts_desc="; (__isset.ts_desc ? (out << to_string(ts_desc)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ", " << "encoder="; (__isset.encoder ? (out << to_string(encoder)) : (out << "<null>"));
  out << ")";
}


CellValueSerial::~CellValueSerial() noexcept {
}


void CellValueSerial::__set_field_id(const int32_t val) {
  this->field_id = val;
}

void CellValueSerial::__set_v_int64(const int64_t val) {
  this->v_int64 = val;
__isset.v_int64 = true;
}

void CellValueSerial::__set_v_double(const double val) {
  this->v_double = val;
__isset.v_double = true;
}

void CellValueSerial::__set_v_bytes(const std::string& val) {
  this->v_bytes = val;
}

void CellValueSerial::__set_v_key(const Key& val) {
  this->v_key = val;
}

void CellValueSerial::__set_v_li(const std::vector<int64_t> & val) {
  this->v_li = val;
}

void CellValueSerial::__set_v_lb(const std::vector<std::string> & val) {
  this->v_lb = val;
}
std::ostream& operator<<(std::ostream& out, const CellValueSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellValueSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field_id);
          this->__isset.field_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v_int64);
          this->__isset.v_int64 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v_double);
          this->__isset.v_double = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v_bytes);
          this->__isset.v_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_key.clear();
            uint32_t _size264;
            ::apache::thrift::protocol::TType _etype267;
            xfer += iprot->readListBegin(_etype267, _size264);
            this->v_key.resize(_size264);
            uint32_t _i268;
            for (_i268 = 0; _i268 < _size264; ++_i268)
            {
              xfer += iprot->readBinary(this->v_key[_i268]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_li.clear();
            uint32_t _size269;
            ::apache::thrift::protocol::TType _etype272;
            xfer += iprot->readListBegin(_etype272, _size269);
            this->v_li.resize(_size269);
            uint32_t _i273;
            for (_i273 = 0; _i273 < _size269; ++_i273)
            {
              xfer += iprot->readI64(this->v_li[_i273]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_li = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_lb.clear();
            uint32_t _size274;
            ::apache::thrift::protocol::TType _etype277;
            xfer += iprot->readListBegin(_etype277, _size274);
            this->v_lb.resize(_size274);
            uint32_t _i278;
            for (_i278 = 0; _i278 < _size274; ++_i278)
            {
              xfer += iprot->readBinary(this->v_lb[_i278]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_lb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellValueSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellValueSerial");

  xfer += oprot->writeFieldBegin("field_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.v_int64) {
    xfer += oprot->writeFieldBegin("v_int64", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->v_int64);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_double) {
    xfer += oprot->writeFieldBegin("v_double", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->v_double);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v_bytes", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->v_bytes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_key", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->v_key.size()));
    std::vector<std::string> ::const_iterator _iter279;
    for (_iter279 = this->v_key.begin(); _iter279 != this->v_key.end(); ++_iter279)
    {
      xfer += oprot->writeBinary((*_iter279));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_li", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->v_li.size()));
    std::vector<int64_t> ::const_iterator _iter280;
    for (_iter280 = this->v_li.begin(); _iter280 != this->v_li.end(); ++_iter280)
    {
      xfer += oprot->writeI64((*_iter280));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_lb", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->v_lb.size()));
    std::vector<std::string> ::const_iterator _iter281;
    for (_iter281 = this->v_lb.begin(); _iter281 != this->v_lb.end(); ++_iter281)
    {
      xfer += oprot->writeBinary((*_iter281));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellValueSerial &a, CellValueSerial &b) {
  using ::std::swap;
  swap(a.field_id, b.field_id);
  swap(a.v_int64, b.v_int64);
  swap(a.v_double, b.v_double);
  swap(a.v_bytes, b.v_bytes);
  swap(a.v_key, b.v_key);
  swap(a.v_li, b.v_li);
  swap(a.v_lb, b.v_lb);
  swap(a.__isset, b.__isset);
}

CellValueSerial::CellValueSerial(const CellValueSerial& other282) {
  field_id = other282.field_id;
  v_int64 = other282.v_int64;
  v_double = other282.v_double;
  v_bytes = other282.v_bytes;
  v_key = other282.v_key;
  v_li = other282.v_li;
  v_lb = other282.v_lb;
  __isset = other282.__isset;
}
CellValueSerial::CellValueSerial(CellValueSerial&& other283) noexcept {
  field_id = other283.field_id;
  v_int64 = other283.v_int64;
  v_double = other283.v_double;
  v_bytes = std::move(other283.v_bytes);
  v_key = std::move(other283.v_key);
  v_li = std::move(other283.v_li);
  v_lb = std::move(other283.v_lb);
  __isset = other283.__isset;
}
CellValueSerial& CellValueSerial::operator=(const CellValueSerial& other284) {
  field_id = other284.field_id;
  v_int64 = other284.v_int64;
  v_double = other284.v_double;
  v_bytes = other284.v_bytes;
  v_key = other284.v_key;
  v_li = other284.v_li;
  v_lb = other284.v_lb;
  __isset = other284.__isset;
  return *this;
}
CellValueSerial& CellValueSerial::operator=(CellValueSerial&& other285) noexcept {
  field_id = other285.field_id;
  v_int64 = other285.v_int64;
  v_double = other285.v_double;
  v_bytes = std::move(other285.v_bytes);
  v_key = std::move(other285.v_key);
  v_li = std::move(other285.v_li);
  v_lb = std::move(other285.v_lb);
  __isset = other285.__isset;
  return *this;
}
void CellValueSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellValueSerial(";
  out << "field_id=" << to_string(field_id);
  out << ", " << "v_int64="; (__isset.v_int64 ? (out << to_string(v_int64)) : (out << "<null>"));
  out << ", " << "v_double="; (__isset.v_double ? (out << to_string(v_double)) : (out << "<null>"));
  out << ", " << "v_bytes=" << to_string(v_bytes);
  out << ", " << "v_key=" << to_string(v_key);
  out << ", " << "v_li=" << to_string(v_li);
  out << ", " << "v_lb=" << to_string(v_lb);
  out << ")";
}


UCellSerial::~UCellSerial() noexcept {
}


void UCellSerial::__set_f(const Flag::type val) {
  this->f = val;
}

void UCellSerial::__set_k(const Key& val) {
  this->k = val;
}

void UCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
__isset.ts = true;
}

void UCellSerial::__set_ts_desc(const bool val) {
  this->ts_desc = val;
__isset.ts_desc = true;
}

void UCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}

void UCellSerial::__set_encoder(const EncodingType::type val) {
  this->encoder = val;
__isset.encoder = true;
}
std::ostream& operator<<(std::ostream& out, const UCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast286;
          xfer += iprot->readI32(ecast286);
          this->f = static_cast<Flag::type>(ecast286);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size287;
            ::apache::thrift::protocol::TType _etype290;
            xfer += iprot->readListBegin(_etype290, _size287);
            this->k.resize(_size287);
            uint32_t _i291;
            for (_i291 = 0; _i291 < _size287; ++_i291)
            {
              xfer += iprot->readBinary(this->k[_i291]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ts_desc);
          this->__isset.ts_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size292;
            ::apache::thrift::protocol::TType _etype295;
            xfer += iprot->readListBegin(_etype295, _size292);
            this->v.resize(_size292);
            uint32_t _i296;
            for (_i296 = 0; _i296 < _size292; ++_i296)
            {
              xfer += this->v[_i296].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast297;
          xfer += iprot->readI32(ecast297);
          this->encoder = static_cast<EncodingType::type>(ecast297);
          this->__isset.encoder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UCellSerial");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->f));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter298;
    for (_iter298 = this->k.begin(); _iter298 != this->k.end(); ++_iter298)
    {
      xfer += oprot->writeBinary((*_iter298));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts) {
    xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_desc) {
    xfer += oprot->writeFieldBegin("ts_desc", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->ts_desc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter299;
    for (_iter299 = this->v.begin(); _iter299 != this->v.end(); ++_iter299)
    {
      xfer += (*_iter299).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.encoder) {
    xfer += oprot->writeFieldBegin("encoder", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->encoder));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UCellSerial &a, UCellSerial &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.ts_desc, b.ts_desc);
  swap(a.v, b.v);
  swap(a.encoder, b.encoder);
  swap(a.__isset, b.__isset);
}

UCellSerial::UCellSerial(const UCellSerial& other300) {
  f = other300.f;
  k = other300.k;
  ts = other300.ts;
  ts_desc = other300.ts_desc;
  v = other300.v;
  encoder = other300.encoder;
  __isset = other300.__isset;
}
UCellSerial::UCellSerial(UCellSerial&& other301) noexcept {
  f = other301.f;
  k = std::move(other301.k);
  ts = other301.ts;
  ts_desc = other301.ts_desc;
  v = std::move(other301.v);
  encoder = other301.encoder;
  __isset = other301.__isset;
}
UCellSerial& UCellSerial::operator=(const UCellSerial& other302) {
  f = other302.f;
  k = other302.k;
  ts = other302.ts;
  ts_desc = other302.ts_desc;
  v = other302.v;
  encoder = other302.encoder;
  __isset = other302.__isset;
  return *this;
}
UCellSerial& UCellSerial::operator=(UCellSerial&& other303) noexcept {
  f = other303.f;
  k = std::move(other303.k);
  ts = other303.ts;
  ts_desc = other303.ts_desc;
  v = std::move(other303.v);
  encoder = other303.encoder;
  __isset = other303.__isset;
  return *this;
}
void UCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UCellSerial(";
  out << "f=" << to_string(f);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts="; (__isset.ts ? (out << to_string(ts)) : (out << "<null>"));
  out << ", " << "ts_desc="; (__isset.ts_desc ? (out << to_string(ts_desc)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ", " << "encoder="; (__isset.encoder ? (out << to_string(encoder)) : (out << "<null>"));
  out << ")";
}


Cell::~Cell() noexcept {
}


void Cell::__set_c(const std::string& val) {
  this->c = val;
}

void Cell::__set_k(const Key& val) {
  this->k = val;
}

void Cell::__set_ts(const int64_t val) {
  this->ts = val;
}

void Cell::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const Cell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size304;
            ::apache::thrift::protocol::TType _etype307;
            xfer += iprot->readListBegin(_etype307, _size304);
            this->k.resize(_size304);
            uint32_t _i308;
            for (_i308 = 0; _i308 < _size304; ++_i308)
            {
              xfer += iprot->readBinary(this->k[_i308]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cell");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter309;
    for (_iter309 = this->k.begin(); _iter309 != this->k.end(); ++_iter309)
    {
      xfer += oprot->writeBinary((*_iter309));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cell &a, Cell &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

Cell::Cell(const Cell& other310) {
  c = other310.c;
  k = other310.k;
  ts = other310.ts;
  v = other310.v;
  __isset = other310.__isset;
}
Cell::Cell(Cell&& other311) noexcept {
  c = std::move(other311.c);
  k = std::move(other311.k);
  ts = other311.ts;
  v = std::move(other311.v);
  __isset = other311.__isset;
}
Cell& Cell::operator=(const Cell& other312) {
  c = other312.c;
  k = other312.k;
  ts = other312.ts;
  v = other312.v;
  __isset = other312.__isset;
  return *this;
}
Cell& Cell::operator=(Cell&& other313) noexcept {
  c = std::move(other313.c);
  k = std::move(other313.k);
  ts = other313.ts;
  v = std::move(other313.v);
  __isset = other313.__isset;
  return *this;
}
void Cell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cell(";
  out << "c=" << to_string(c);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


CellSerial::~CellSerial() noexcept {
}


void CellSerial::__set_c(const std::string& val) {
  this->c = val;
}

void CellSerial::__set_k(const Key& val) {
  this->k = val;
}

void CellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void CellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const CellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size314;
            ::apache::thrift::protocol::TType _etype317;
            xfer += iprot->readListBegin(_etype317, _size314);
            this->k.resize(_size314);
            uint32_t _i318;
            for (_i318 = 0; _i318 < _size314; ++_i318)
            {
              xfer += iprot->readBinary(this->k[_i318]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size319;
            ::apache::thrift::protocol::TType _etype322;
            xfer += iprot->readListBegin(_etype322, _size319);
            this->v.resize(_size319);
            uint32_t _i323;
            for (_i323 = 0; _i323 < _size319; ++_i323)
            {
              xfer += this->v[_i323].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellSerial");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter324;
    for (_iter324 = this->k.begin(); _iter324 != this->k.end(); ++_iter324)
    {
      xfer += oprot->writeBinary((*_iter324));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter325;
    for (_iter325 = this->v.begin(); _iter325 != this->v.end(); ++_iter325)
    {
      xfer += (*_iter325).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellSerial &a, CellSerial &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CellSerial::CellSerial(const CellSerial& other326) {
  c = other326.c;
  k = other326.k;
  ts = other326.ts;
  v = other326.v;
  __isset = other326.__isset;
}
CellSerial::CellSerial(CellSerial&& other327) noexcept {
  c = std::move(other327.c);
  k = std::move(other327.k);
  ts = other327.ts;
  v = std::move(other327.v);
  __isset = other327.__isset;
}
CellSerial& CellSerial::operator=(const CellSerial& other328) {
  c = other328.c;
  k = other328.k;
  ts = other328.ts;
  v = other328.v;
  __isset = other328.__isset;
  return *this;
}
CellSerial& CellSerial::operator=(CellSerial&& other329) noexcept {
  c = std::move(other329.c);
  k = std::move(other329.k);
  ts = other329.ts;
  v = std::move(other329.v);
  __isset = other329.__isset;
  return *this;
}
void CellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellSerial(";
  out << "c=" << to_string(c);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


Cells::~Cells() noexcept {
}


void Cells::__set_cells(const std::vector<Cell> & val) {
  this->cells = val;
}

void Cells::__set_serial_cells(const std::vector<CellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const Cells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size330;
            ::apache::thrift::protocol::TType _etype333;
            xfer += iprot->readListBegin(_etype333, _size330);
            this->cells.resize(_size330);
            uint32_t _i334;
            for (_i334 = 0; _i334 < _size330; ++_i334)
            {
              xfer += this->cells[_i334].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size335;
            ::apache::thrift::protocol::TType _etype338;
            xfer += iprot->readListBegin(_etype338, _size335);
            this->serial_cells.resize(_size335);
            uint32_t _i339;
            for (_i339 = 0; _i339 < _size335; ++_i339)
            {
              xfer += this->serial_cells[_i339].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cells");

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<Cell> ::const_iterator _iter340;
    for (_iter340 = this->cells.begin(); _iter340 != this->cells.end(); ++_iter340)
    {
      xfer += (*_iter340).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<CellSerial> ::const_iterator _iter341;
    for (_iter341 = this->serial_cells.begin(); _iter341 != this->serial_cells.end(); ++_iter341)
    {
      xfer += (*_iter341).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cells &a, Cells &b) {
  using ::std::swap;
  swap(a.cells, b.cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

Cells::Cells(const Cells& other342) {
  cells = other342.cells;
  serial_cells = other342.serial_cells;
  __isset = other342.__isset;
}
Cells::Cells(Cells&& other343) noexcept {
  cells = std::move(other343.cells);
  serial_cells = std::move(other343.serial_cells);
  __isset = other343.__isset;
}
Cells& Cells::operator=(const Cells& other344) {
  cells = other344.cells;
  serial_cells = other344.serial_cells;
  __isset = other344.__isset;
  return *this;
}
Cells& Cells::operator=(Cells&& other345) noexcept {
  cells = std::move(other345.cells);
  serial_cells = std::move(other345.serial_cells);
  __isset = other345.__isset;
  return *this;
}
void Cells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cells(";
  out << "cells=" << to_string(cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


CCell::~CCell() noexcept {
}


void CCell::__set_k(const Key& val) {
  this->k = val;
}

void CCell::__set_ts(const int64_t val) {
  this->ts = val;
}

void CCell::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const CCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size346;
            ::apache::thrift::protocol::TType _etype349;
            xfer += iprot->readListBegin(_etype349, _size346);
            this->k.resize(_size346);
            uint32_t _i350;
            for (_i350 = 0; _i350 < _size346; ++_i350)
            {
              xfer += iprot->readBinary(this->k[_i350]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCell");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter351;
    for (_iter351 = this->k.begin(); _iter351 != this->k.end(); ++_iter351)
    {
      xfer += oprot->writeBinary((*_iter351));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCell &a, CCell &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CCell::CCell(const CCell& other352) {
  k = other352.k;
  ts = other352.ts;
  v = other352.v;
  __isset = other352.__isset;
}
CCell::CCell(CCell&& other353) noexcept {
  k = std::move(other353.k);
  ts = other353.ts;
  v = std::move(other353.v);
  __isset = other353.__isset;
}
CCell& CCell::operator=(const CCell& other354) {
  k = other354.k;
  ts = other354.ts;
  v = other354.v;
  __isset = other354.__isset;
  return *this;
}
CCell& CCell::operator=(CCell&& other355) noexcept {
  k = std::move(other355.k);
  ts = other355.ts;
  v = std::move(other355.v);
  __isset = other355.__isset;
  return *this;
}
void CCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCell(";
  out << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


CCellSerial::~CCellSerial() noexcept {
}


void CCellSerial::__set_k(const Key& val) {
  this->k = val;
}

void CCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void CCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const CCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size356;
            ::apache::thrift::protocol::TType _etype359;
            xfer += iprot->readListBegin(_etype359, _size356);
            this->k.resize(_size356);
            uint32_t _i360;
            for (_i360 = 0; _i360 < _size356; ++_i360)
            {
              xfer += iprot->readBinary(this->k[_i360]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size361;
            ::apache::thrift::protocol::TType _etype364;
            xfer += iprot->readListBegin(_etype364, _size361);
            this->v.resize(_size361);
            uint32_t _i365;
            for (_i365 = 0; _i365 < _size361; ++_i365)
            {
              xfer += this->v[_i365].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCellSerial");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter366;
    for (_iter366 = this->k.begin(); _iter366 != this->k.end(); ++_iter366)
    {
      xfer += oprot->writeBinary((*_iter366));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter367;
    for (_iter367 = this->v.begin(); _iter367 != this->v.end(); ++_iter367)
    {
      xfer += (*_iter367).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCellSerial &a, CCellSerial &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CCellSerial::CCellSerial(const CCellSerial& other368) {
  k = other368.k;
  ts = other368.ts;
  v = other368.v;
  __isset = other368.__isset;
}
CCellSerial::CCellSerial(CCellSerial&& other369) noexcept {
  k = std::move(other369.k);
  ts = other369.ts;
  v = std::move(other369.v);
  __isset = other369.__isset;
}
CCellSerial& CCellSerial::operator=(const CCellSerial& other370) {
  k = other370.k;
  ts = other370.ts;
  v = other370.v;
  __isset = other370.__isset;
  return *this;
}
CCellSerial& CCellSerial::operator=(CCellSerial&& other371) noexcept {
  k = std::move(other371.k);
  ts = other371.ts;
  v = std::move(other371.v);
  __isset = other371.__isset;
  return *this;
}
void CCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCellSerial(";
  out << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


ColCells::~ColCells() noexcept {
}


void ColCells::__set_cells(const std::vector<CCell> & val) {
  this->cells = val;
}

void ColCells::__set_serial_cells(const std::vector<CCellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const ColCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size372;
            ::apache::thrift::protocol::TType _etype375;
            xfer += iprot->readListBegin(_etype375, _size372);
            this->cells.resize(_size372);
            uint32_t _i376;
            for (_i376 = 0; _i376 < _size372; ++_i376)
            {
              xfer += this->cells[_i376].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size377;
            ::apache::thrift::protocol::TType _etype380;
            xfer += iprot->readListBegin(_etype380, _size377);
            this->serial_cells.resize(_size377);
            uint32_t _i381;
            for (_i381 = 0; _i381 < _size377; ++_i381)
            {
              xfer += this->serial_cells[_i381].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColCells");

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<CCell> ::const_iterator _iter382;
    for (_iter382 = this->cells.begin(); _iter382 != this->cells.end(); ++_iter382)
    {
      xfer += (*_iter382).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<CCellSerial> ::const_iterator _iter383;
    for (_iter383 = this->serial_cells.begin(); _iter383 != this->serial_cells.end(); ++_iter383)
    {
      xfer += (*_iter383).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColCells &a, ColCells &b) {
  using ::std::swap;
  swap(a.cells, b.cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

ColCells::ColCells(const ColCells& other384) {
  cells = other384.cells;
  serial_cells = other384.serial_cells;
  __isset = other384.__isset;
}
ColCells::ColCells(ColCells&& other385) noexcept {
  cells = std::move(other385.cells);
  serial_cells = std::move(other385.serial_cells);
  __isset = other385.__isset;
}
ColCells& ColCells::operator=(const ColCells& other386) {
  cells = other386.cells;
  serial_cells = other386.serial_cells;
  __isset = other386.__isset;
  return *this;
}
ColCells& ColCells::operator=(ColCells&& other387) noexcept {
  cells = std::move(other387.cells);
  serial_cells = std::move(other387.serial_cells);
  __isset = other387.__isset;
  return *this;
}
void ColCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColCells(";
  out << "cells=" << to_string(cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


KCell::~KCell() noexcept {
}


void KCell::__set_c(const std::string& val) {
  this->c = val;
}

void KCell::__set_ts(const int64_t val) {
  this->ts = val;
}

void KCell::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const KCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KCell");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KCell &a, KCell &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

KCell::KCell(const KCell& other388) {
  c = other388.c;
  ts = other388.ts;
  v = other388.v;
  __isset = other388.__isset;
}
KCell::KCell(KCell&& other389) noexcept {
  c = std::move(other389.c);
  ts = other389.ts;
  v = std::move(other389.v);
  __isset = other389.__isset;
}
KCell& KCell::operator=(const KCell& other390) {
  c = other390.c;
  ts = other390.ts;
  v = other390.v;
  __isset = other390.__isset;
  return *this;
}
KCell& KCell::operator=(KCell&& other391) noexcept {
  c = std::move(other391.c);
  ts = other391.ts;
  v = std::move(other391.v);
  __isset = other391.__isset;
  return *this;
}
void KCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KCell(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


KCellSerial::~KCellSerial() noexcept {
}


void KCellSerial::__set_c(const std::string& val) {
  this->c = val;
}

void KCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void KCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const KCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size392;
            ::apache::thrift::protocol::TType _etype395;
            xfer += iprot->readListBegin(_etype395, _size392);
            this->v.resize(_size392);
            uint32_t _i396;
            for (_i396 = 0; _i396 < _size392; ++_i396)
            {
              xfer += this->v[_i396].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KCellSerial");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter397;
    for (_iter397 = this->v.begin(); _iter397 != this->v.end(); ++_iter397)
    {
      xfer += (*_iter397).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KCellSerial &a, KCellSerial &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

KCellSerial::KCellSerial(const KCellSerial& other398) {
  c = other398.c;
  ts = other398.ts;
  v = other398.v;
  __isset = other398.__isset;
}
KCellSerial::KCellSerial(KCellSerial&& other399) noexcept {
  c = std::move(other399.c);
  ts = other399.ts;
  v = std::move(other399.v);
  __isset = other399.__isset;
}
KCellSerial& KCellSerial::operator=(const KCellSerial& other400) {
  c = other400.c;
  ts = other400.ts;
  v = other400.v;
  __isset = other400.__isset;
  return *this;
}
KCellSerial& KCellSerial::operator=(KCellSerial&& other401) noexcept {
  c = std::move(other401.c);
  ts = other401.ts;
  v = std::move(other401.v);
  __isset = other401.__isset;
  return *this;
}
void KCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KCellSerial(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


kCells::~kCells() noexcept {
}


void kCells::__set_k(const Key& val) {
  this->k = val;
}

void kCells::__set_cells(const std::vector<KCell> & val) {
  this->cells = val;
}

void kCells::__set_serial_cells(const std::vector<KCellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const kCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t kCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size402;
            ::apache::thrift::protocol::TType _etype405;
            xfer += iprot->readListBegin(_etype405, _size402);
            this->k.resize(_size402);
            uint32_t _i406;
            for (_i406 = 0; _i406 < _size402; ++_i406)
            {
              xfer += iprot->readBinary(this->k[_i406]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size407;
            ::apache::thrift::protocol::TType _etype410;
            xfer += iprot->readListBegin(_etype410, _size407);
            this->cells.resize(_size407);
            uint32_t _i411;
            for (_i411 = 0; _i411 < _size407; ++_i411)
            {
              xfer += this->cells[_i411].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size412;
            ::apache::thrift::protocol::TType _etype415;
            xfer += iprot->readListBegin(_etype415, _size412);
            this->serial_cells.resize(_size412);
            uint32_t _i416;
            for (_i416 = 0; _i416 < _size412; ++_i416)
            {
              xfer += this->serial_cells[_i416].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kCells");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter417;
    for (_iter417 = this->k.begin(); _iter417 != this->k.end(); ++_iter417)
    {
      xfer += oprot->writeBinary((*_iter417));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<KCell> ::const_iterator _iter418;
    for (_iter418 = this->cells.begin(); _iter418 != this->cells.end(); ++_iter418)
    {
      xfer += (*_iter418).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<KCellSerial> ::const_iterator _iter419;
    for (_iter419 = this->serial_cells.begin(); _iter419 != this->serial_cells.end(); ++_iter419)
    {
      xfer += (*_iter419).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(kCells &a, kCells &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.cells, b.cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

kCells::kCells(const kCells& other420) {
  k = other420.k;
  cells = other420.cells;
  serial_cells = other420.serial_cells;
  __isset = other420.__isset;
}
kCells::kCells(kCells&& other421) noexcept {
  k = std::move(other421.k);
  cells = std::move(other421.cells);
  serial_cells = std::move(other421.serial_cells);
  __isset = other421.__isset;
}
kCells& kCells::operator=(const kCells& other422) {
  k = other422.k;
  cells = other422.cells;
  serial_cells = other422.serial_cells;
  __isset = other422.__isset;
  return *this;
}
kCells& kCells::operator=(kCells&& other423) noexcept {
  k = std::move(other423.k);
  cells = std::move(other423.cells);
  serial_cells = std::move(other423.serial_cells);
  __isset = other423.__isset;
  return *this;
}
void kCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "kCells(";
  out << "k=" << to_string(k);
  out << ", " << "cells=" << to_string(cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


FCell::~FCell() noexcept {
}


void FCell::__set_c(const std::string& val) {
  this->c = val;
}

void FCell::__set_ts(const int64_t val) {
  this->ts = val;
}

void FCell::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCell");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCell &a, FCell &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FCell::FCell(const FCell& other424) {
  c = other424.c;
  ts = other424.ts;
  v = other424.v;
  __isset = other424.__isset;
}
FCell::FCell(FCell&& other425) noexcept {
  c = std::move(other425.c);
  ts = other425.ts;
  v = std::move(other425.v);
  __isset = other425.__isset;
}
FCell& FCell::operator=(const FCell& other426) {
  c = other426.c;
  ts = other426.ts;
  v = other426.v;
  __isset = other426.__isset;
  return *this;
}
FCell& FCell::operator=(FCell&& other427) noexcept {
  c = std::move(other427.c);
  ts = other427.ts;
  v = std::move(other427.v);
  __isset = other427.__isset;
  return *this;
}
void FCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCell(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FCellSerial::~FCellSerial() noexcept {
}


void FCellSerial::__set_c(const std::string& val) {
  this->c = val;
}

void FCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void FCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size428;
            ::apache::thrift::protocol::TType _etype431;
            xfer += iprot->readListBegin(_etype431, _size428);
            this->v.resize(_size428);
            uint32_t _i432;
            for (_i432 = 0; _i432 < _size428; ++_i432)
            {
              xfer += this->v[_i432].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCellSerial");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter433;
    for (_iter433 = this->v.begin(); _iter433 != this->v.end(); ++_iter433)
    {
      xfer += (*_iter433).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCellSerial &a, FCellSerial &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FCellSerial::FCellSerial(const FCellSerial& other434) {
  c = other434.c;
  ts = other434.ts;
  v = other434.v;
  __isset = other434.__isset;
}
FCellSerial::FCellSerial(FCellSerial&& other435) noexcept {
  c = std::move(other435.c);
  ts = other435.ts;
  v = std::move(other435.v);
  __isset = other435.__isset;
}
FCellSerial& FCellSerial::operator=(const FCellSerial& other436) {
  c = other436.c;
  ts = other436.ts;
  v = other436.v;
  __isset = other436.__isset;
  return *this;
}
FCellSerial& FCellSerial::operator=(FCellSerial&& other437) noexcept {
  c = std::move(other437.c);
  ts = other437.ts;
  v = std::move(other437.v);
  __isset = other437.__isset;
  return *this;
}
void FCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCellSerial(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FCells::~FCells() noexcept {
}


void FCells::__set_f(const std::map<std::string, FCells> & val) {
  this->f = val;
}

void FCells::__set_cells(const std::vector<FCell> & val) {
  this->cells = val;
}

void FCells::__set_serial_cells(const std::vector<FCellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const FCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->f.clear();
            uint32_t _size438;
            ::apache::thrift::protocol::TType _ktype439;
            ::apache::thrift::protocol::TType _vtype440;
            xfer += iprot->readMapBegin(_ktype439, _vtype440, _size438);
            uint32_t _i442;
            for (_i442 = 0; _i442 < _size438; ++_i442)
            {
              std::string _key443;
              xfer += iprot->readBinary(_key443);
              FCells& _val444 = this->f[_key443];
              xfer += _val444.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size445;
            ::apache::thrift::protocol::TType _etype448;
            xfer += iprot->readListBegin(_etype448, _size445);
            this->cells.resize(_size445);
            uint32_t _i449;
            for (_i449 = 0; _i449 < _size445; ++_i449)
            {
              xfer += this->cells[_i449].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size450;
            ::apache::thrift::protocol::TType _etype453;
            xfer += iprot->readListBegin(_etype453, _size450);
            this->serial_cells.resize(_size450);
            uint32_t _i454;
            for (_i454 = 0; _i454 < _size450; ++_i454)
            {
              xfer += this->serial_cells[_i454].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCells");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->f.size()));
    std::map<std::string, FCells> ::const_iterator _iter455;
    for (_iter455 = this->f.begin(); _iter455 != this->f.end(); ++_iter455)
    {
      xfer += oprot->writeBinary(_iter455->first);
      xfer += _iter455->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<FCell> ::const_iterator _iter456;
    for (_iter456 = this->cells.begin(); _iter456 != this->cells.end(); ++_iter456)
    {
      xfer += (*_iter456).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<FCellSerial> ::const_iterator _iter457;
    for (_iter457 = this->serial_cells.begin(); _iter457 != this->serial_cells.end(); ++_iter457)
    {
      xfer += (*_iter457).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCells &a, FCells &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.cells, b.cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

FCells::FCells(const FCells& other458) {
  f = other458.f;
  cells = other458.cells;
  serial_cells = other458.serial_cells;
  __isset = other458.__isset;
}
FCells::FCells(FCells&& other459) noexcept {
  f = std::move(other459.f);
  cells = std::move(other459.cells);
  serial_cells = std::move(other459.serial_cells);
  __isset = other459.__isset;
}
FCells& FCells::operator=(const FCells& other460) {
  f = other460.f;
  cells = other460.cells;
  serial_cells = other460.serial_cells;
  __isset = other460.__isset;
  return *this;
}
FCells& FCells::operator=(FCells&& other461) noexcept {
  f = std::move(other461.f);
  cells = std::move(other461.cells);
  serial_cells = std::move(other461.serial_cells);
  __isset = other461.__isset;
  return *this;
}
void FCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCells(";
  out << "f=" << to_string(f);
  out << ", " << "cells=" << to_string(cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


CellsGroup::~CellsGroup() noexcept {
}


void CellsGroup::__set_cells(const Cells& val) {
  this->cells = val;
}

void CellsGroup::__set_ccells(const CCells& val) {
  this->ccells = val;
}

void CellsGroup::__set_kcells(const KCells& val) {
  this->kcells = val;
}

void CellsGroup::__set_fcells(const FCells& val) {
  this->fcells = val;
}
std::ostream& operator<<(std::ostream& out, const CellsGroup& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellsGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cells.read(iprot);
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ccells.clear();
            uint32_t _size462;
            ::apache::thrift::protocol::TType _ktype463;
            ::apache::thrift::protocol::TType _vtype464;
            xfer += iprot->readMapBegin(_ktype463, _vtype464, _size462);
            uint32_t _i466;
            for (_i466 = 0; _i466 < _size462; ++_i466)
            {
              std::string _key467;
              xfer += iprot->readString(_key467);
              ColCells& _val468 = this->ccells[_key467];
              xfer += _val468.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ccells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->kcells.clear();
            uint32_t _size469;
            ::apache::thrift::protocol::TType _etype472;
            xfer += iprot->readListBegin(_etype472, _size469);
            this->kcells.resize(_size469);
            uint32_t _i473;
            for (_i473 = 0; _i473 < _size469; ++_i473)
            {
              xfer += this->kcells[_i473].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.kcells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fcells.read(iprot);
          this->__isset.fcells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellsGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellsGroup");

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cells.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ccells", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ccells.size()));
    std::map<std::string, ColCells> ::const_iterator _iter474;
    for (_iter474 = this->ccells.begin(); _iter474 != this->ccells.end(); ++_iter474)
    {
      xfer += oprot->writeString(_iter474->first);
      xfer += _iter474->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("kcells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->kcells.size()));
    std::vector<kCells> ::const_iterator _iter475;
    for (_iter475 = this->kcells.begin(); _iter475 != this->kcells.end(); ++_iter475)
    {
      xfer += (*_iter475).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fcells", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->fcells.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellsGroup &a, CellsGroup &b) {
  using ::std::swap;
  swap(a.cells, b.cells);
  swap(a.ccells, b.ccells);
  swap(a.kcells, b.kcells);
  swap(a.fcells, b.fcells);
  swap(a.__isset, b.__isset);
}

CellsGroup::CellsGroup(const CellsGroup& other476) {
  cells = other476.cells;
  ccells = other476.ccells;
  kcells = other476.kcells;
  fcells = other476.fcells;
  __isset = other476.__isset;
}
CellsGroup::CellsGroup(CellsGroup&& other477) noexcept {
  cells = std::move(other477.cells);
  ccells = std::move(other477.ccells);
  kcells = std::move(other477.kcells);
  fcells = std::move(other477.fcells);
  __isset = other477.__isset;
}
CellsGroup& CellsGroup::operator=(const CellsGroup& other478) {
  cells = other478.cells;
  ccells = other478.ccells;
  kcells = other478.kcells;
  fcells = other478.fcells;
  __isset = other478.__isset;
  return *this;
}
CellsGroup& CellsGroup::operator=(CellsGroup&& other479) noexcept {
  cells = std::move(other479.cells);
  ccells = std::move(other479.ccells);
  kcells = std::move(other479.kcells);
  fcells = std::move(other479.fcells);
  __isset = other479.__isset;
  return *this;
}
void CellsGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellsGroup(";
  out << "cells=" << to_string(cells);
  out << ", " << "ccells=" << to_string(ccells);
  out << ", " << "kcells=" << to_string(kcells);
  out << ", " << "fcells=" << to_string(fcells);
  out << ")";
}


CompactResult::~CompactResult() noexcept {
}


void CompactResult::__set_cid(const int64_t val) {
  this->cid = val;
}

void CompactResult::__set_err(const int32_t val) {
  this->err = val;
}
std::ostream& operator<<(std::ostream& out, const CompactResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->err);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CompactResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactResult");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->err);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactResult &a, CompactResult &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

CompactResult::CompactResult(const CompactResult& other480) noexcept {
  cid = other480.cid;
  err = other480.err;
  __isset = other480.__isset;
}
CompactResult::CompactResult(CompactResult&& other481) noexcept {
  cid = other481.cid;
  err = other481.err;
  __isset = other481.__isset;
}
CompactResult& CompactResult::operator=(const CompactResult& other482) noexcept {
  cid = other482.cid;
  err = other482.err;
  __isset = other482.__isset;
  return *this;
}
CompactResult& CompactResult::operator=(CompactResult&& other483) noexcept {
  cid = other483.cid;
  err = other483.err;
  __isset = other483.__isset;
  return *this;
}
void CompactResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactResult(";
  out << "cid=" << to_string(cid);
  out << ", " << "err=" << to_string(err);
  out << ")";
}


Result::~Result() noexcept {
}


void Result::__set_schemas(const Schemas& val) {
  this->schemas = val;
}

void Result::__set_cells(const Cells& val) {
  this->cells = val;
}

void Result::__set_compact(const CompactResults& val) {
  this->compact = val;
}
std::ostream& operator<<(std::ostream& out, const Result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->schemas.clear();
            uint32_t _size484;
            ::apache::thrift::protocol::TType _etype487;
            xfer += iprot->readListBegin(_etype487, _size484);
            this->schemas.resize(_size484);
            uint32_t _i488;
            for (_i488 = 0; _i488 < _size484; ++_i488)
            {
              xfer += this->schemas[_i488].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.schemas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cells.read(iprot);
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compact.clear();
            uint32_t _size489;
            ::apache::thrift::protocol::TType _etype492;
            xfer += iprot->readListBegin(_etype492, _size489);
            this->compact.resize(_size489);
            uint32_t _i493;
            for (_i493 = 0; _i493 < _size489; ++_i493)
            {
              xfer += this->compact[_i493].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.compact = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Result");

  xfer += oprot->writeFieldBegin("schemas", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->schemas.size()));
    std::vector<Schema> ::const_iterator _iter494;
    for (_iter494 = this->schemas.begin(); _iter494 != this->schemas.end(); ++_iter494)
    {
      xfer += (*_iter494).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->cells.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compact", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->compact.size()));
    std::vector<CompactResult> ::const_iterator _iter495;
    for (_iter495 = this->compact.begin(); _iter495 != this->compact.end(); ++_iter495)
    {
      xfer += (*_iter495).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Result &a, Result &b) {
  using ::std::swap;
  swap(a.schemas, b.schemas);
  swap(a.cells, b.cells);
  swap(a.compact, b.compact);
  swap(a.__isset, b.__isset);
}

Result::Result(const Result& other496) {
  schemas = other496.schemas;
  cells = other496.cells;
  compact = other496.compact;
  __isset = other496.__isset;
}
Result::Result(Result&& other497) noexcept {
  schemas = std::move(other497.schemas);
  cells = std::move(other497.cells);
  compact = std::move(other497.compact);
  __isset = other497.__isset;
}
Result& Result::operator=(const Result& other498) {
  schemas = other498.schemas;
  cells = other498.cells;
  compact = other498.compact;
  __isset = other498.__isset;
  return *this;
}
Result& Result::operator=(Result&& other499) noexcept {
  schemas = std::move(other499.schemas);
  cells = std::move(other499.cells);
  compact = std::move(other499.compact);
  __isset = other499.__isset;
  return *this;
}
void Result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Result(";
  out << "schemas=" << to_string(schemas);
  out << ", " << "cells=" << to_string(cells);
  out << ", " << "compact=" << to_string(compact);
  out << ")";
}

}} // namespace
