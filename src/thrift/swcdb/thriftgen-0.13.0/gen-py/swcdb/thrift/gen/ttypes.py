#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:slots,no_utf8strings
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec


from thrift.transport import TTransport
all_structs = []


class ColumnMng(object):
    CREATE = 3
    DELETE = 5
    MODIFY = 7

    _VALUES_TO_NAMES = {
        3: "CREATE",
        5: "DELETE",
        7: "MODIFY",
    }

    _NAMES_TO_VALUES = {
        "CREATE": 3,
        "DELETE": 5,
        "MODIFY": 7,
    }


class ColumnType(object):
    UNKNOWN = 0
    PLAIN = 1
    COUNTER_I64 = 2
    COUNTER_I32 = 3
    COUNTER_I16 = 4
    COUNTER_I8 = 5
    CELL_DEFINED = 15

    _VALUES_TO_NAMES = {
        0: "UNKNOWN",
        1: "PLAIN",
        2: "COUNTER_I64",
        3: "COUNTER_I32",
        4: "COUNTER_I16",
        5: "COUNTER_I8",
        15: "CELL_DEFINED",
    }

    _NAMES_TO_VALUES = {
        "UNKNOWN": 0,
        "PLAIN": 1,
        "COUNTER_I64": 2,
        "COUNTER_I32": 3,
        "COUNTER_I16": 4,
        "COUNTER_I8": 5,
        "CELL_DEFINED": 15,
    }


class EncodingType(object):
    DEFAULT = 0
    PLAIN = 1
    ZLIB = 2
    SNAPPY = 3
    UNKNOWN = 255

    _VALUES_TO_NAMES = {
        0: "DEFAULT",
        1: "PLAIN",
        2: "ZLIB",
        3: "SNAPPY",
        255: "UNKNOWN",
    }

    _NAMES_TO_VALUES = {
        "DEFAULT": 0,
        "PLAIN": 1,
        "ZLIB": 2,
        "SNAPPY": 3,
        "UNKNOWN": 255,
    }


class SchemaFunc(object):
    CREATE = 3
    DELETE = 5
    MODIFY = 7

    _VALUES_TO_NAMES = {
        3: "CREATE",
        5: "DELETE",
        7: "MODIFY",
    }

    _NAMES_TO_VALUES = {
        "CREATE": 3,
        "DELETE": 5,
        "MODIFY": 7,
    }


class Comp(object):
    NONE = 0
    PF = 1
    GT = 2
    GE = 3
    EQ = 4
    LE = 5
    LT = 6
    NE = 7
    RE = 8
    VGT = 9
    VGE = 10
    VLE = 11
    VLT = 12

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "PF",
        2: "GT",
        3: "GE",
        4: "EQ",
        5: "LE",
        6: "LT",
        7: "NE",
        8: "RE",
        9: "VGT",
        10: "VGE",
        11: "VLE",
        12: "VLT",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "PF": 1,
        "GT": 2,
        "GE": 3,
        "EQ": 4,
        "LE": 5,
        "LT": 6,
        "NE": 7,
        "RE": 8,
        "VGT": 9,
        "VGE": 10,
        "VLE": 11,
        "VLT": 12,
    }


class SpecFlagsOpt(object):
    NONE = 0
    LIMIT_BY_KEYS = 1
    OFFSET_BY_KEYS = 4
    ONLY_KEYS = 8
    ONLY_DELETES = 10

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "LIMIT_BY_KEYS",
        4: "OFFSET_BY_KEYS",
        8: "ONLY_KEYS",
        10: "ONLY_DELETES",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "LIMIT_BY_KEYS": 1,
        "OFFSET_BY_KEYS": 4,
        "ONLY_KEYS": 8,
        "ONLY_DELETES": 10,
    }


class Flag(object):
    NONE = 0
    INSERT = 1
    DELETE = 2
    DELETE_VERSION = 3

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "INSERT",
        2: "DELETE",
        3: "DELETE_VERSION",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "INSERT": 1,
        "DELETE": 2,
        "DELETE_VERSION": 3,
    }


class CellsResult(object):
    IN_LIST = 0
    ON_COLUMN = 1
    ON_KEY = 2
    ON_FRACTION = 3

    _VALUES_TO_NAMES = {
        0: "IN_LIST",
        1: "ON_COLUMN",
        2: "ON_KEY",
        3: "ON_FRACTION",
    }

    _NAMES_TO_VALUES = {
        "IN_LIST": 0,
        "ON_COLUMN": 1,
        "ON_KEY": 2,
        "ON_FRACTION": 3,
    }


class Exception(TException):
    """
    Attributes:
     - code
     - message

    """

    __slots__ = (
        'code',
        'message',
    )


    def __init__(self, code=None, message=None,):
        self.code = code
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Exception')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class Schema(object):
    """
    Attributes:
     - cid
     - col_name
     - col_type
     - cell_versions
     - cell_ttl
     - blk_encoding
     - blk_size
     - blk_cells
     - cs_replication
     - cs_size
     - cs_max
     - log_rollout_ratio
     - compact_percent
     - revision

    """

    __slots__ = (
        'cid',
        'col_name',
        'col_type',
        'cell_versions',
        'cell_ttl',
        'blk_encoding',
        'blk_size',
        'blk_cells',
        'cs_replication',
        'cs_size',
        'cs_max',
        'log_rollout_ratio',
        'compact_percent',
        'revision',
    )


    def __init__(self, cid=None, col_name=None, col_type=None, cell_versions=None, cell_ttl=None, blk_encoding=None, blk_size=None, blk_cells=None, cs_replication=None, cs_size=None, cs_max=None, log_rollout_ratio=None, compact_percent=None, revision=None,):
        self.cid = cid
        self.col_name = col_name
        self.col_type = col_type
        self.cell_versions = cell_versions
        self.cell_ttl = cell_ttl
        self.blk_encoding = blk_encoding
        self.blk_size = blk_size
        self.blk_cells = blk_cells
        self.cs_replication = cs_replication
        self.cs_size = cs_size
        self.cs_max = cs_max
        self.log_rollout_ratio = log_rollout_ratio
        self.compact_percent = compact_percent
        self.revision = revision

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.col_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.col_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.cell_versions = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.cell_ttl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.blk_encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.blk_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.blk_cells = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BYTE:
                    self.cs_replication = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.cs_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BYTE:
                    self.cs_max = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BYTE:
                    self.log_rollout_ratio = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BYTE:
                    self.compact_percent = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I64:
                    self.revision = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Schema')
        if self.cid is not None:
            oprot.writeFieldBegin('cid', TType.I64, 1)
            oprot.writeI64(self.cid)
            oprot.writeFieldEnd()
        if self.col_name is not None:
            oprot.writeFieldBegin('col_name', TType.STRING, 2)
            oprot.writeString(self.col_name)
            oprot.writeFieldEnd()
        if self.col_type is not None:
            oprot.writeFieldBegin('col_type', TType.I32, 3)
            oprot.writeI32(self.col_type)
            oprot.writeFieldEnd()
        if self.cell_versions is not None:
            oprot.writeFieldBegin('cell_versions', TType.I32, 4)
            oprot.writeI32(self.cell_versions)
            oprot.writeFieldEnd()
        if self.cell_ttl is not None:
            oprot.writeFieldBegin('cell_ttl', TType.I32, 5)
            oprot.writeI32(self.cell_ttl)
            oprot.writeFieldEnd()
        if self.blk_encoding is not None:
            oprot.writeFieldBegin('blk_encoding', TType.I32, 6)
            oprot.writeI32(self.blk_encoding)
            oprot.writeFieldEnd()
        if self.blk_size is not None:
            oprot.writeFieldBegin('blk_size', TType.I32, 7)
            oprot.writeI32(self.blk_size)
            oprot.writeFieldEnd()
        if self.blk_cells is not None:
            oprot.writeFieldBegin('blk_cells', TType.I32, 8)
            oprot.writeI32(self.blk_cells)
            oprot.writeFieldEnd()
        if self.cs_replication is not None:
            oprot.writeFieldBegin('cs_replication', TType.BYTE, 9)
            oprot.writeByte(self.cs_replication)
            oprot.writeFieldEnd()
        if self.cs_size is not None:
            oprot.writeFieldBegin('cs_size', TType.I32, 10)
            oprot.writeI32(self.cs_size)
            oprot.writeFieldEnd()
        if self.cs_max is not None:
            oprot.writeFieldBegin('cs_max', TType.BYTE, 11)
            oprot.writeByte(self.cs_max)
            oprot.writeFieldEnd()
        if self.log_rollout_ratio is not None:
            oprot.writeFieldBegin('log_rollout_ratio', TType.BYTE, 12)
            oprot.writeByte(self.log_rollout_ratio)
            oprot.writeFieldEnd()
        if self.compact_percent is not None:
            oprot.writeFieldBegin('compact_percent', TType.BYTE, 13)
            oprot.writeByte(self.compact_percent)
            oprot.writeFieldEnd()
        if self.revision is not None:
            oprot.writeFieldBegin('revision', TType.I64, 14)
            oprot.writeI64(self.revision)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecSchemas(object):
    """
    Attributes:
     - cids
     - names

    """

    __slots__ = (
        'cids',
        'names',
    )


    def __init__(self, cids=None, names=None,):
        self.cids = cids
        self.names = names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.cids = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI64()
                        self.cids.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.names = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readString()
                        self.names.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecSchemas')
        if self.cids is not None:
            oprot.writeFieldBegin('cids', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.cids))
            for iter12 in self.cids:
                oprot.writeI64(iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.names is not None:
            oprot.writeFieldBegin('names', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.names))
            for iter13 in self.names:
                oprot.writeString(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecFlags(object):
    """
    Attributes:
     - limit
     - offset
     - max_versions
     - max_buffer
     - options

    """

    __slots__ = (
        'limit',
        'offset',
        'max_versions',
        'max_buffer',
        'options',
    )


    def __init__(self, limit=None, offset=None, max_versions=None, max_buffer=None, options=None,):
        self.limit = limit
        self.offset = offset
        self.max_versions = max_versions
        self.max_buffer = max_buffer
        self.options = options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.max_versions = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.max_buffer = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BYTE:
                    self.options = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecFlags')
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 1)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 2)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.max_versions is not None:
            oprot.writeFieldBegin('max_versions', TType.I32, 3)
            oprot.writeI32(self.max_versions)
            oprot.writeFieldEnd()
        if self.max_buffer is not None:
            oprot.writeFieldBegin('max_buffer', TType.I32, 4)
            oprot.writeI32(self.max_buffer)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.BYTE, 5)
            oprot.writeByte(self.options)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecFraction(object):
    """
    Attributes:
     - comp
     - f

    """

    __slots__ = (
        'comp',
        'f',
    )


    def __init__(self, comp=None, f=None,):
        self.comp = comp
        self.f = f

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.f = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecFraction')
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 1)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.f is not None:
            oprot.writeFieldBegin('f', TType.STRING, 2)
            oprot.writeBinary(self.f)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecValue(object):
    """
    Attributes:
     - comp
     - v

    """

    __slots__ = (
        'comp',
        'v',
    )


    def __init__(self, comp=None, v=None,):
        self.comp = comp
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.v = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecValue')
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 1)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.STRING, 2)
            oprot.writeBinary(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecTimestamp(object):
    """
    Attributes:
     - comp
     - ts

    """

    __slots__ = (
        'comp',
        'ts',
    )


    def __init__(self, comp=None, ts=None,):
        self.comp = comp
        self.ts = ts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecTimestamp')
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 1)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 2)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecInterval(object):
    """
    Attributes:
     - range_begin
     - range_end
     - range_offset
     - offset_key
     - offset_rev
     - key_start
     - key_finish
     - value
     - ts_start
     - ts_finish
     - flags

    """

    __slots__ = (
        'range_begin',
        'range_end',
        'range_offset',
        'offset_key',
        'offset_rev',
        'key_start',
        'key_finish',
        'value',
        'ts_start',
        'ts_finish',
        'flags',
    )


    def __init__(self, range_begin=None, range_end=None, range_offset=None, offset_key=None, offset_rev=None, key_start=None, key_finish=None, value=None, ts_start=None, ts_finish=None, flags=None,):
        self.range_begin = range_begin
        self.range_end = range_end
        self.range_offset = range_offset
        self.offset_key = offset_key
        self.offset_rev = offset_rev
        self.key_start = key_start
        self.key_finish = key_finish
        self.value = value
        self.ts_start = ts_start
        self.ts_finish = ts_finish
        self.flags = flags

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.range_begin = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readBinary()
                        self.range_begin.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.range_end = []
                    (_etype23, _size20) = iprot.readListBegin()
                    for _i24 in range(_size20):
                        _elem25 = iprot.readBinary()
                        self.range_end.append(_elem25)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.range_offset = []
                    (_etype29, _size26) = iprot.readListBegin()
                    for _i30 in range(_size26):
                        _elem31 = iprot.readBinary()
                        self.range_offset.append(_elem31)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.offset_key = []
                    (_etype35, _size32) = iprot.readListBegin()
                    for _i36 in range(_size32):
                        _elem37 = iprot.readBinary()
                        self.offset_key.append(_elem37)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.offset_rev = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.key_start = []
                    (_etype41, _size38) = iprot.readListBegin()
                    for _i42 in range(_size38):
                        _elem43 = SpecFraction()
                        _elem43.read(iprot)
                        self.key_start.append(_elem43)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.key_finish = []
                    (_etype47, _size44) = iprot.readListBegin()
                    for _i48 in range(_size44):
                        _elem49 = SpecFraction()
                        _elem49.read(iprot)
                        self.key_finish.append(_elem49)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.value = SpecValue()
                    self.value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.ts_start = SpecTimestamp()
                    self.ts_start.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.ts_finish = SpecTimestamp()
                    self.ts_finish.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.flags = SpecFlags()
                    self.flags.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecInterval')
        if self.range_begin is not None:
            oprot.writeFieldBegin('range_begin', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.range_begin))
            for iter50 in self.range_begin:
                oprot.writeBinary(iter50)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.range_end is not None:
            oprot.writeFieldBegin('range_end', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.range_end))
            for iter51 in self.range_end:
                oprot.writeBinary(iter51)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.range_offset is not None:
            oprot.writeFieldBegin('range_offset', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.range_offset))
            for iter52 in self.range_offset:
                oprot.writeBinary(iter52)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.offset_key is not None:
            oprot.writeFieldBegin('offset_key', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.offset_key))
            for iter53 in self.offset_key:
                oprot.writeBinary(iter53)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.offset_rev is not None:
            oprot.writeFieldBegin('offset_rev', TType.I64, 5)
            oprot.writeI64(self.offset_rev)
            oprot.writeFieldEnd()
        if self.key_start is not None:
            oprot.writeFieldBegin('key_start', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.key_start))
            for iter54 in self.key_start:
                iter54.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.key_finish is not None:
            oprot.writeFieldBegin('key_finish', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.key_finish))
            for iter55 in self.key_finish:
                iter55.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRUCT, 8)
            self.value.write(oprot)
            oprot.writeFieldEnd()
        if self.ts_start is not None:
            oprot.writeFieldBegin('ts_start', TType.STRUCT, 9)
            self.ts_start.write(oprot)
            oprot.writeFieldEnd()
        if self.ts_finish is not None:
            oprot.writeFieldBegin('ts_finish', TType.STRUCT, 10)
            self.ts_finish.write(oprot)
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.STRUCT, 11)
            self.flags.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecColumn(object):
    """
    Attributes:
     - cid
     - intervals

    """

    __slots__ = (
        'cid',
        'intervals',
    )


    def __init__(self, cid=None, intervals=None,):
        self.cid = cid
        self.intervals = intervals

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.intervals = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = SpecInterval()
                        _elem61.read(iprot)
                        self.intervals.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecColumn')
        if self.cid is not None:
            oprot.writeFieldBegin('cid', TType.I64, 1)
            oprot.writeI64(self.cid)
            oprot.writeFieldEnd()
        if self.intervals is not None:
            oprot.writeFieldBegin('intervals', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.intervals))
            for iter62 in self.intervals:
                iter62.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecScan(object):
    """
    Attributes:
     - columns
     - flags

    """

    __slots__ = (
        'columns',
        'flags',
    )


    def __init__(self, columns=None, flags=None,):
        self.columns = columns
        self.flags = flags

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = SpecColumn()
                        _elem68.read(iprot)
                        self.columns.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.flags = SpecFlags()
                    self.flags.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecScan')
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter69 in self.columns:
                iter69.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.STRUCT, 2)
            self.flags.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class UCell(object):
    """
    Attributes:
     - f
     - k
     - ts
     - ts_desc
     - v

    """

    __slots__ = (
        'f',
        'k',
        'ts',
        'ts_desc',
        'v',
    )


    def __init__(self, f=None, k=None, ts=None, ts_desc=None, v=None,):
        self.f = f
        self.k = k
        self.ts = ts
        self.ts_desc = ts_desc
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.f = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.k = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = iprot.readBinary()
                        self.k.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.ts_desc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.v = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UCell')
        if self.f is not None:
            oprot.writeFieldBegin('f', TType.I32, 1)
            oprot.writeI32(self.f)
            oprot.writeFieldEnd()
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.k))
            for iter76 in self.k:
                oprot.writeBinary(iter76)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 3)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.ts_desc is not None:
            oprot.writeFieldBegin('ts_desc', TType.BOOL, 4)
            oprot.writeBool(self.ts_desc)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.STRING, 5)
            oprot.writeBinary(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class Cell(object):
    """
    Attributes:
     - c
     - k
     - ts
     - v

    """

    __slots__ = (
        'c',
        'k',
        'ts',
        'v',
    )


    def __init__(self, c=None, k=None, ts=None, v=None,):
        self.c = c
        self.k = k
        self.ts = ts
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.c = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.k = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = iprot.readBinary()
                        self.k.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.v = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Cell')
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRING, 1)
            oprot.writeString(self.c)
            oprot.writeFieldEnd()
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.k))
            for iter83 in self.k:
                oprot.writeBinary(iter83)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 3)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.STRING, 4)
            oprot.writeBinary(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class CCell(object):
    """
    Attributes:
     - k
     - ts
     - v

    """

    __slots__ = (
        'k',
        'ts',
        'v',
    )


    def __init__(self, k=None, ts=None, v=None,):
        self.k = k
        self.ts = ts
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.k = []
                    (_etype87, _size84) = iprot.readListBegin()
                    for _i88 in range(_size84):
                        _elem89 = iprot.readBinary()
                        self.k.append(_elem89)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.v = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CCell')
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.k))
            for iter90 in self.k:
                oprot.writeBinary(iter90)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 2)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.STRING, 3)
            oprot.writeBinary(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class KCell(object):
    """
    Attributes:
     - c
     - ts
     - v

    """

    __slots__ = (
        'c',
        'ts',
        'v',
    )


    def __init__(self, c=None, ts=None, v=None,):
        self.c = c
        self.ts = ts
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.c = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.v = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('KCell')
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRING, 1)
            oprot.writeString(self.c)
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 2)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.STRING, 3)
            oprot.writeBinary(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class kCells(object):
    """
    Attributes:
     - k
     - cells

    """

    __slots__ = (
        'k',
        'cells',
    )


    def __init__(self, k=None, cells=None,):
        self.k = k
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.k = []
                    (_etype94, _size91) = iprot.readListBegin()
                    for _i95 in range(_size91):
                        _elem96 = iprot.readBinary()
                        self.k.append(_elem96)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.cells = []
                    (_etype100, _size97) = iprot.readListBegin()
                    for _i101 in range(_size97):
                        _elem102 = KCell()
                        _elem102.read(iprot)
                        self.cells.append(_elem102)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('kCells')
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.k))
            for iter103 in self.k:
                oprot.writeBinary(iter103)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.cells))
            for iter104 in self.cells:
                iter104.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class FCell(object):
    """
    Attributes:
     - c
     - ts
     - v

    """

    __slots__ = (
        'c',
        'ts',
        'v',
    )


    def __init__(self, c=None, ts=None, v=None,):
        self.c = c
        self.ts = ts
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.c = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.v = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FCell')
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRING, 1)
            oprot.writeString(self.c)
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 2)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.STRING, 3)
            oprot.writeBinary(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class FCells(object):
    """
    Attributes:
     - f
     - cells

    """

    __slots__ = (
        'f',
        'cells',
    )


    def __init__(self, f=None, cells=None,):
        self.f = f
        self.cells = cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.f = {}
                    (_ktype106, _vtype107, _size105) = iprot.readMapBegin()
                    for _i109 in range(_size105):
                        _key110 = iprot.readBinary()
                        _val111 = FCells()
                        _val111.read(iprot)
                        self.f[_key110] = _val111
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.cells = []
                    (_etype115, _size112) = iprot.readListBegin()
                    for _i116 in range(_size112):
                        _elem117 = FCell()
                        _elem117.read(iprot)
                        self.cells.append(_elem117)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FCells')
        if self.f is not None:
            oprot.writeFieldBegin('f', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.f))
            for kiter118, viter119 in self.f.items():
                oprot.writeBinary(kiter118)
                viter119.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.cells))
            for iter120 in self.cells:
                iter120.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class CellsGroup(object):
    """
    Attributes:
     - cells
     - ccells
     - kcells
     - fcells

    """

    __slots__ = (
        'cells',
        'ccells',
        'kcells',
        'fcells',
    )


    def __init__(self, cells=None, ccells=None, kcells=None, fcells=None,):
        self.cells = cells
        self.ccells = ccells
        self.kcells = kcells
        self.fcells = fcells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.cells = []
                    (_etype124, _size121) = iprot.readListBegin()
                    for _i125 in range(_size121):
                        _elem126 = Cell()
                        _elem126.read(iprot)
                        self.cells.append(_elem126)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.ccells = {}
                    (_ktype128, _vtype129, _size127) = iprot.readMapBegin()
                    for _i131 in range(_size127):
                        _key132 = iprot.readString()
                        _val133 = []
                        (_etype137, _size134) = iprot.readListBegin()
                        for _i138 in range(_size134):
                            _elem139 = CCell()
                            _elem139.read(iprot)
                            _val133.append(_elem139)
                        iprot.readListEnd()
                        self.ccells[_key132] = _val133
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.kcells = []
                    (_etype143, _size140) = iprot.readListBegin()
                    for _i144 in range(_size140):
                        _elem145 = kCells()
                        _elem145.read(iprot)
                        self.kcells.append(_elem145)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.fcells = FCells()
                    self.fcells.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CellsGroup')
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.cells))
            for iter146 in self.cells:
                iter146.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ccells is not None:
            oprot.writeFieldBegin('ccells', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.ccells))
            for kiter147, viter148 in self.ccells.items():
                oprot.writeString(kiter147)
                oprot.writeListBegin(TType.STRUCT, len(viter148))
                for iter149 in viter148:
                    iter149.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.kcells is not None:
            oprot.writeFieldBegin('kcells', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.kcells))
            for iter150 in self.kcells:
                iter150.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fcells is not None:
            oprot.writeFieldBegin('fcells', TType.STRUCT, 4)
            self.fcells.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class CompactResult(object):
    """
    Attributes:
     - cid
     - err

    """

    __slots__ = (
        'cid',
        'err',
    )


    def __init__(self, cid=None, err=None,):
        self.cid = cid
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.err = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CompactResult')
        if self.cid is not None:
            oprot.writeFieldBegin('cid', TType.I64, 1)
            oprot.writeI64(self.cid)
            oprot.writeFieldEnd()
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.I32, 2)
            oprot.writeI32(self.err)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Exception)
Exception.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
    (2, TType.STRING, 'message', None, None, ),  # 2
)
all_structs.append(Schema)
Schema.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cid', None, None, ),  # 1
    (2, TType.STRING, 'col_name', None, None, ),  # 2
    (3, TType.I32, 'col_type', None, None, ),  # 3
    (4, TType.I32, 'cell_versions', None, None, ),  # 4
    (5, TType.I32, 'cell_ttl', None, None, ),  # 5
    (6, TType.I32, 'blk_encoding', None, None, ),  # 6
    (7, TType.I32, 'blk_size', None, None, ),  # 7
    (8, TType.I32, 'blk_cells', None, None, ),  # 8
    (9, TType.BYTE, 'cs_replication', None, None, ),  # 9
    (10, TType.I32, 'cs_size', None, None, ),  # 10
    (11, TType.BYTE, 'cs_max', None, None, ),  # 11
    (12, TType.BYTE, 'log_rollout_ratio', None, None, ),  # 12
    (13, TType.BYTE, 'compact_percent', None, None, ),  # 13
    (14, TType.I64, 'revision', None, None, ),  # 14
)
all_structs.append(SpecSchemas)
SpecSchemas.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'cids', (TType.I64, None, False), None, ),  # 1
    (2, TType.LIST, 'names', (TType.STRING, None, False), None, ),  # 2
)
all_structs.append(SpecFlags)
SpecFlags.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'limit', None, None, ),  # 1
    (2, TType.I64, 'offset', None, None, ),  # 2
    (3, TType.I32, 'max_versions', None, None, ),  # 3
    (4, TType.I32, 'max_buffer', None, None, ),  # 4
    (5, TType.BYTE, 'options', None, None, ),  # 5
)
all_structs.append(SpecFraction)
SpecFraction.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'comp', None, None, ),  # 1
    (2, TType.STRING, 'f', 'BINARY', None, ),  # 2
)
all_structs.append(SpecValue)
SpecValue.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'comp', None, None, ),  # 1
    (2, TType.STRING, 'v', 'BINARY', None, ),  # 2
)
all_structs.append(SpecTimestamp)
SpecTimestamp.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'comp', None, None, ),  # 1
    (2, TType.I64, 'ts', None, None, ),  # 2
)
all_structs.append(SpecInterval)
SpecInterval.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'range_begin', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.LIST, 'range_end', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.LIST, 'range_offset', (TType.STRING, 'BINARY', False), None, ),  # 3
    (4, TType.LIST, 'offset_key', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.I64, 'offset_rev', None, None, ),  # 5
    (6, TType.LIST, 'key_start', (TType.STRUCT, [SpecFraction, None], False), None, ),  # 6
    (7, TType.LIST, 'key_finish', (TType.STRUCT, [SpecFraction, None], False), None, ),  # 7
    (8, TType.STRUCT, 'value', [SpecValue, None], None, ),  # 8
    (9, TType.STRUCT, 'ts_start', [SpecTimestamp, None], None, ),  # 9
    (10, TType.STRUCT, 'ts_finish', [SpecTimestamp, None], None, ),  # 10
    (11, TType.STRUCT, 'flags', [SpecFlags, None], None, ),  # 11
)
all_structs.append(SpecColumn)
SpecColumn.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cid', None, None, ),  # 1
    (2, TType.LIST, 'intervals', (TType.STRUCT, [SpecInterval, None], False), None, ),  # 2
)
all_structs.append(SpecScan)
SpecScan.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'columns', (TType.STRUCT, [SpecColumn, None], False), None, ),  # 1
    (2, TType.STRUCT, 'flags', [SpecFlags, None], None, ),  # 2
)
all_structs.append(UCell)
UCell.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'f', None, None, ),  # 1
    (2, TType.LIST, 'k', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.I64, 'ts', None, None, ),  # 3
    (4, TType.BOOL, 'ts_desc', None, None, ),  # 4
    (5, TType.STRING, 'v', 'BINARY', None, ),  # 5
)
all_structs.append(Cell)
Cell.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'c', None, None, ),  # 1
    (2, TType.LIST, 'k', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.I64, 'ts', None, None, ),  # 3
    (4, TType.STRING, 'v', 'BINARY', None, ),  # 4
)
all_structs.append(CCell)
CCell.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'k', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.I64, 'ts', None, None, ),  # 2
    (3, TType.STRING, 'v', 'BINARY', None, ),  # 3
)
all_structs.append(KCell)
KCell.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'c', None, None, ),  # 1
    (2, TType.I64, 'ts', None, None, ),  # 2
    (3, TType.STRING, 'v', 'BINARY', None, ),  # 3
)
all_structs.append(kCells)
kCells.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'k', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.LIST, 'cells', (TType.STRUCT, [KCell, None], False), None, ),  # 2
)
all_structs.append(FCell)
FCell.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'c', None, None, ),  # 1
    (2, TType.I64, 'ts', None, None, ),  # 2
    (3, TType.STRING, 'v', 'BINARY', None, ),  # 3
)
all_structs.append(FCells)
FCells.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'f', (TType.STRING, 'BINARY', TType.STRUCT, [FCells, None], False), None, ),  # 1
    (2, TType.LIST, 'cells', (TType.STRUCT, [FCell, None], False), None, ),  # 2
)
all_structs.append(CellsGroup)
CellsGroup.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'cells', (TType.STRUCT, [Cell, None], False), None, ),  # 1
    (2, TType.MAP, 'ccells', (TType.STRING, None, TType.LIST, (TType.STRUCT, [CCell, None], False), False), None, ),  # 2
    (3, TType.LIST, 'kcells', (TType.STRUCT, [kCells, None], False), None, ),  # 3
    (4, TType.STRUCT, 'fcells', [FCells, None], None, ),  # 4
)
all_structs.append(CompactResult)
CompactResult.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cid', None, None, ),  # 1
    (2, TType.I32, 'err', None, None, ),  # 2
)
fix_spec(all_structs)
del all_structs
