/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Service_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace SWC { namespace Thrift {

int _kKeySeqValues[] = {
  KeySeq::UNKNOWN,
  KeySeq::LEXIC,
  KeySeq::VOLUME,
  KeySeq::FC_LEXIC,
  KeySeq::FC_VOLUME
};
const char* _kKeySeqNames[] = {
  "UNKNOWN",
  "LEXIC",
  "VOLUME",
  "FC_LEXIC",
  "FC_VOLUME"
};
const std::map<int, const char*> _KeySeq_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kKeySeqValues, _kKeySeqNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const KeySeq::type& val) {
  std::map<int, const char*>::const_iterator it = _KeySeq_VALUES_TO_NAMES.find(val);
  if (it != _KeySeq_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const KeySeq::type& val) {
  std::map<int, const char*>::const_iterator it = _KeySeq_VALUES_TO_NAMES.find(val);
  if (it != _KeySeq_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kColumnTypeValues[] = {
  ColumnType::UNKNOWN,
  ColumnType::PLAIN,
  ColumnType::COUNTER_I64,
  ColumnType::COUNTER_I32,
  ColumnType::COUNTER_I16,
  ColumnType::COUNTER_I8,
  ColumnType::CELL_DEFINED
};
const char* _kColumnTypeNames[] = {
  "UNKNOWN",
  "PLAIN",
  "COUNTER_I64",
  "COUNTER_I32",
  "COUNTER_I16",
  "COUNTER_I8",
  "CELL_DEFINED"
};
const std::map<int, const char*> _ColumnType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kColumnTypeValues, _kColumnTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ColumnType::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnType_VALUES_TO_NAMES.find(val);
  if (it != _ColumnType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ColumnType::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnType_VALUES_TO_NAMES.find(val);
  if (it != _ColumnType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kEncodingTypeValues[] = {
  EncodingType::DEFAULT,
  EncodingType::PLAIN,
  EncodingType::ZLIB,
  EncodingType::SNAPPY,
  EncodingType::ZSTD,
  EncodingType::UNKNOWN
};
const char* _kEncodingTypeNames[] = {
  "DEFAULT",
  "PLAIN",
  "ZLIB",
  "SNAPPY",
  "ZSTD",
  "UNKNOWN"
};
const std::map<int, const char*> _EncodingType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kEncodingTypeValues, _kEncodingTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const EncodingType::type& val) {
  std::map<int, const char*>::const_iterator it = _EncodingType_VALUES_TO_NAMES.find(val);
  if (it != _EncodingType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const EncodingType::type& val) {
  std::map<int, const char*>::const_iterator it = _EncodingType_VALUES_TO_NAMES.find(val);
  if (it != _EncodingType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSchemaFuncValues[] = {
  SchemaFunc::CREATE,
  SchemaFunc::DELETE,
  SchemaFunc::MODIFY
};
const char* _kSchemaFuncNames[] = {
  "CREATE",
  "DELETE",
  "MODIFY"
};
const std::map<int, const char*> _SchemaFunc_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kSchemaFuncValues, _kSchemaFuncNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const SchemaFunc::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaFunc_VALUES_TO_NAMES.find(val);
  if (it != _SchemaFunc_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SchemaFunc::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaFunc_VALUES_TO_NAMES.find(val);
  if (it != _SchemaFunc_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCompValues[] = {
  Comp::NONE,
  Comp::PF,
  Comp::GT,
  Comp::GE,
  Comp::EQ,
  Comp::LE,
  Comp::LT,
  Comp::NE,
  Comp::RE,
  Comp::VGT,
  Comp::VGE,
  Comp::VLE,
  Comp::VLT
};
const char* _kCompNames[] = {
  "NONE",
  "PF",
  "GT",
  "GE",
  "EQ",
  "LE",
  "LT",
  "NE",
  "RE",
  "VGT",
  "VGE",
  "VLE",
  "VLT"
};
const std::map<int, const char*> _Comp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(13, _kCompValues, _kCompNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const Comp::type& val) {
  std::map<int, const char*>::const_iterator it = _Comp_VALUES_TO_NAMES.find(val);
  if (it != _Comp_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Comp::type& val) {
  std::map<int, const char*>::const_iterator it = _Comp_VALUES_TO_NAMES.find(val);
  if (it != _Comp_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSpecFlagsOptValues[] = {
  SpecFlagsOpt::NONE,
  SpecFlagsOpt::LIMIT_BY_KEYS,
  SpecFlagsOpt::OFFSET_BY_KEYS,
  SpecFlagsOpt::ONLY_KEYS,
  SpecFlagsOpt::ONLY_DELETES
};
const char* _kSpecFlagsOptNames[] = {
  "NONE",
  "LIMIT_BY_KEYS",
  "OFFSET_BY_KEYS",
  "ONLY_KEYS",
  "ONLY_DELETES"
};
const std::map<int, const char*> _SpecFlagsOpt_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kSpecFlagsOptValues, _kSpecFlagsOptNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const SpecFlagsOpt::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecFlagsOpt_VALUES_TO_NAMES.find(val);
  if (it != _SpecFlagsOpt_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SpecFlagsOpt::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecFlagsOpt_VALUES_TO_NAMES.find(val);
  if (it != _SpecFlagsOpt_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFlagValues[] = {
  Flag::NONE,
  Flag::INSERT,
  Flag::DELETE,
  Flag::DELETE_VERSION
};
const char* _kFlagNames[] = {
  "NONE",
  "INSERT",
  "DELETE",
  "DELETE_VERSION"
};
const std::map<int, const char*> _Flag_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kFlagValues, _kFlagNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const Flag::type& val) {
  std::map<int, const char*>::const_iterator it = _Flag_VALUES_TO_NAMES.find(val);
  if (it != _Flag_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Flag::type& val) {
  std::map<int, const char*>::const_iterator it = _Flag_VALUES_TO_NAMES.find(val);
  if (it != _Flag_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCellsResultValues[] = {
  CellsResult::IN_LIST,
  CellsResult::ON_COLUMN,
  CellsResult::ON_KEY,
  CellsResult::ON_FRACTION
};
const char* _kCellsResultNames[] = {
  "IN_LIST",
  "ON_COLUMN",
  "ON_KEY",
  "ON_FRACTION"
};
const std::map<int, const char*> _CellsResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kCellsResultValues, _kCellsResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const CellsResult::type& val) {
  std::map<int, const char*>::const_iterator it = _CellsResult_VALUES_TO_NAMES.find(val);
  if (it != _CellsResult_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CellsResult::type& val) {
  std::map<int, const char*>::const_iterator it = _CellsResult_VALUES_TO_NAMES.find(val);
  if (it != _CellsResult_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Exception::~Exception() noexcept {
}


void Exception::__set_code(const int32_t val) {
  this->code = val;
}

void Exception::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const Exception& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Exception::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Exception::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Exception");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Exception &a, Exception &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

Exception::Exception(const Exception& other0) : TException() {
  code = other0.code;
  message = other0.message;
  __isset = other0.__isset;
}
Exception& Exception::operator=(const Exception& other1) {
  code = other1.code;
  message = other1.message;
  __isset = other1.__isset;
  return *this;
}
void Exception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Exception(";
  out << "code=" << to_string(code);
  out << ", " << "message=" << to_string(message);
  out << ")";
}

const char* Exception::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: Exception";
  }
}


Schema::~Schema() noexcept {
}


void Schema::__set_cid(const int64_t val) {
  this->cid = val;
__isset.cid = true;
}

void Schema::__set_col_name(const std::string& val) {
  this->col_name = val;
__isset.col_name = true;
}

void Schema::__set_col_seq(const KeySeq::type val) {
  this->col_seq = val;
__isset.col_seq = true;
}

void Schema::__set_col_type(const ColumnType::type val) {
  this->col_type = val;
__isset.col_type = true;
}

void Schema::__set_cell_versions(const int32_t val) {
  this->cell_versions = val;
__isset.cell_versions = true;
}

void Schema::__set_cell_ttl(const int32_t val) {
  this->cell_ttl = val;
__isset.cell_ttl = true;
}

void Schema::__set_blk_encoding(const EncodingType::type val) {
  this->blk_encoding = val;
__isset.blk_encoding = true;
}

void Schema::__set_blk_size(const int32_t val) {
  this->blk_size = val;
__isset.blk_size = true;
}

void Schema::__set_blk_cells(const int32_t val) {
  this->blk_cells = val;
__isset.blk_cells = true;
}

void Schema::__set_cs_replication(const int8_t val) {
  this->cs_replication = val;
__isset.cs_replication = true;
}

void Schema::__set_cs_size(const int32_t val) {
  this->cs_size = val;
__isset.cs_size = true;
}

void Schema::__set_cs_max(const int8_t val) {
  this->cs_max = val;
__isset.cs_max = true;
}

void Schema::__set_log_rollout_ratio(const int8_t val) {
  this->log_rollout_ratio = val;
__isset.log_rollout_ratio = true;
}

void Schema::__set_compact_percent(const int8_t val) {
  this->compact_percent = val;
__isset.compact_percent = true;
}

void Schema::__set_revision(const int64_t val) {
  this->revision = val;
__isset.revision = true;
}
std::ostream& operator<<(std::ostream& out, const Schema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Schema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col_name);
          this->__isset.col_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->col_seq = (KeySeq::type)ecast2;
          this->__isset.col_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->col_type = (ColumnType::type)ecast3;
          this->__isset.col_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_versions);
          this->__isset.cell_versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_ttl);
          this->__isset.cell_ttl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->blk_encoding = (EncodingType::type)ecast4;
          this->__isset.blk_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blk_size);
          this->__isset.blk_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blk_cells);
          this->__isset.blk_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->cs_replication);
          this->__isset.cs_replication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cs_size);
          this->__isset.cs_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->cs_max);
          this->__isset.cs_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->log_rollout_ratio);
          this->__isset.log_rollout_ratio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->compact_percent);
          this->__isset.compact_percent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Schema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Schema");

  if (this->__isset.cid) {
    xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->cid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_name) {
    xfer += oprot->writeFieldBegin("col_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->col_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_seq) {
    xfer += oprot->writeFieldBegin("col_seq", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->col_seq);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_type) {
    xfer += oprot->writeFieldBegin("col_type", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->col_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_versions) {
    xfer += oprot->writeFieldBegin("cell_versions", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->cell_versions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_ttl) {
    xfer += oprot->writeFieldBegin("cell_ttl", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->cell_ttl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_encoding) {
    xfer += oprot->writeFieldBegin("blk_encoding", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->blk_encoding);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_size) {
    xfer += oprot->writeFieldBegin("blk_size", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->blk_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_cells) {
    xfer += oprot->writeFieldBegin("blk_cells", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->blk_cells);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_replication) {
    xfer += oprot->writeFieldBegin("cs_replication", ::apache::thrift::protocol::T_BYTE, 10);
    xfer += oprot->writeByte(this->cs_replication);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_size) {
    xfer += oprot->writeFieldBegin("cs_size", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->cs_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_max) {
    xfer += oprot->writeFieldBegin("cs_max", ::apache::thrift::protocol::T_BYTE, 12);
    xfer += oprot->writeByte(this->cs_max);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.log_rollout_ratio) {
    xfer += oprot->writeFieldBegin("log_rollout_ratio", ::apache::thrift::protocol::T_BYTE, 13);
    xfer += oprot->writeByte(this->log_rollout_ratio);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compact_percent) {
    xfer += oprot->writeFieldBegin("compact_percent", ::apache::thrift::protocol::T_BYTE, 14);
    xfer += oprot->writeByte(this->compact_percent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.revision) {
    xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 15);
    xfer += oprot->writeI64(this->revision);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Schema &a, Schema &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.col_name, b.col_name);
  swap(a.col_seq, b.col_seq);
  swap(a.col_type, b.col_type);
  swap(a.cell_versions, b.cell_versions);
  swap(a.cell_ttl, b.cell_ttl);
  swap(a.blk_encoding, b.blk_encoding);
  swap(a.blk_size, b.blk_size);
  swap(a.blk_cells, b.blk_cells);
  swap(a.cs_replication, b.cs_replication);
  swap(a.cs_size, b.cs_size);
  swap(a.cs_max, b.cs_max);
  swap(a.log_rollout_ratio, b.log_rollout_ratio);
  swap(a.compact_percent, b.compact_percent);
  swap(a.revision, b.revision);
  swap(a.__isset, b.__isset);
}

Schema::Schema(const Schema& other5) {
  cid = other5.cid;
  col_name = other5.col_name;
  col_seq = other5.col_seq;
  col_type = other5.col_type;
  cell_versions = other5.cell_versions;
  cell_ttl = other5.cell_ttl;
  blk_encoding = other5.blk_encoding;
  blk_size = other5.blk_size;
  blk_cells = other5.blk_cells;
  cs_replication = other5.cs_replication;
  cs_size = other5.cs_size;
  cs_max = other5.cs_max;
  log_rollout_ratio = other5.log_rollout_ratio;
  compact_percent = other5.compact_percent;
  revision = other5.revision;
  __isset = other5.__isset;
}
Schema& Schema::operator=(const Schema& other6) {
  cid = other6.cid;
  col_name = other6.col_name;
  col_seq = other6.col_seq;
  col_type = other6.col_type;
  cell_versions = other6.cell_versions;
  cell_ttl = other6.cell_ttl;
  blk_encoding = other6.blk_encoding;
  blk_size = other6.blk_size;
  blk_cells = other6.blk_cells;
  cs_replication = other6.cs_replication;
  cs_size = other6.cs_size;
  cs_max = other6.cs_max;
  log_rollout_ratio = other6.log_rollout_ratio;
  compact_percent = other6.compact_percent;
  revision = other6.revision;
  __isset = other6.__isset;
  return *this;
}
void Schema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Schema(";
  out << "cid="; (__isset.cid ? (out << to_string(cid)) : (out << "<null>"));
  out << ", " << "col_name="; (__isset.col_name ? (out << to_string(col_name)) : (out << "<null>"));
  out << ", " << "col_seq="; (__isset.col_seq ? (out << to_string(col_seq)) : (out << "<null>"));
  out << ", " << "col_type="; (__isset.col_type ? (out << to_string(col_type)) : (out << "<null>"));
  out << ", " << "cell_versions="; (__isset.cell_versions ? (out << to_string(cell_versions)) : (out << "<null>"));
  out << ", " << "cell_ttl="; (__isset.cell_ttl ? (out << to_string(cell_ttl)) : (out << "<null>"));
  out << ", " << "blk_encoding="; (__isset.blk_encoding ? (out << to_string(blk_encoding)) : (out << "<null>"));
  out << ", " << "blk_size="; (__isset.blk_size ? (out << to_string(blk_size)) : (out << "<null>"));
  out << ", " << "blk_cells="; (__isset.blk_cells ? (out << to_string(blk_cells)) : (out << "<null>"));
  out << ", " << "cs_replication="; (__isset.cs_replication ? (out << to_string(cs_replication)) : (out << "<null>"));
  out << ", " << "cs_size="; (__isset.cs_size ? (out << to_string(cs_size)) : (out << "<null>"));
  out << ", " << "cs_max="; (__isset.cs_max ? (out << to_string(cs_max)) : (out << "<null>"));
  out << ", " << "log_rollout_ratio="; (__isset.log_rollout_ratio ? (out << to_string(log_rollout_ratio)) : (out << "<null>"));
  out << ", " << "compact_percent="; (__isset.compact_percent ? (out << to_string(compact_percent)) : (out << "<null>"));
  out << ", " << "revision="; (__isset.revision ? (out << to_string(revision)) : (out << "<null>"));
  out << ")";
}


SchemaPattern::~SchemaPattern() noexcept {
}


void SchemaPattern::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SchemaPattern::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const SchemaPattern& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaPattern::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast7;
          xfer += iprot->readI32(ecast7);
          this->comp = (Comp::type)ecast7;
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaPattern::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaPattern");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->comp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaPattern &a, SchemaPattern &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

SchemaPattern::SchemaPattern(const SchemaPattern& other8) {
  comp = other8.comp;
  value = other8.value;
  __isset = other8.__isset;
}
SchemaPattern& SchemaPattern::operator=(const SchemaPattern& other9) {
  comp = other9.comp;
  value = other9.value;
  __isset = other9.__isset;
  return *this;
}
void SchemaPattern::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaPattern(";
  out << "comp=" << to_string(comp);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


SpecSchemas::~SpecSchemas() noexcept {
}


void SpecSchemas::__set_cids(const std::vector<int64_t> & val) {
  this->cids = val;
__isset.cids = true;
}

void SpecSchemas::__set_names(const std::vector<std::string> & val) {
  this->names = val;
__isset.names = true;
}

void SpecSchemas::__set_patterns(const std::vector<SchemaPattern> & val) {
  this->patterns = val;
__isset.patterns = true;
}
std::ostream& operator<<(std::ostream& out, const SpecSchemas& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecSchemas::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cids.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->cids.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += iprot->readI64(this->cids[_i14]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size15;
            ::apache::thrift::protocol::TType _etype18;
            xfer += iprot->readListBegin(_etype18, _size15);
            this->names.resize(_size15);
            uint32_t _i19;
            for (_i19 = 0; _i19 < _size15; ++_i19)
            {
              xfer += iprot->readString(this->names[_i19]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->patterns.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->patterns.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += this->patterns[_i24].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.patterns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecSchemas::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecSchemas");

  if (this->__isset.cids) {
    xfer += oprot->writeFieldBegin("cids", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->cids.size()));
      std::vector<int64_t> ::const_iterator _iter25;
      for (_iter25 = this->cids.begin(); _iter25 != this->cids.end(); ++_iter25)
      {
        xfer += oprot->writeI64((*_iter25));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.names) {
    xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
      std::vector<std::string> ::const_iterator _iter26;
      for (_iter26 = this->names.begin(); _iter26 != this->names.end(); ++_iter26)
      {
        xfer += oprot->writeString((*_iter26));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.patterns) {
    xfer += oprot->writeFieldBegin("patterns", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->patterns.size()));
      std::vector<SchemaPattern> ::const_iterator _iter27;
      for (_iter27 = this->patterns.begin(); _iter27 != this->patterns.end(); ++_iter27)
      {
        xfer += (*_iter27).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecSchemas &a, SpecSchemas &b) {
  using ::std::swap;
  swap(a.cids, b.cids);
  swap(a.names, b.names);
  swap(a.patterns, b.patterns);
  swap(a.__isset, b.__isset);
}

SpecSchemas::SpecSchemas(const SpecSchemas& other28) {
  cids = other28.cids;
  names = other28.names;
  patterns = other28.patterns;
  __isset = other28.__isset;
}
SpecSchemas& SpecSchemas::operator=(const SpecSchemas& other29) {
  cids = other29.cids;
  names = other29.names;
  patterns = other29.patterns;
  __isset = other29.__isset;
  return *this;
}
void SpecSchemas::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecSchemas(";
  out << "cids="; (__isset.cids ? (out << to_string(cids)) : (out << "<null>"));
  out << ", " << "names="; (__isset.names ? (out << to_string(names)) : (out << "<null>"));
  out << ", " << "patterns="; (__isset.patterns ? (out << to_string(patterns)) : (out << "<null>"));
  out << ")";
}


SpecFlags::~SpecFlags() noexcept {
}


void SpecFlags::__set_limit(const int64_t val) {
  this->limit = val;
__isset.limit = true;
}

void SpecFlags::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}

void SpecFlags::__set_max_versions(const int32_t val) {
  this->max_versions = val;
__isset.max_versions = true;
}

void SpecFlags::__set_max_buffer(const int32_t val) {
  this->max_buffer = val;
__isset.max_buffer = true;
}

void SpecFlags::__set_options(const int8_t val) {
  this->options = val;
__isset.options = true;
}
std::ostream& operator<<(std::ostream& out, const SpecFlags& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecFlags::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_versions);
          this->__isset.max_versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_buffer);
          this->__isset.max_buffer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->options);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecFlags::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecFlags");

  if (this->__isset.limit) {
    xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_versions) {
    xfer += oprot->writeFieldBegin("max_versions", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->max_versions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_buffer) {
    xfer += oprot->writeFieldBegin("max_buffer", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->max_buffer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_BYTE, 5);
    xfer += oprot->writeByte(this->options);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecFlags &a, SpecFlags &b) {
  using ::std::swap;
  swap(a.limit, b.limit);
  swap(a.offset, b.offset);
  swap(a.max_versions, b.max_versions);
  swap(a.max_buffer, b.max_buffer);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

SpecFlags::SpecFlags(const SpecFlags& other30) {
  limit = other30.limit;
  offset = other30.offset;
  max_versions = other30.max_versions;
  max_buffer = other30.max_buffer;
  options = other30.options;
  __isset = other30.__isset;
}
SpecFlags& SpecFlags::operator=(const SpecFlags& other31) {
  limit = other31.limit;
  offset = other31.offset;
  max_versions = other31.max_versions;
  max_buffer = other31.max_buffer;
  options = other31.options;
  __isset = other31.__isset;
  return *this;
}
void SpecFlags::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecFlags(";
  out << "limit="; (__isset.limit ? (out << to_string(limit)) : (out << "<null>"));
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ", " << "max_versions="; (__isset.max_versions ? (out << to_string(max_versions)) : (out << "<null>"));
  out << ", " << "max_buffer="; (__isset.max_buffer ? (out << to_string(max_buffer)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ")";
}


SpecFraction::~SpecFraction() noexcept {
}


void SpecFraction::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecFraction::__set_f(const std::string& val) {
  this->f = val;
}
std::ostream& operator<<(std::ostream& out, const SpecFraction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecFraction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast32;
          xfer += iprot->readI32(ecast32);
          this->comp = (Comp::type)ecast32;
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->f);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecFraction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecFraction");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->comp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->f);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecFraction &a, SpecFraction &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.f, b.f);
  swap(a.__isset, b.__isset);
}

SpecFraction::SpecFraction(const SpecFraction& other33) {
  comp = other33.comp;
  f = other33.f;
  __isset = other33.__isset;
}
SpecFraction& SpecFraction::operator=(const SpecFraction& other34) {
  comp = other34.comp;
  f = other34.f;
  __isset = other34.__isset;
  return *this;
}
void SpecFraction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecFraction(";
  out << "comp=" << to_string(comp);
  out << ", " << "f=" << to_string(f);
  out << ")";
}


SpecValue::~SpecValue() noexcept {
}


void SpecValue::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValue::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast35;
          xfer += iprot->readI32(ecast35);
          this->comp = (Comp::type)ecast35;
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValue");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->comp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValue &a, SpecValue &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValue::SpecValue(const SpecValue& other36) {
  comp = other36.comp;
  v = other36.v;
  __isset = other36.__isset;
}
SpecValue& SpecValue::operator=(const SpecValue& other37) {
  comp = other37.comp;
  v = other37.v;
  __isset = other37.__isset;
  return *this;
}
void SpecValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValue(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecTimestamp::~SpecTimestamp() noexcept {
}


void SpecTimestamp::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecTimestamp::__set_ts(const int64_t val) {
  this->ts = val;
}
std::ostream& operator<<(std::ostream& out, const SpecTimestamp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecTimestamp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast38;
          xfer += iprot->readI32(ecast38);
          this->comp = (Comp::type)ecast38;
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecTimestamp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecTimestamp");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->comp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecTimestamp &a, SpecTimestamp &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.ts, b.ts);
  swap(a.__isset, b.__isset);
}

SpecTimestamp::SpecTimestamp(const SpecTimestamp& other39) {
  comp = other39.comp;
  ts = other39.ts;
  __isset = other39.__isset;
}
SpecTimestamp& SpecTimestamp::operator=(const SpecTimestamp& other40) {
  comp = other40.comp;
  ts = other40.ts;
  __isset = other40.__isset;
  return *this;
}
void SpecTimestamp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecTimestamp(";
  out << "comp=" << to_string(comp);
  out << ", " << "ts=" << to_string(ts);
  out << ")";
}


SpecInterval::~SpecInterval() noexcept {
}


void SpecInterval::__set_range_begin(const Key& val) {
  this->range_begin = val;
__isset.range_begin = true;
}

void SpecInterval::__set_range_end(const Key& val) {
  this->range_end = val;
__isset.range_end = true;
}

void SpecInterval::__set_range_offset(const Key& val) {
  this->range_offset = val;
__isset.range_offset = true;
}

void SpecInterval::__set_offset_key(const Key& val) {
  this->offset_key = val;
__isset.offset_key = true;
}

void SpecInterval::__set_offset_rev(const int64_t val) {
  this->offset_rev = val;
__isset.offset_rev = true;
}

void SpecInterval::__set_key_start(const SpecKey& val) {
  this->key_start = val;
__isset.key_start = true;
}

void SpecInterval::__set_key_finish(const SpecKey& val) {
  this->key_finish = val;
__isset.key_finish = true;
}

void SpecInterval::__set_value(const SpecValue& val) {
  this->value = val;
__isset.value = true;
}

void SpecInterval::__set_ts_start(const SpecTimestamp& val) {
  this->ts_start = val;
__isset.ts_start = true;
}

void SpecInterval::__set_ts_finish(const SpecTimestamp& val) {
  this->ts_finish = val;
__isset.ts_finish = true;
}

void SpecInterval::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}
std::ostream& operator<<(std::ostream& out, const SpecInterval& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecInterval::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_begin.clear();
            uint32_t _size41;
            ::apache::thrift::protocol::TType _etype44;
            xfer += iprot->readListBegin(_etype44, _size41);
            this->range_begin.resize(_size41);
            uint32_t _i45;
            for (_i45 = 0; _i45 < _size41; ++_i45)
            {
              xfer += iprot->readBinary(this->range_begin[_i45]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_end.clear();
            uint32_t _size46;
            ::apache::thrift::protocol::TType _etype49;
            xfer += iprot->readListBegin(_etype49, _size46);
            this->range_end.resize(_size46);
            uint32_t _i50;
            for (_i50 = 0; _i50 < _size46; ++_i50)
            {
              xfer += iprot->readBinary(this->range_end[_i50]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_offset.clear();
            uint32_t _size51;
            ::apache::thrift::protocol::TType _etype54;
            xfer += iprot->readListBegin(_etype54, _size51);
            this->range_offset.resize(_size51);
            uint32_t _i55;
            for (_i55 = 0; _i55 < _size51; ++_i55)
            {
              xfer += iprot->readBinary(this->range_offset[_i55]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->offset_key.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            xfer += iprot->readListBegin(_etype59, _size56);
            this->offset_key.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += iprot->readBinary(this->offset_key[_i60]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.offset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset_rev);
          this->__isset.offset_rev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_start.clear();
            uint32_t _size61;
            ::apache::thrift::protocol::TType _etype64;
            xfer += iprot->readListBegin(_etype64, _size61);
            this->key_start.resize(_size61);
            uint32_t _i65;
            for (_i65 = 0; _i65 < _size61; ++_i65)
            {
              xfer += this->key_start[_i65].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_finish.clear();
            uint32_t _size66;
            ::apache::thrift::protocol::TType _etype69;
            xfer += iprot->readListBegin(_etype69, _size66);
            this->key_finish.resize(_size66);
            uint32_t _i70;
            for (_i70 = 0; _i70 < _size66; ++_i70)
            {
              xfer += this->key_finish[_i70].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->value.read(iprot);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_start.read(iprot);
          this->__isset.ts_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_finish.read(iprot);
          this->__isset.ts_finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecInterval::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecInterval");

  if (this->__isset.range_begin) {
    xfer += oprot->writeFieldBegin("range_begin", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_begin.size()));
      std::vector<std::string> ::const_iterator _iter71;
      for (_iter71 = this->range_begin.begin(); _iter71 != this->range_begin.end(); ++_iter71)
      {
        xfer += oprot->writeBinary((*_iter71));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.range_end) {
    xfer += oprot->writeFieldBegin("range_end", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_end.size()));
      std::vector<std::string> ::const_iterator _iter72;
      for (_iter72 = this->range_end.begin(); _iter72 != this->range_end.end(); ++_iter72)
      {
        xfer += oprot->writeBinary((*_iter72));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.range_offset) {
    xfer += oprot->writeFieldBegin("range_offset", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_offset.size()));
      std::vector<std::string> ::const_iterator _iter73;
      for (_iter73 = this->range_offset.begin(); _iter73 != this->range_offset.end(); ++_iter73)
      {
        xfer += oprot->writeBinary((*_iter73));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset_key) {
    xfer += oprot->writeFieldBegin("offset_key", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->offset_key.size()));
      std::vector<std::string> ::const_iterator _iter74;
      for (_iter74 = this->offset_key.begin(); _iter74 != this->offset_key.end(); ++_iter74)
      {
        xfer += oprot->writeBinary((*_iter74));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset_rev) {
    xfer += oprot->writeFieldBegin("offset_rev", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->offset_rev);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.key_start) {
    xfer += oprot->writeFieldBegin("key_start", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->key_start.size()));
      std::vector<SpecFraction> ::const_iterator _iter75;
      for (_iter75 = this->key_start.begin(); _iter75 != this->key_start.end(); ++_iter75)
      {
        xfer += (*_iter75).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.key_finish) {
    xfer += oprot->writeFieldBegin("key_finish", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->key_finish.size()));
      std::vector<SpecFraction> ::const_iterator _iter76;
      for (_iter76 = this->key_finish.begin(); _iter76 != this->key_finish.end(); ++_iter76)
      {
        xfer += (*_iter76).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->value.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_start) {
    xfer += oprot->writeFieldBegin("ts_start", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->ts_start.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_finish) {
    xfer += oprot->writeFieldBegin("ts_finish", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->ts_finish.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecInterval &a, SpecInterval &b) {
  using ::std::swap;
  swap(a.range_begin, b.range_begin);
  swap(a.range_end, b.range_end);
  swap(a.range_offset, b.range_offset);
  swap(a.offset_key, b.offset_key);
  swap(a.offset_rev, b.offset_rev);
  swap(a.key_start, b.key_start);
  swap(a.key_finish, b.key_finish);
  swap(a.value, b.value);
  swap(a.ts_start, b.ts_start);
  swap(a.ts_finish, b.ts_finish);
  swap(a.flags, b.flags);
  swap(a.__isset, b.__isset);
}

SpecInterval::SpecInterval(const SpecInterval& other77) {
  range_begin = other77.range_begin;
  range_end = other77.range_end;
  range_offset = other77.range_offset;
  offset_key = other77.offset_key;
  offset_rev = other77.offset_rev;
  key_start = other77.key_start;
  key_finish = other77.key_finish;
  value = other77.value;
  ts_start = other77.ts_start;
  ts_finish = other77.ts_finish;
  flags = other77.flags;
  __isset = other77.__isset;
}
SpecInterval& SpecInterval::operator=(const SpecInterval& other78) {
  range_begin = other78.range_begin;
  range_end = other78.range_end;
  range_offset = other78.range_offset;
  offset_key = other78.offset_key;
  offset_rev = other78.offset_rev;
  key_start = other78.key_start;
  key_finish = other78.key_finish;
  value = other78.value;
  ts_start = other78.ts_start;
  ts_finish = other78.ts_finish;
  flags = other78.flags;
  __isset = other78.__isset;
  return *this;
}
void SpecInterval::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecInterval(";
  out << "range_begin="; (__isset.range_begin ? (out << to_string(range_begin)) : (out << "<null>"));
  out << ", " << "range_end="; (__isset.range_end ? (out << to_string(range_end)) : (out << "<null>"));
  out << ", " << "range_offset="; (__isset.range_offset ? (out << to_string(range_offset)) : (out << "<null>"));
  out << ", " << "offset_key="; (__isset.offset_key ? (out << to_string(offset_key)) : (out << "<null>"));
  out << ", " << "offset_rev="; (__isset.offset_rev ? (out << to_string(offset_rev)) : (out << "<null>"));
  out << ", " << "key_start="; (__isset.key_start ? (out << to_string(key_start)) : (out << "<null>"));
  out << ", " << "key_finish="; (__isset.key_finish ? (out << to_string(key_finish)) : (out << "<null>"));
  out << ", " << "value="; (__isset.value ? (out << to_string(value)) : (out << "<null>"));
  out << ", " << "ts_start="; (__isset.ts_start ? (out << to_string(ts_start)) : (out << "<null>"));
  out << ", " << "ts_finish="; (__isset.ts_finish ? (out << to_string(ts_finish)) : (out << "<null>"));
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ")";
}


SpecColumn::~SpecColumn() noexcept {
}


void SpecColumn::__set_cid(const int64_t val) {
  this->cid = val;
}

void SpecColumn::__set_intervals(const std::vector<SpecInterval> & val) {
  this->intervals = val;
}
std::ostream& operator<<(std::ostream& out, const SpecColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->intervals.clear();
            uint32_t _size79;
            ::apache::thrift::protocol::TType _etype82;
            xfer += iprot->readListBegin(_etype82, _size79);
            this->intervals.resize(_size79);
            uint32_t _i83;
            for (_i83 = 0; _i83 < _size79; ++_i83)
            {
              xfer += this->intervals[_i83].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecColumn");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intervals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->intervals.size()));
    std::vector<SpecInterval> ::const_iterator _iter84;
    for (_iter84 = this->intervals.begin(); _iter84 != this->intervals.end(); ++_iter84)
    {
      xfer += (*_iter84).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecColumn &a, SpecColumn &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.intervals, b.intervals);
  swap(a.__isset, b.__isset);
}

SpecColumn::SpecColumn(const SpecColumn& other85) {
  cid = other85.cid;
  intervals = other85.intervals;
  __isset = other85.__isset;
}
SpecColumn& SpecColumn::operator=(const SpecColumn& other86) {
  cid = other86.cid;
  intervals = other86.intervals;
  __isset = other86.__isset;
  return *this;
}
void SpecColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecColumn(";
  out << "cid=" << to_string(cid);
  out << ", " << "intervals=" << to_string(intervals);
  out << ")";
}


SpecScan::~SpecScan() noexcept {
}


void SpecScan::__set_columns(const std::vector<SpecColumn> & val) {
  this->columns = val;
}

void SpecScan::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}
std::ostream& operator<<(std::ostream& out, const SpecScan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecScan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _etype90;
            xfer += iprot->readListBegin(_etype90, _size87);
            this->columns.resize(_size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              xfer += this->columns[_i91].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecScan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecScan");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<SpecColumn> ::const_iterator _iter92;
    for (_iter92 = this->columns.begin(); _iter92 != this->columns.end(); ++_iter92)
    {
      xfer += (*_iter92).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecScan &a, SpecScan &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.flags, b.flags);
  swap(a.__isset, b.__isset);
}

SpecScan::SpecScan(const SpecScan& other93) {
  columns = other93.columns;
  flags = other93.flags;
  __isset = other93.__isset;
}
SpecScan& SpecScan::operator=(const SpecScan& other94) {
  columns = other94.columns;
  flags = other94.flags;
  __isset = other94.__isset;
  return *this;
}
void SpecScan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecScan(";
  out << "columns=" << to_string(columns);
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ")";
}


UCell::~UCell() noexcept {
}


void UCell::__set_f(const Flag::type val) {
  this->f = val;
}

void UCell::__set_k(const Key& val) {
  this->k = val;
}

void UCell::__set_ts(const int64_t val) {
  this->ts = val;
__isset.ts = true;
}

void UCell::__set_ts_desc(const bool val) {
  this->ts_desc = val;
__isset.ts_desc = true;
}

void UCell::__set_v(const std::string& val) {
  this->v = val;
__isset.v = true;
}
std::ostream& operator<<(std::ostream& out, const UCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast95;
          xfer += iprot->readI32(ecast95);
          this->f = (Flag::type)ecast95;
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size96;
            ::apache::thrift::protocol::TType _etype99;
            xfer += iprot->readListBegin(_etype99, _size96);
            this->k.resize(_size96);
            uint32_t _i100;
            for (_i100 = 0; _i100 < _size96; ++_i100)
            {
              xfer += iprot->readBinary(this->k[_i100]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ts_desc);
          this->__isset.ts_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UCell");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->f);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter101;
    for (_iter101 = this->k.begin(); _iter101 != this->k.end(); ++_iter101)
    {
      xfer += oprot->writeBinary((*_iter101));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts) {
    xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_desc) {
    xfer += oprot->writeFieldBegin("ts_desc", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->ts_desc);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v) {
    xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->v);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UCell &a, UCell &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.ts_desc, b.ts_desc);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

UCell::UCell(const UCell& other102) {
  f = other102.f;
  k = other102.k;
  ts = other102.ts;
  ts_desc = other102.ts_desc;
  v = other102.v;
  __isset = other102.__isset;
}
UCell& UCell::operator=(const UCell& other103) {
  f = other103.f;
  k = other103.k;
  ts = other103.ts;
  ts_desc = other103.ts_desc;
  v = other103.v;
  __isset = other103.__isset;
  return *this;
}
void UCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UCell(";
  out << "f=" << to_string(f);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts="; (__isset.ts ? (out << to_string(ts)) : (out << "<null>"));
  out << ", " << "ts_desc="; (__isset.ts_desc ? (out << to_string(ts_desc)) : (out << "<null>"));
  out << ", " << "v="; (__isset.v ? (out << to_string(v)) : (out << "<null>"));
  out << ")";
}


Cell::~Cell() noexcept {
}


void Cell::__set_c(const std::string& val) {
  this->c = val;
}

void Cell::__set_k(const Key& val) {
  this->k = val;
}

void Cell::__set_ts(const int64_t val) {
  this->ts = val;
}

void Cell::__set_v(const std::string& val) {
  this->v = val;
__isset.v = true;
}
std::ostream& operator<<(std::ostream& out, const Cell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size104;
            ::apache::thrift::protocol::TType _etype107;
            xfer += iprot->readListBegin(_etype107, _size104);
            this->k.resize(_size104);
            uint32_t _i108;
            for (_i108 = 0; _i108 < _size104; ++_i108)
            {
              xfer += iprot->readBinary(this->k[_i108]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cell");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter109;
    for (_iter109 = this->k.begin(); _iter109 != this->k.end(); ++_iter109)
    {
      xfer += oprot->writeBinary((*_iter109));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.v) {
    xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->v);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cell &a, Cell &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

Cell::Cell(const Cell& other110) {
  c = other110.c;
  k = other110.k;
  ts = other110.ts;
  v = other110.v;
  __isset = other110.__isset;
}
Cell& Cell::operator=(const Cell& other111) {
  c = other111.c;
  k = other111.k;
  ts = other111.ts;
  v = other111.v;
  __isset = other111.__isset;
  return *this;
}
void Cell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cell(";
  out << "c=" << to_string(c);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v="; (__isset.v ? (out << to_string(v)) : (out << "<null>"));
  out << ")";
}


CCell::~CCell() noexcept {
}


void CCell::__set_k(const Key& val) {
  this->k = val;
}

void CCell::__set_ts(const int64_t val) {
  this->ts = val;
}

void CCell::__set_v(const std::string& val) {
  this->v = val;
__isset.v = true;
}
std::ostream& operator<<(std::ostream& out, const CCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size112;
            ::apache::thrift::protocol::TType _etype115;
            xfer += iprot->readListBegin(_etype115, _size112);
            this->k.resize(_size112);
            uint32_t _i116;
            for (_i116 = 0; _i116 < _size112; ++_i116)
            {
              xfer += iprot->readBinary(this->k[_i116]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCell");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter117;
    for (_iter117 = this->k.begin(); _iter117 != this->k.end(); ++_iter117)
    {
      xfer += oprot->writeBinary((*_iter117));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.v) {
    xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->v);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCell &a, CCell &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CCell::CCell(const CCell& other118) {
  k = other118.k;
  ts = other118.ts;
  v = other118.v;
  __isset = other118.__isset;
}
CCell& CCell::operator=(const CCell& other119) {
  k = other119.k;
  ts = other119.ts;
  v = other119.v;
  __isset = other119.__isset;
  return *this;
}
void CCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCell(";
  out << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v="; (__isset.v ? (out << to_string(v)) : (out << "<null>"));
  out << ")";
}


KCell::~KCell() noexcept {
}


void KCell::__set_c(const std::string& val) {
  this->c = val;
}

void KCell::__set_ts(const int64_t val) {
  this->ts = val;
}

void KCell::__set_v(const std::string& val) {
  this->v = val;
__isset.v = true;
}
std::ostream& operator<<(std::ostream& out, const KCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KCell");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.v) {
    xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->v);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KCell &a, KCell &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

KCell::KCell(const KCell& other120) {
  c = other120.c;
  ts = other120.ts;
  v = other120.v;
  __isset = other120.__isset;
}
KCell& KCell::operator=(const KCell& other121) {
  c = other121.c;
  ts = other121.ts;
  v = other121.v;
  __isset = other121.__isset;
  return *this;
}
void KCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KCell(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v="; (__isset.v ? (out << to_string(v)) : (out << "<null>"));
  out << ")";
}


kCells::~kCells() noexcept {
}


void kCells::__set_k(const Key& val) {
  this->k = val;
}

void kCells::__set_cells(const std::vector<KCell> & val) {
  this->cells = val;
}
std::ostream& operator<<(std::ostream& out, const kCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t kCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size122;
            ::apache::thrift::protocol::TType _etype125;
            xfer += iprot->readListBegin(_etype125, _size122);
            this->k.resize(_size122);
            uint32_t _i126;
            for (_i126 = 0; _i126 < _size122; ++_i126)
            {
              xfer += iprot->readBinary(this->k[_i126]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size127;
            ::apache::thrift::protocol::TType _etype130;
            xfer += iprot->readListBegin(_etype130, _size127);
            this->cells.resize(_size127);
            uint32_t _i131;
            for (_i131 = 0; _i131 < _size127; ++_i131)
            {
              xfer += this->cells[_i131].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kCells");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter132;
    for (_iter132 = this->k.begin(); _iter132 != this->k.end(); ++_iter132)
    {
      xfer += oprot->writeBinary((*_iter132));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<KCell> ::const_iterator _iter133;
    for (_iter133 = this->cells.begin(); _iter133 != this->cells.end(); ++_iter133)
    {
      xfer += (*_iter133).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(kCells &a, kCells &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.cells, b.cells);
  swap(a.__isset, b.__isset);
}

kCells::kCells(const kCells& other134) {
  k = other134.k;
  cells = other134.cells;
  __isset = other134.__isset;
}
kCells& kCells::operator=(const kCells& other135) {
  k = other135.k;
  cells = other135.cells;
  __isset = other135.__isset;
  return *this;
}
void kCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "kCells(";
  out << "k=" << to_string(k);
  out << ", " << "cells=" << to_string(cells);
  out << ")";
}


FCell::~FCell() noexcept {
}


void FCell::__set_c(const std::string& val) {
  this->c = val;
}

void FCell::__set_ts(const int64_t val) {
  this->ts = val;
}

void FCell::__set_v(const std::string& val) {
  this->v = val;
__isset.v = true;
}
std::ostream& operator<<(std::ostream& out, const FCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCell");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.v) {
    xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->v);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCell &a, FCell &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FCell::FCell(const FCell& other136) {
  c = other136.c;
  ts = other136.ts;
  v = other136.v;
  __isset = other136.__isset;
}
FCell& FCell::operator=(const FCell& other137) {
  c = other137.c;
  ts = other137.ts;
  v = other137.v;
  __isset = other137.__isset;
  return *this;
}
void FCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCell(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v="; (__isset.v ? (out << to_string(v)) : (out << "<null>"));
  out << ")";
}


FCells::~FCells() noexcept {
}


void FCells::__set_f(const std::map<std::string, FCells> & val) {
  this->f = val;
}

void FCells::__set_cells(const std::vector<FCell> & val) {
  this->cells = val;
__isset.cells = true;
}
std::ostream& operator<<(std::ostream& out, const FCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->f.clear();
            uint32_t _size138;
            ::apache::thrift::protocol::TType _ktype139;
            ::apache::thrift::protocol::TType _vtype140;
            xfer += iprot->readMapBegin(_ktype139, _vtype140, _size138);
            uint32_t _i142;
            for (_i142 = 0; _i142 < _size138; ++_i142)
            {
              std::string _key143;
              xfer += iprot->readBinary(_key143);
              FCells& _val144 = this->f[_key143];
              xfer += _val144.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size145;
            ::apache::thrift::protocol::TType _etype148;
            xfer += iprot->readListBegin(_etype148, _size145);
            this->cells.resize(_size145);
            uint32_t _i149;
            for (_i149 = 0; _i149 < _size145; ++_i149)
            {
              xfer += this->cells[_i149].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCells");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->f.size()));
    std::map<std::string, FCells> ::const_iterator _iter150;
    for (_iter150 = this->f.begin(); _iter150 != this->f.end(); ++_iter150)
    {
      xfer += oprot->writeBinary(_iter150->first);
      xfer += _iter150->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.cells) {
    xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
      std::vector<FCell> ::const_iterator _iter151;
      for (_iter151 = this->cells.begin(); _iter151 != this->cells.end(); ++_iter151)
      {
        xfer += (*_iter151).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCells &a, FCells &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.cells, b.cells);
  swap(a.__isset, b.__isset);
}

FCells::FCells(const FCells& other152) {
  f = other152.f;
  cells = other152.cells;
  __isset = other152.__isset;
}
FCells& FCells::operator=(const FCells& other153) {
  f = other153.f;
  cells = other153.cells;
  __isset = other153.__isset;
  return *this;
}
void FCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCells(";
  out << "f=" << to_string(f);
  out << ", " << "cells="; (__isset.cells ? (out << to_string(cells)) : (out << "<null>"));
  out << ")";
}


CellsGroup::~CellsGroup() noexcept {
}


void CellsGroup::__set_cells(const Cells& val) {
  this->cells = val;
__isset.cells = true;
}

void CellsGroup::__set_ccells(const CCells& val) {
  this->ccells = val;
__isset.ccells = true;
}

void CellsGroup::__set_kcells(const KCells& val) {
  this->kcells = val;
__isset.kcells = true;
}

void CellsGroup::__set_fcells(const FCells& val) {
  this->fcells = val;
__isset.fcells = true;
}
std::ostream& operator<<(std::ostream& out, const CellsGroup& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellsGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readListBegin(_etype157, _size154);
            this->cells.resize(_size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              xfer += this->cells[_i158].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ccells.clear();
            uint32_t _size159;
            ::apache::thrift::protocol::TType _ktype160;
            ::apache::thrift::protocol::TType _vtype161;
            xfer += iprot->readMapBegin(_ktype160, _vtype161, _size159);
            uint32_t _i163;
            for (_i163 = 0; _i163 < _size159; ++_i163)
            {
              std::string _key164;
              xfer += iprot->readString(_key164);
              ColCells& _val165 = this->ccells[_key164];
              {
                _val165.clear();
                uint32_t _size166;
                ::apache::thrift::protocol::TType _etype169;
                xfer += iprot->readListBegin(_etype169, _size166);
                _val165.resize(_size166);
                uint32_t _i170;
                for (_i170 = 0; _i170 < _size166; ++_i170)
                {
                  xfer += _val165[_i170].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ccells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->kcells.clear();
            uint32_t _size171;
            ::apache::thrift::protocol::TType _etype174;
            xfer += iprot->readListBegin(_etype174, _size171);
            this->kcells.resize(_size171);
            uint32_t _i175;
            for (_i175 = 0; _i175 < _size171; ++_i175)
            {
              xfer += this->kcells[_i175].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.kcells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fcells.read(iprot);
          this->__isset.fcells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellsGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellsGroup");

  if (this->__isset.cells) {
    xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
      std::vector<Cell> ::const_iterator _iter176;
      for (_iter176 = this->cells.begin(); _iter176 != this->cells.end(); ++_iter176)
      {
        xfer += (*_iter176).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ccells) {
    xfer += oprot->writeFieldBegin("ccells", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->ccells.size()));
      std::map<std::string, ColCells> ::const_iterator _iter177;
      for (_iter177 = this->ccells.begin(); _iter177 != this->ccells.end(); ++_iter177)
      {
        xfer += oprot->writeString(_iter177->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter177->second.size()));
          std::vector<CCell> ::const_iterator _iter178;
          for (_iter178 = _iter177->second.begin(); _iter178 != _iter177->second.end(); ++_iter178)
          {
            xfer += (*_iter178).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kcells) {
    xfer += oprot->writeFieldBegin("kcells", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->kcells.size()));
      std::vector<kCells> ::const_iterator _iter179;
      for (_iter179 = this->kcells.begin(); _iter179 != this->kcells.end(); ++_iter179)
      {
        xfer += (*_iter179).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fcells) {
    xfer += oprot->writeFieldBegin("fcells", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->fcells.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellsGroup &a, CellsGroup &b) {
  using ::std::swap;
  swap(a.cells, b.cells);
  swap(a.ccells, b.ccells);
  swap(a.kcells, b.kcells);
  swap(a.fcells, b.fcells);
  swap(a.__isset, b.__isset);
}

CellsGroup::CellsGroup(const CellsGroup& other180) {
  cells = other180.cells;
  ccells = other180.ccells;
  kcells = other180.kcells;
  fcells = other180.fcells;
  __isset = other180.__isset;
}
CellsGroup& CellsGroup::operator=(const CellsGroup& other181) {
  cells = other181.cells;
  ccells = other181.ccells;
  kcells = other181.kcells;
  fcells = other181.fcells;
  __isset = other181.__isset;
  return *this;
}
void CellsGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellsGroup(";
  out << "cells="; (__isset.cells ? (out << to_string(cells)) : (out << "<null>"));
  out << ", " << "ccells="; (__isset.ccells ? (out << to_string(ccells)) : (out << "<null>"));
  out << ", " << "kcells="; (__isset.kcells ? (out << to_string(kcells)) : (out << "<null>"));
  out << ", " << "fcells="; (__isset.fcells ? (out << to_string(fcells)) : (out << "<null>"));
  out << ")";
}


CompactResult::~CompactResult() noexcept {
}


void CompactResult::__set_cid(const int64_t val) {
  this->cid = val;
}

void CompactResult::__set_err(const int32_t val) {
  this->err = val;
}
std::ostream& operator<<(std::ostream& out, const CompactResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->err);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CompactResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactResult");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->err);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactResult &a, CompactResult &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

CompactResult::CompactResult(const CompactResult& other182) {
  cid = other182.cid;
  err = other182.err;
  __isset = other182.__isset;
}
CompactResult& CompactResult::operator=(const CompactResult& other183) {
  cid = other183.cid;
  err = other183.err;
  __isset = other183.__isset;
  return *this;
}
void CompactResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactResult(";
  out << "cid=" << to_string(cid);
  out << ", " << "err=" << to_string(err);
  out << ")";
}


Result::~Result() noexcept {
}


void Result::__set_schemas(const Schemas& val) {
  this->schemas = val;
__isset.schemas = true;
}

void Result::__set_cells(const Cells& val) {
  this->cells = val;
__isset.cells = true;
}

void Result::__set_compact(const CompactResults& val) {
  this->compact = val;
__isset.compact = true;
}
std::ostream& operator<<(std::ostream& out, const Result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->schemas.clear();
            uint32_t _size184;
            ::apache::thrift::protocol::TType _etype187;
            xfer += iprot->readListBegin(_etype187, _size184);
            this->schemas.resize(_size184);
            uint32_t _i188;
            for (_i188 = 0; _i188 < _size184; ++_i188)
            {
              xfer += this->schemas[_i188].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.schemas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size189;
            ::apache::thrift::protocol::TType _etype192;
            xfer += iprot->readListBegin(_etype192, _size189);
            this->cells.resize(_size189);
            uint32_t _i193;
            for (_i193 = 0; _i193 < _size189; ++_i193)
            {
              xfer += this->cells[_i193].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compact.clear();
            uint32_t _size194;
            ::apache::thrift::protocol::TType _etype197;
            xfer += iprot->readListBegin(_etype197, _size194);
            this->compact.resize(_size194);
            uint32_t _i198;
            for (_i198 = 0; _i198 < _size194; ++_i198)
            {
              xfer += this->compact[_i198].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.compact = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Result");

  if (this->__isset.schemas) {
    xfer += oprot->writeFieldBegin("schemas", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->schemas.size()));
      std::vector<Schema> ::const_iterator _iter199;
      for (_iter199 = this->schemas.begin(); _iter199 != this->schemas.end(); ++_iter199)
      {
        xfer += (*_iter199).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cells) {
    xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
      std::vector<Cell> ::const_iterator _iter200;
      for (_iter200 = this->cells.begin(); _iter200 != this->cells.end(); ++_iter200)
      {
        xfer += (*_iter200).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compact) {
    xfer += oprot->writeFieldBegin("compact", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->compact.size()));
      std::vector<CompactResult> ::const_iterator _iter201;
      for (_iter201 = this->compact.begin(); _iter201 != this->compact.end(); ++_iter201)
      {
        xfer += (*_iter201).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Result &a, Result &b) {
  using ::std::swap;
  swap(a.schemas, b.schemas);
  swap(a.cells, b.cells);
  swap(a.compact, b.compact);
  swap(a.__isset, b.__isset);
}

Result::Result(const Result& other202) {
  schemas = other202.schemas;
  cells = other202.cells;
  compact = other202.compact;
  __isset = other202.__isset;
}
Result& Result::operator=(const Result& other203) {
  schemas = other203.schemas;
  cells = other203.cells;
  compact = other203.compact;
  __isset = other203.__isset;
  return *this;
}
void Result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Result(";
  out << "schemas="; (__isset.schemas ? (out << to_string(schemas)) : (out << "<null>"));
  out << ", " << "cells="; (__isset.cells ? (out << to_string(cells)) : (out << "<null>"));
  out << ", " << "compact="; (__isset.compact ? (out << to_string(compact)) : (out << "<null>"));
  out << ")";
}

}} // namespace
