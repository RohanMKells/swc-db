/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Service_TYPES_H
#define Service_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>


namespace SWC { namespace Thrift {

struct KeySeq {
  enum type {
    UNKNOWN = 0,
    LEXIC = 1,
    VOLUME = 2,
    FC_LEXIC = 3,
    FC_VOLUME = 4
  };
};

extern const std::map<int, const char*> _KeySeq_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const KeySeq::type& val);

std::string to_string(const KeySeq::type& val);

struct ColumnType {
  enum type {
    UNKNOWN = 0,
    PLAIN = 1,
    COUNTER_I64 = 2,
    COUNTER_I32 = 3,
    COUNTER_I16 = 4,
    COUNTER_I8 = 5,
    CELL_DEFINED = 15
  };
};

extern const std::map<int, const char*> _ColumnType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ColumnType::type& val);

std::string to_string(const ColumnType::type& val);

struct EncodingType {
  enum type {
    DEFAULT = 0,
    PLAIN = 1,
    ZLIB = 2,
    SNAPPY = 3,
    ZSTD = 4,
    UNKNOWN = 255
  };
};

extern const std::map<int, const char*> _EncodingType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const EncodingType::type& val);

std::string to_string(const EncodingType::type& val);

struct SchemaFunc {
  enum type {
    CREATE = 3,
    DELETE = 5,
    MODIFY = 7
  };
};

extern const std::map<int, const char*> _SchemaFunc_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const SchemaFunc::type& val);

std::string to_string(const SchemaFunc::type& val);

struct Comp {
  enum type {
    NONE = 0,
    PF = 1,
    GT = 2,
    GE = 3,
    EQ = 4,
    LE = 5,
    LT = 6,
    NE = 7,
    RE = 8,
    VGT = 9,
    VGE = 10,
    VLE = 11,
    VLT = 12
  };
};

extern const std::map<int, const char*> _Comp_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const Comp::type& val);

std::string to_string(const Comp::type& val);

struct SpecFlagsOpt {
  enum type {
    NONE = 0,
    LIMIT_BY_KEYS = 1,
    OFFSET_BY_KEYS = 4,
    ONLY_KEYS = 8,
    ONLY_DELETES = 10
  };
};

extern const std::map<int, const char*> _SpecFlagsOpt_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const SpecFlagsOpt::type& val);

std::string to_string(const SpecFlagsOpt::type& val);

struct Flag {
  enum type {
    NONE = 0,
    INSERT = 1,
    DELETE = 2,
    DELETE_VERSION = 3
  };
};

extern const std::map<int, const char*> _Flag_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const Flag::type& val);

std::string to_string(const Flag::type& val);

struct CellsResult {
  enum type {
    IN_LIST = 0,
    ON_COLUMN = 1,
    ON_KEY = 2,
    ON_FRACTION = 3
  };
};

extern const std::map<int, const char*> _CellsResult_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const CellsResult::type& val);

std::string to_string(const CellsResult::type& val);

typedef std::vector<class Schema>  Schemas;

typedef std::vector<std::string>  Key;

typedef std::vector<class SpecFraction>  SpecKey;

typedef std::vector<class SpecKeyInterval>  SpecKeyIntervals;

typedef std::vector<class UCell>  UCells;

typedef std::map<int64_t, UCells>  UCCells;

typedef std::vector<class Cell>  Cells;

typedef std::vector<class CCell>  ColCells;

typedef std::map<std::string, ColCells>  CCells;

typedef std::vector<class kCells>  KCells;

typedef std::vector<class CompactResult>  CompactResults;

class Exception;

class Schema;

class SchemaPattern;

class SpecSchemas;

class SpecFlags;

class SpecFraction;

class SpecValue;

class SpecTimestamp;

class SpecKeyInterval;

class SpecInterval;

class SpecColumn;

class SpecScan;

class UCell;

class Cell;

class CCell;

class KCell;

class kCells;

class FCell;

class FCells;

class CellsGroup;

class CompactResult;

class Result;

typedef struct _Exception__isset {
  _Exception__isset() : code(false), message(false) {}
  bool code :1;
  bool message :1;
} _Exception__isset;

class Exception : public ::apache::thrift::TException {
 public:

  Exception(const Exception&);
  Exception& operator=(const Exception&);
  Exception() : code(0), message() {
  }

  virtual ~Exception() noexcept;
  int32_t code;
  std::string message;

  _Exception__isset __isset;

  void __set_code(const int32_t val);

  void __set_message(const std::string& val);

  bool operator == (const Exception & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const Exception &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Exception & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept;
};

void swap(Exception &a, Exception &b);

std::ostream& operator<<(std::ostream& out, const Exception& obj);

typedef struct _Schema__isset {
  _Schema__isset() : cid(false), col_name(false), col_seq(false), col_type(false), cell_versions(false), cell_ttl(false), blk_encoding(false), blk_size(false), blk_cells(false), cs_replication(false), cs_size(false), cs_max(false), log_rollout_ratio(false), log_compact_cointervaling(false), log_fragment_preload(false), compact_percent(false), revision(false) {}
  bool cid :1;
  bool col_name :1;
  bool col_seq :1;
  bool col_type :1;
  bool cell_versions :1;
  bool cell_ttl :1;
  bool blk_encoding :1;
  bool blk_size :1;
  bool blk_cells :1;
  bool cs_replication :1;
  bool cs_size :1;
  bool cs_max :1;
  bool log_rollout_ratio :1;
  bool log_compact_cointervaling :1;
  bool log_fragment_preload :1;
  bool compact_percent :1;
  bool revision :1;
} _Schema__isset;

class Schema : public virtual ::apache::thrift::TBase {
 public:

  Schema(const Schema&);
  Schema& operator=(const Schema&);
  Schema() : cid(0), col_name(), col_seq((KeySeq::type)0), col_type((ColumnType::type)0), cell_versions(0), cell_ttl(0), blk_encoding((EncodingType::type)0), blk_size(0), blk_cells(0), cs_replication(0), cs_size(0), cs_max(0), log_rollout_ratio(0), log_compact_cointervaling(0), log_fragment_preload(0), compact_percent(0), revision(0) {
  }

  virtual ~Schema() noexcept;
  int64_t cid;
  std::string col_name;
  KeySeq::type col_seq;
  ColumnType::type col_type;
  int32_t cell_versions;
  int32_t cell_ttl;
  EncodingType::type blk_encoding;
  int32_t blk_size;
  int32_t blk_cells;
  int8_t cs_replication;
  int32_t cs_size;
  int8_t cs_max;
  int8_t log_rollout_ratio;
  int8_t log_compact_cointervaling;
  int8_t log_fragment_preload;
  int8_t compact_percent;
  int64_t revision;

  _Schema__isset __isset;

  void __set_cid(const int64_t val);

  void __set_col_name(const std::string& val);

  void __set_col_seq(const KeySeq::type val);

  void __set_col_type(const ColumnType::type val);

  void __set_cell_versions(const int32_t val);

  void __set_cell_ttl(const int32_t val);

  void __set_blk_encoding(const EncodingType::type val);

  void __set_blk_size(const int32_t val);

  void __set_blk_cells(const int32_t val);

  void __set_cs_replication(const int8_t val);

  void __set_cs_size(const int32_t val);

  void __set_cs_max(const int8_t val);

  void __set_log_rollout_ratio(const int8_t val);

  void __set_log_compact_cointervaling(const int8_t val);

  void __set_log_fragment_preload(const int8_t val);

  void __set_compact_percent(const int8_t val);

  void __set_revision(const int64_t val);

  bool operator == (const Schema & rhs) const
  {
    if (__isset.cid != rhs.__isset.cid)
      return false;
    else if (__isset.cid && !(cid == rhs.cid))
      return false;
    if (__isset.col_name != rhs.__isset.col_name)
      return false;
    else if (__isset.col_name && !(col_name == rhs.col_name))
      return false;
    if (__isset.col_seq != rhs.__isset.col_seq)
      return false;
    else if (__isset.col_seq && !(col_seq == rhs.col_seq))
      return false;
    if (__isset.col_type != rhs.__isset.col_type)
      return false;
    else if (__isset.col_type && !(col_type == rhs.col_type))
      return false;
    if (__isset.cell_versions != rhs.__isset.cell_versions)
      return false;
    else if (__isset.cell_versions && !(cell_versions == rhs.cell_versions))
      return false;
    if (__isset.cell_ttl != rhs.__isset.cell_ttl)
      return false;
    else if (__isset.cell_ttl && !(cell_ttl == rhs.cell_ttl))
      return false;
    if (__isset.blk_encoding != rhs.__isset.blk_encoding)
      return false;
    else if (__isset.blk_encoding && !(blk_encoding == rhs.blk_encoding))
      return false;
    if (__isset.blk_size != rhs.__isset.blk_size)
      return false;
    else if (__isset.blk_size && !(blk_size == rhs.blk_size))
      return false;
    if (__isset.blk_cells != rhs.__isset.blk_cells)
      return false;
    else if (__isset.blk_cells && !(blk_cells == rhs.blk_cells))
      return false;
    if (__isset.cs_replication != rhs.__isset.cs_replication)
      return false;
    else if (__isset.cs_replication && !(cs_replication == rhs.cs_replication))
      return false;
    if (__isset.cs_size != rhs.__isset.cs_size)
      return false;
    else if (__isset.cs_size && !(cs_size == rhs.cs_size))
      return false;
    if (__isset.cs_max != rhs.__isset.cs_max)
      return false;
    else if (__isset.cs_max && !(cs_max == rhs.cs_max))
      return false;
    if (__isset.log_rollout_ratio != rhs.__isset.log_rollout_ratio)
      return false;
    else if (__isset.log_rollout_ratio && !(log_rollout_ratio == rhs.log_rollout_ratio))
      return false;
    if (__isset.log_compact_cointervaling != rhs.__isset.log_compact_cointervaling)
      return false;
    else if (__isset.log_compact_cointervaling && !(log_compact_cointervaling == rhs.log_compact_cointervaling))
      return false;
    if (__isset.log_fragment_preload != rhs.__isset.log_fragment_preload)
      return false;
    else if (__isset.log_fragment_preload && !(log_fragment_preload == rhs.log_fragment_preload))
      return false;
    if (__isset.compact_percent != rhs.__isset.compact_percent)
      return false;
    else if (__isset.compact_percent && !(compact_percent == rhs.compact_percent))
      return false;
    if (__isset.revision != rhs.__isset.revision)
      return false;
    else if (__isset.revision && !(revision == rhs.revision))
      return false;
    return true;
  }
  bool operator != (const Schema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Schema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Schema &a, Schema &b);

std::ostream& operator<<(std::ostream& out, const Schema& obj);

typedef struct _SchemaPattern__isset {
  _SchemaPattern__isset() : comp(false), value(false) {}
  bool comp :1;
  bool value :1;
} _SchemaPattern__isset;

class SchemaPattern : public virtual ::apache::thrift::TBase {
 public:

  SchemaPattern(const SchemaPattern&);
  SchemaPattern& operator=(const SchemaPattern&);
  SchemaPattern() : comp((Comp::type)0), value() {
  }

  virtual ~SchemaPattern() noexcept;
  Comp::type comp;
  std::string value;

  _SchemaPattern__isset __isset;

  void __set_comp(const Comp::type val);

  void __set_value(const std::string& val);

  bool operator == (const SchemaPattern & rhs) const
  {
    if (!(comp == rhs.comp))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const SchemaPattern &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SchemaPattern & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SchemaPattern &a, SchemaPattern &b);

std::ostream& operator<<(std::ostream& out, const SchemaPattern& obj);

typedef struct _SpecSchemas__isset {
  _SpecSchemas__isset() : cids(false), names(false), patterns(false) {}
  bool cids :1;
  bool names :1;
  bool patterns :1;
} _SpecSchemas__isset;

class SpecSchemas : public virtual ::apache::thrift::TBase {
 public:

  SpecSchemas(const SpecSchemas&);
  SpecSchemas& operator=(const SpecSchemas&);
  SpecSchemas() {
  }

  virtual ~SpecSchemas() noexcept;
  std::vector<int64_t>  cids;
  std::vector<std::string>  names;
  std::vector<SchemaPattern>  patterns;

  _SpecSchemas__isset __isset;

  void __set_cids(const std::vector<int64_t> & val);

  void __set_names(const std::vector<std::string> & val);

  void __set_patterns(const std::vector<SchemaPattern> & val);

  bool operator == (const SpecSchemas & rhs) const
  {
    if (__isset.cids != rhs.__isset.cids)
      return false;
    else if (__isset.cids && !(cids == rhs.cids))
      return false;
    if (__isset.names != rhs.__isset.names)
      return false;
    else if (__isset.names && !(names == rhs.names))
      return false;
    if (__isset.patterns != rhs.__isset.patterns)
      return false;
    else if (__isset.patterns && !(patterns == rhs.patterns))
      return false;
    return true;
  }
  bool operator != (const SpecSchemas &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecSchemas & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecSchemas &a, SpecSchemas &b);

std::ostream& operator<<(std::ostream& out, const SpecSchemas& obj);

typedef struct _SpecFlags__isset {
  _SpecFlags__isset() : limit(false), offset(false), max_versions(false), max_buffer(false), options(false) {}
  bool limit :1;
  bool offset :1;
  bool max_versions :1;
  bool max_buffer :1;
  bool options :1;
} _SpecFlags__isset;

class SpecFlags : public virtual ::apache::thrift::TBase {
 public:

  SpecFlags(const SpecFlags&);
  SpecFlags& operator=(const SpecFlags&);
  SpecFlags() : limit(0), offset(0), max_versions(0), max_buffer(0), options(0) {
  }

  virtual ~SpecFlags() noexcept;
  int64_t limit;
  int64_t offset;
  int32_t max_versions;
  int32_t max_buffer;
  int8_t options;

  _SpecFlags__isset __isset;

  void __set_limit(const int64_t val);

  void __set_offset(const int64_t val);

  void __set_max_versions(const int32_t val);

  void __set_max_buffer(const int32_t val);

  void __set_options(const int8_t val);

  bool operator == (const SpecFlags & rhs) const
  {
    if (__isset.limit != rhs.__isset.limit)
      return false;
    else if (__isset.limit && !(limit == rhs.limit))
      return false;
    if (__isset.offset != rhs.__isset.offset)
      return false;
    else if (__isset.offset && !(offset == rhs.offset))
      return false;
    if (__isset.max_versions != rhs.__isset.max_versions)
      return false;
    else if (__isset.max_versions && !(max_versions == rhs.max_versions))
      return false;
    if (__isset.max_buffer != rhs.__isset.max_buffer)
      return false;
    else if (__isset.max_buffer && !(max_buffer == rhs.max_buffer))
      return false;
    if (__isset.options != rhs.__isset.options)
      return false;
    else if (__isset.options && !(options == rhs.options))
      return false;
    return true;
  }
  bool operator != (const SpecFlags &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecFlags & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecFlags &a, SpecFlags &b);

std::ostream& operator<<(std::ostream& out, const SpecFlags& obj);

typedef struct _SpecFraction__isset {
  _SpecFraction__isset() : comp(false), f(false) {}
  bool comp :1;
  bool f :1;
} _SpecFraction__isset;

class SpecFraction : public virtual ::apache::thrift::TBase {
 public:

  SpecFraction(const SpecFraction&);
  SpecFraction& operator=(const SpecFraction&);
  SpecFraction() : comp((Comp::type)0), f() {
  }

  virtual ~SpecFraction() noexcept;
  Comp::type comp;
  std::string f;

  _SpecFraction__isset __isset;

  void __set_comp(const Comp::type val);

  void __set_f(const std::string& val);

  bool operator == (const SpecFraction & rhs) const
  {
    if (!(comp == rhs.comp))
      return false;
    if (!(f == rhs.f))
      return false;
    return true;
  }
  bool operator != (const SpecFraction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecFraction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecFraction &a, SpecFraction &b);

std::ostream& operator<<(std::ostream& out, const SpecFraction& obj);

typedef struct _SpecValue__isset {
  _SpecValue__isset() : comp(false), v(false) {}
  bool comp :1;
  bool v :1;
} _SpecValue__isset;

class SpecValue : public virtual ::apache::thrift::TBase {
 public:

  SpecValue(const SpecValue&);
  SpecValue& operator=(const SpecValue&);
  SpecValue() : comp((Comp::type)0), v() {
  }

  virtual ~SpecValue() noexcept;
  Comp::type comp;
  std::string v;

  _SpecValue__isset __isset;

  void __set_comp(const Comp::type val);

  void __set_v(const std::string& val);

  bool operator == (const SpecValue & rhs) const
  {
    if (!(comp == rhs.comp))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const SpecValue &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecValue & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecValue &a, SpecValue &b);

std::ostream& operator<<(std::ostream& out, const SpecValue& obj);

typedef struct _SpecTimestamp__isset {
  _SpecTimestamp__isset() : comp(false), ts(false) {}
  bool comp :1;
  bool ts :1;
} _SpecTimestamp__isset;

class SpecTimestamp : public virtual ::apache::thrift::TBase {
 public:

  SpecTimestamp(const SpecTimestamp&);
  SpecTimestamp& operator=(const SpecTimestamp&);
  SpecTimestamp() : comp((Comp::type)0), ts(0) {
  }

  virtual ~SpecTimestamp() noexcept;
  Comp::type comp;
  int64_t ts;

  _SpecTimestamp__isset __isset;

  void __set_comp(const Comp::type val);

  void __set_ts(const int64_t val);

  bool operator == (const SpecTimestamp & rhs) const
  {
    if (!(comp == rhs.comp))
      return false;
    if (!(ts == rhs.ts))
      return false;
    return true;
  }
  bool operator != (const SpecTimestamp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecTimestamp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecTimestamp &a, SpecTimestamp &b);

std::ostream& operator<<(std::ostream& out, const SpecTimestamp& obj);

typedef struct _SpecKeyInterval__isset {
  _SpecKeyInterval__isset() : start(false), finish(false) {}
  bool start :1;
  bool finish :1;
} _SpecKeyInterval__isset;

class SpecKeyInterval : public virtual ::apache::thrift::TBase {
 public:

  SpecKeyInterval(const SpecKeyInterval&);
  SpecKeyInterval& operator=(const SpecKeyInterval&);
  SpecKeyInterval() {
  }

  virtual ~SpecKeyInterval() noexcept;
  SpecKey start;
  SpecKey finish;

  _SpecKeyInterval__isset __isset;

  void __set_start(const SpecKey& val);

  void __set_finish(const SpecKey& val);

  bool operator == (const SpecKeyInterval & rhs) const
  {
    if (__isset.start != rhs.__isset.start)
      return false;
    else if (__isset.start && !(start == rhs.start))
      return false;
    if (__isset.finish != rhs.__isset.finish)
      return false;
    else if (__isset.finish && !(finish == rhs.finish))
      return false;
    return true;
  }
  bool operator != (const SpecKeyInterval &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecKeyInterval & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecKeyInterval &a, SpecKeyInterval &b);

std::ostream& operator<<(std::ostream& out, const SpecKeyInterval& obj);

typedef struct _SpecInterval__isset {
  _SpecInterval__isset() : range_begin(false), range_end(false), range_offset(false), offset_key(false), offset_rev(false), key_intervals(false), value(false), ts_start(false), ts_finish(false), flags(false) {}
  bool range_begin :1;
  bool range_end :1;
  bool range_offset :1;
  bool offset_key :1;
  bool offset_rev :1;
  bool key_intervals :1;
  bool value :1;
  bool ts_start :1;
  bool ts_finish :1;
  bool flags :1;
} _SpecInterval__isset;

class SpecInterval : public virtual ::apache::thrift::TBase {
 public:

  SpecInterval(const SpecInterval&);
  SpecInterval& operator=(const SpecInterval&);
  SpecInterval() : offset_rev(0) {
  }

  virtual ~SpecInterval() noexcept;
  Key range_begin;
  Key range_end;
  Key range_offset;
  Key offset_key;
  int64_t offset_rev;
  SpecKeyIntervals key_intervals;
  SpecValue value;
  SpecTimestamp ts_start;
  SpecTimestamp ts_finish;
  SpecFlags flags;

  _SpecInterval__isset __isset;

  void __set_range_begin(const Key& val);

  void __set_range_end(const Key& val);

  void __set_range_offset(const Key& val);

  void __set_offset_key(const Key& val);

  void __set_offset_rev(const int64_t val);

  void __set_key_intervals(const SpecKeyIntervals& val);

  void __set_value(const SpecValue& val);

  void __set_ts_start(const SpecTimestamp& val);

  void __set_ts_finish(const SpecTimestamp& val);

  void __set_flags(const SpecFlags& val);

  bool operator == (const SpecInterval & rhs) const
  {
    if (__isset.range_begin != rhs.__isset.range_begin)
      return false;
    else if (__isset.range_begin && !(range_begin == rhs.range_begin))
      return false;
    if (__isset.range_end != rhs.__isset.range_end)
      return false;
    else if (__isset.range_end && !(range_end == rhs.range_end))
      return false;
    if (__isset.range_offset != rhs.__isset.range_offset)
      return false;
    else if (__isset.range_offset && !(range_offset == rhs.range_offset))
      return false;
    if (__isset.offset_key != rhs.__isset.offset_key)
      return false;
    else if (__isset.offset_key && !(offset_key == rhs.offset_key))
      return false;
    if (__isset.offset_rev != rhs.__isset.offset_rev)
      return false;
    else if (__isset.offset_rev && !(offset_rev == rhs.offset_rev))
      return false;
    if (__isset.key_intervals != rhs.__isset.key_intervals)
      return false;
    else if (__isset.key_intervals && !(key_intervals == rhs.key_intervals))
      return false;
    if (__isset.value != rhs.__isset.value)
      return false;
    else if (__isset.value && !(value == rhs.value))
      return false;
    if (__isset.ts_start != rhs.__isset.ts_start)
      return false;
    else if (__isset.ts_start && !(ts_start == rhs.ts_start))
      return false;
    if (__isset.ts_finish != rhs.__isset.ts_finish)
      return false;
    else if (__isset.ts_finish && !(ts_finish == rhs.ts_finish))
      return false;
    if (__isset.flags != rhs.__isset.flags)
      return false;
    else if (__isset.flags && !(flags == rhs.flags))
      return false;
    return true;
  }
  bool operator != (const SpecInterval &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecInterval & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecInterval &a, SpecInterval &b);

std::ostream& operator<<(std::ostream& out, const SpecInterval& obj);

typedef struct _SpecColumn__isset {
  _SpecColumn__isset() : cid(false), intervals(false) {}
  bool cid :1;
  bool intervals :1;
} _SpecColumn__isset;

class SpecColumn : public virtual ::apache::thrift::TBase {
 public:

  SpecColumn(const SpecColumn&);
  SpecColumn& operator=(const SpecColumn&);
  SpecColumn() : cid(0) {
  }

  virtual ~SpecColumn() noexcept;
  int64_t cid;
  std::vector<SpecInterval>  intervals;

  _SpecColumn__isset __isset;

  void __set_cid(const int64_t val);

  void __set_intervals(const std::vector<SpecInterval> & val);

  bool operator == (const SpecColumn & rhs) const
  {
    if (!(cid == rhs.cid))
      return false;
    if (!(intervals == rhs.intervals))
      return false;
    return true;
  }
  bool operator != (const SpecColumn &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecColumn & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecColumn &a, SpecColumn &b);

std::ostream& operator<<(std::ostream& out, const SpecColumn& obj);

typedef struct _SpecScan__isset {
  _SpecScan__isset() : columns(false), flags(false) {}
  bool columns :1;
  bool flags :1;
} _SpecScan__isset;

class SpecScan : public virtual ::apache::thrift::TBase {
 public:

  SpecScan(const SpecScan&);
  SpecScan& operator=(const SpecScan&);
  SpecScan() {
  }

  virtual ~SpecScan() noexcept;
  std::vector<SpecColumn>  columns;
  SpecFlags flags;

  _SpecScan__isset __isset;

  void __set_columns(const std::vector<SpecColumn> & val);

  void __set_flags(const SpecFlags& val);

  bool operator == (const SpecScan & rhs) const
  {
    if (!(columns == rhs.columns))
      return false;
    if (__isset.flags != rhs.__isset.flags)
      return false;
    else if (__isset.flags && !(flags == rhs.flags))
      return false;
    return true;
  }
  bool operator != (const SpecScan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecScan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecScan &a, SpecScan &b);

std::ostream& operator<<(std::ostream& out, const SpecScan& obj);

typedef struct _UCell__isset {
  _UCell__isset() : f(false), k(false), ts(false), ts_desc(false), v(false) {}
  bool f :1;
  bool k :1;
  bool ts :1;
  bool ts_desc :1;
  bool v :1;
} _UCell__isset;

class UCell : public virtual ::apache::thrift::TBase {
 public:

  UCell(const UCell&);
  UCell& operator=(const UCell&);
  UCell() : f((Flag::type)0), ts(0), ts_desc(0), v() {
  }

  virtual ~UCell() noexcept;
  Flag::type f;
  Key k;
  int64_t ts;
  bool ts_desc;
  std::string v;

  _UCell__isset __isset;

  void __set_f(const Flag::type val);

  void __set_k(const Key& val);

  void __set_ts(const int64_t val);

  void __set_ts_desc(const bool val);

  void __set_v(const std::string& val);

  bool operator == (const UCell & rhs) const
  {
    if (!(f == rhs.f))
      return false;
    if (!(k == rhs.k))
      return false;
    if (__isset.ts != rhs.__isset.ts)
      return false;
    else if (__isset.ts && !(ts == rhs.ts))
      return false;
    if (__isset.ts_desc != rhs.__isset.ts_desc)
      return false;
    else if (__isset.ts_desc && !(ts_desc == rhs.ts_desc))
      return false;
    if (__isset.v != rhs.__isset.v)
      return false;
    else if (__isset.v && !(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const UCell &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UCell & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(UCell &a, UCell &b);

std::ostream& operator<<(std::ostream& out, const UCell& obj);

typedef struct _Cell__isset {
  _Cell__isset() : c(false), k(false), ts(false), v(false) {}
  bool c :1;
  bool k :1;
  bool ts :1;
  bool v :1;
} _Cell__isset;

class Cell : public virtual ::apache::thrift::TBase {
 public:

  Cell(const Cell&);
  Cell& operator=(const Cell&);
  Cell() : c(), ts(0), v() {
  }

  virtual ~Cell() noexcept;
  std::string c;
  Key k;
  int64_t ts;
  std::string v;

  _Cell__isset __isset;

  void __set_c(const std::string& val);

  void __set_k(const Key& val);

  void __set_ts(const int64_t val);

  void __set_v(const std::string& val);

  bool operator == (const Cell & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(k == rhs.k))
      return false;
    if (!(ts == rhs.ts))
      return false;
    if (__isset.v != rhs.__isset.v)
      return false;
    else if (__isset.v && !(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const Cell &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cell & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Cell &a, Cell &b);

std::ostream& operator<<(std::ostream& out, const Cell& obj);

typedef struct _CCell__isset {
  _CCell__isset() : k(false), ts(false), v(false) {}
  bool k :1;
  bool ts :1;
  bool v :1;
} _CCell__isset;

class CCell : public virtual ::apache::thrift::TBase {
 public:

  CCell(const CCell&);
  CCell& operator=(const CCell&);
  CCell() : ts(0), v() {
  }

  virtual ~CCell() noexcept;
  Key k;
  int64_t ts;
  std::string v;

  _CCell__isset __isset;

  void __set_k(const Key& val);

  void __set_ts(const int64_t val);

  void __set_v(const std::string& val);

  bool operator == (const CCell & rhs) const
  {
    if (!(k == rhs.k))
      return false;
    if (!(ts == rhs.ts))
      return false;
    if (__isset.v != rhs.__isset.v)
      return false;
    else if (__isset.v && !(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const CCell &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CCell & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CCell &a, CCell &b);

std::ostream& operator<<(std::ostream& out, const CCell& obj);

typedef struct _KCell__isset {
  _KCell__isset() : c(false), ts(false), v(false) {}
  bool c :1;
  bool ts :1;
  bool v :1;
} _KCell__isset;

class KCell : public virtual ::apache::thrift::TBase {
 public:

  KCell(const KCell&);
  KCell& operator=(const KCell&);
  KCell() : c(), ts(0), v() {
  }

  virtual ~KCell() noexcept;
  std::string c;
  int64_t ts;
  std::string v;

  _KCell__isset __isset;

  void __set_c(const std::string& val);

  void __set_ts(const int64_t val);

  void __set_v(const std::string& val);

  bool operator == (const KCell & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(ts == rhs.ts))
      return false;
    if (__isset.v != rhs.__isset.v)
      return false;
    else if (__isset.v && !(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const KCell &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KCell & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(KCell &a, KCell &b);

std::ostream& operator<<(std::ostream& out, const KCell& obj);

typedef struct _kCells__isset {
  _kCells__isset() : k(false), cells(false) {}
  bool k :1;
  bool cells :1;
} _kCells__isset;

class kCells : public virtual ::apache::thrift::TBase {
 public:

  kCells(const kCells&);
  kCells& operator=(const kCells&);
  kCells() {
  }

  virtual ~kCells() noexcept;
  Key k;
  std::vector<KCell>  cells;

  _kCells__isset __isset;

  void __set_k(const Key& val);

  void __set_cells(const std::vector<KCell> & val);

  bool operator == (const kCells & rhs) const
  {
    if (!(k == rhs.k))
      return false;
    if (!(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const kCells &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const kCells & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(kCells &a, kCells &b);

std::ostream& operator<<(std::ostream& out, const kCells& obj);

typedef struct _FCell__isset {
  _FCell__isset() : c(false), ts(false), v(false) {}
  bool c :1;
  bool ts :1;
  bool v :1;
} _FCell__isset;

class FCell : public virtual ::apache::thrift::TBase {
 public:

  FCell(const FCell&);
  FCell& operator=(const FCell&);
  FCell() : c(), ts(0), v() {
  }

  virtual ~FCell() noexcept;
  std::string c;
  int64_t ts;
  std::string v;

  _FCell__isset __isset;

  void __set_c(const std::string& val);

  void __set_ts(const int64_t val);

  void __set_v(const std::string& val);

  bool operator == (const FCell & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(ts == rhs.ts))
      return false;
    if (__isset.v != rhs.__isset.v)
      return false;
    else if (__isset.v && !(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const FCell &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FCell & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FCell &a, FCell &b);

std::ostream& operator<<(std::ostream& out, const FCell& obj);

typedef struct _FCells__isset {
  _FCells__isset() : f(false), cells(false) {}
  bool f :1;
  bool cells :1;
} _FCells__isset;

class FCells : public virtual ::apache::thrift::TBase {
 public:

  FCells(const FCells&);
  FCells& operator=(const FCells&);
  FCells() {
  }

  virtual ~FCells() noexcept;
  std::map<std::string, FCells>  f;
  std::vector<FCell>  cells;

  _FCells__isset __isset;

  void __set_f(const std::map<std::string, FCells> & val);

  void __set_cells(const std::vector<FCell> & val);

  bool operator == (const FCells & rhs) const
  {
    if (!(f == rhs.f))
      return false;
    if (__isset.cells != rhs.__isset.cells)
      return false;
    else if (__isset.cells && !(cells == rhs.cells))
      return false;
    return true;
  }
  bool operator != (const FCells &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FCells & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FCells &a, FCells &b);

std::ostream& operator<<(std::ostream& out, const FCells& obj);

typedef struct _CellsGroup__isset {
  _CellsGroup__isset() : cells(false), ccells(false), kcells(false), fcells(false) {}
  bool cells :1;
  bool ccells :1;
  bool kcells :1;
  bool fcells :1;
} _CellsGroup__isset;

class CellsGroup : public virtual ::apache::thrift::TBase {
 public:

  CellsGroup(const CellsGroup&);
  CellsGroup& operator=(const CellsGroup&);
  CellsGroup() {
  }

  virtual ~CellsGroup() noexcept;
  Cells cells;
  CCells ccells;
  KCells kcells;
  FCells fcells;

  _CellsGroup__isset __isset;

  void __set_cells(const Cells& val);

  void __set_ccells(const CCells& val);

  void __set_kcells(const KCells& val);

  void __set_fcells(const FCells& val);

  bool operator == (const CellsGroup & rhs) const
  {
    if (__isset.cells != rhs.__isset.cells)
      return false;
    else if (__isset.cells && !(cells == rhs.cells))
      return false;
    if (__isset.ccells != rhs.__isset.ccells)
      return false;
    else if (__isset.ccells && !(ccells == rhs.ccells))
      return false;
    if (__isset.kcells != rhs.__isset.kcells)
      return false;
    else if (__isset.kcells && !(kcells == rhs.kcells))
      return false;
    if (__isset.fcells != rhs.__isset.fcells)
      return false;
    else if (__isset.fcells && !(fcells == rhs.fcells))
      return false;
    return true;
  }
  bool operator != (const CellsGroup &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CellsGroup & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CellsGroup &a, CellsGroup &b);

std::ostream& operator<<(std::ostream& out, const CellsGroup& obj);

typedef struct _CompactResult__isset {
  _CompactResult__isset() : cid(false), err(false) {}
  bool cid :1;
  bool err :1;
} _CompactResult__isset;

class CompactResult : public virtual ::apache::thrift::TBase {
 public:

  CompactResult(const CompactResult&);
  CompactResult& operator=(const CompactResult&);
  CompactResult() : cid(0), err(0) {
  }

  virtual ~CompactResult() noexcept;
  int64_t cid;
  int32_t err;

  _CompactResult__isset __isset;

  void __set_cid(const int64_t val);

  void __set_err(const int32_t val);

  bool operator == (const CompactResult & rhs) const
  {
    if (!(cid == rhs.cid))
      return false;
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const CompactResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CompactResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CompactResult &a, CompactResult &b);

std::ostream& operator<<(std::ostream& out, const CompactResult& obj);

typedef struct _Result__isset {
  _Result__isset() : schemas(false), cells(false), compact(false) {}
  bool schemas :1;
  bool cells :1;
  bool compact :1;
} _Result__isset;

class Result : public virtual ::apache::thrift::TBase {
 public:

  Result(const Result&);
  Result& operator=(const Result&);
  Result() {
  }

  virtual ~Result() noexcept;
  Schemas schemas;
  Cells cells;
  CompactResults compact;

  _Result__isset __isset;

  void __set_schemas(const Schemas& val);

  void __set_cells(const Cells& val);

  void __set_compact(const CompactResults& val);

  bool operator == (const Result & rhs) const
  {
    if (__isset.schemas != rhs.__isset.schemas)
      return false;
    else if (__isset.schemas && !(schemas == rhs.schemas))
      return false;
    if (__isset.cells != rhs.__isset.cells)
      return false;
    else if (__isset.cells && !(cells == rhs.cells))
      return false;
    if (__isset.compact != rhs.__isset.compact)
      return false;
    else if (__isset.compact && !(compact == rhs.compact))
      return false;
    return true;
  }
  bool operator != (const Result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Result &a, Result &b);

std::ostream& operator<<(std::ostream& out, const Result& obj);

}} // namespace

#endif
