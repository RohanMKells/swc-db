/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "service_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_ColumnMng(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case COLUMN_MNG_CREATE:return "COLUMN_MNG_CREATE";
  case COLUMN_MNG_DELETE:return "COLUMN_MNG_DELETE";
  case COLUMN_MNG_MODIFY:return "COLUMN_MNG_MODIFY";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_ColumnType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case COLUMN_TYPE_UNKNOWN:return "COLUMN_TYPE_UNKNOWN";
  case COLUMN_TYPE_PLAIN:return "COLUMN_TYPE_PLAIN";
  case COLUMN_TYPE_COUNTER_I64:return "COLUMN_TYPE_COUNTER_I64";
  case COLUMN_TYPE_COUNTER_I32:return "COLUMN_TYPE_COUNTER_I32";
  case COLUMN_TYPE_COUNTER_I16:return "COLUMN_TYPE_COUNTER_I16";
  case COLUMN_TYPE_COUNTER_I8:return "COLUMN_TYPE_COUNTER_I8";
  case COLUMN_TYPE_CELL_DEFINED:return "COLUMN_TYPE_CELL_DEFINED";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_EncodingType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case ENCODING_TYPE_DEFAULT:return "ENCODING_TYPE_DEFAULT";
  case ENCODING_TYPE_PLAIN:return "ENCODING_TYPE_PLAIN";
  case ENCODING_TYPE_ZLIB:return "ENCODING_TYPE_ZLIB";
  case ENCODING_TYPE_SNAPPY:return "ENCODING_TYPE_SNAPPY";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_Flag(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case FLAG_NONE:return "FLAG_NONE";
  case FLAG_INSERT:return "FLAG_INSERT";
  case FLAG_DELETE:return "FLAG_DELETE";
  case FLAG_DELETE_VERSION:return "FLAG_DELETE_VERSION";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_CellsResult(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case CELLS_RESULT_IN_LIST:return "CELLS_RESULT_IN_LIST";
  case CELLS_RESULT_ON_COLUMN:return "CELLS_RESULT_ON_COLUMN";
  case CELLS_RESULT_ON_KEY:return "CELLS_RESULT_ON_KEY";
  case CELLS_RESULT_ON_FRACTION:return "CELLS_RESULT_ON_FRACTION";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _ExceptionProperties
{
  PROP_EXCEPTION_0,
  PROP_EXCEPTION_CODE,
  PROP_EXCEPTION_MESSAGE
};

/* reads a exception object */
static gint32
exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Exception * this_object = EXCEPTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->code, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_code = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Exception * this_object = EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Exception", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "code", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->code, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
exception_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  Exception *self = EXCEPTION (object);

  switch (property_id)
  {
    case PROP_EXCEPTION_CODE:
      self->code = g_value_get_int (value);
      self->__isset_code = TRUE;
      break;

    case PROP_EXCEPTION_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
exception_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  Exception *self = EXCEPTION (object);

  switch (property_id)
  {
    case PROP_EXCEPTION_CODE:
      g_value_set_int (value, self->code);
      break;

    case PROP_EXCEPTION_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
exception_instance_init (Exception * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->code = 0;
  object->__isset_code = FALSE;
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
exception_finalize (GObject *object)
{
  Exception *tobject = EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
exception_class_init (ExceptionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = exception_read;
  struct_class->write = exception_write;

  gobject_class->finalize = exception_finalize;
  gobject_class->get_property = exception_get_property;
  gobject_class->set_property = exception_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_EXCEPTION_CODE,
     g_param_spec_int ("code",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_EXCEPTION_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Exception),
      0, /* n_preallocs */
      (GInstanceInitFunc) exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define EXCEPTION_ERROR_DOMAIN "exception_error_quark"
GQuark
exception_error_quark (void)
{
  return g_quark_from_static_string (EXCEPTION_ERROR_DOMAIN);
}

enum _SchemaProperties
{
  PROP_SCHEMA_0,
  PROP_SCHEMA_CID,
  PROP_SCHEMA_COL_NAME,
  PROP_SCHEMA_COL_TYPE,
  PROP_SCHEMA_CELL_VERSIONS,
  PROP_SCHEMA_CELL_TTL,
  PROP_SCHEMA_BLK_ENCODING,
  PROP_SCHEMA_BLK_SIZE,
  PROP_SCHEMA_BLK_CELLS,
  PROP_SCHEMA_CS_REPLICATION,
  PROP_SCHEMA_CS_SIZE,
  PROP_SCHEMA_CS_MAX,
  PROP_SCHEMA_COMPACT_PERCENT,
  PROP_SCHEMA_REVISION
};

/* reads a schema object */
static gint32
schema_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Schema * this_object = SCHEMA(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->cid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->col_name != NULL)
          {
            g_free(this_object->col_name);
            this_object->col_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->col_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_col_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast0;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast0, error)) < 0)
            return -1;
          xfer += ret;
          this_object->col_type = (ColumnType)ecast0;
          this_object->__isset_col_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->cell_versions, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cell_versions = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->cell_ttl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cell_ttl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          gint32 ecast1;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->blk_encoding = (EncodingType)ecast1;
          this_object->__isset_blk_encoding = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->blk_size, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_blk_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->blk_cells, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_blk_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->cs_replication, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cs_replication = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->cs_size, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cs_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->cs_max, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cs_max = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->compact_percent, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_compact_percent = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->revision, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_revision = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
schema_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Schema * this_object = SCHEMA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Schema", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_cid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cid", T_I64, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->cid, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_col_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "col_name", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->col_name, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_col_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "col_type", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->col_type, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cell_versions == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cell_versions", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->cell_versions, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cell_ttl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cell_ttl", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->cell_ttl, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_blk_encoding == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "blk_encoding", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->blk_encoding, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_blk_size == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "blk_size", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->blk_size, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_blk_cells == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "blk_cells", T_I32, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->blk_cells, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cs_replication == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cs_replication", T_BYTE, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->cs_replication, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cs_size == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cs_size", T_I32, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->cs_size, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cs_max == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cs_max", T_BYTE, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->cs_max, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_compact_percent == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "compact_percent", T_BYTE, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->compact_percent, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_revision == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "revision", T_I64, 13, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->revision, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
schema_set_property (GObject *object,
                     guint property_id,
                     const GValue *value,
                     GParamSpec *pspec)
{
  Schema *self = SCHEMA (object);

  switch (property_id)
  {
    case PROP_SCHEMA_CID:
      self->cid = g_value_get_int64 (value);
      self->__isset_cid = TRUE;
      break;

    case PROP_SCHEMA_COL_NAME:
      if (self->col_name != NULL)
        g_free (self->col_name);
      self->col_name = g_value_dup_string (value);
      self->__isset_col_name = TRUE;
      break;

    case PROP_SCHEMA_COL_TYPE:
      self->col_type = g_value_get_int (value);
      self->__isset_col_type = TRUE;
      break;

    case PROP_SCHEMA_CELL_VERSIONS:
      self->cell_versions = g_value_get_int (value);
      self->__isset_cell_versions = TRUE;
      break;

    case PROP_SCHEMA_CELL_TTL:
      self->cell_ttl = g_value_get_int (value);
      self->__isset_cell_ttl = TRUE;
      break;

    case PROP_SCHEMA_BLK_ENCODING:
      self->blk_encoding = g_value_get_int (value);
      self->__isset_blk_encoding = TRUE;
      break;

    case PROP_SCHEMA_BLK_SIZE:
      self->blk_size = g_value_get_int (value);
      self->__isset_blk_size = TRUE;
      break;

    case PROP_SCHEMA_BLK_CELLS:
      self->blk_cells = g_value_get_int (value);
      self->__isset_blk_cells = TRUE;
      break;

    case PROP_SCHEMA_CS_REPLICATION:
      self->cs_replication = g_value_get_int (value);
      self->__isset_cs_replication = TRUE;
      break;

    case PROP_SCHEMA_CS_SIZE:
      self->cs_size = g_value_get_int (value);
      self->__isset_cs_size = TRUE;
      break;

    case PROP_SCHEMA_CS_MAX:
      self->cs_max = g_value_get_int (value);
      self->__isset_cs_max = TRUE;
      break;

    case PROP_SCHEMA_COMPACT_PERCENT:
      self->compact_percent = g_value_get_int (value);
      self->__isset_compact_percent = TRUE;
      break;

    case PROP_SCHEMA_REVISION:
      self->revision = g_value_get_int64 (value);
      self->__isset_revision = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
schema_get_property (GObject *object,
                     guint property_id,
                     GValue *value,
                     GParamSpec *pspec)
{
  Schema *self = SCHEMA (object);

  switch (property_id)
  {
    case PROP_SCHEMA_CID:
      g_value_set_int64 (value, self->cid);
      break;

    case PROP_SCHEMA_COL_NAME:
      g_value_set_string (value, self->col_name);
      break;

    case PROP_SCHEMA_COL_TYPE:
      g_value_set_int (value, self->col_type);
      break;

    case PROP_SCHEMA_CELL_VERSIONS:
      g_value_set_int (value, self->cell_versions);
      break;

    case PROP_SCHEMA_CELL_TTL:
      g_value_set_int (value, self->cell_ttl);
      break;

    case PROP_SCHEMA_BLK_ENCODING:
      g_value_set_int (value, self->blk_encoding);
      break;

    case PROP_SCHEMA_BLK_SIZE:
      g_value_set_int (value, self->blk_size);
      break;

    case PROP_SCHEMA_BLK_CELLS:
      g_value_set_int (value, self->blk_cells);
      break;

    case PROP_SCHEMA_CS_REPLICATION:
      g_value_set_int (value, self->cs_replication);
      break;

    case PROP_SCHEMA_CS_SIZE:
      g_value_set_int (value, self->cs_size);
      break;

    case PROP_SCHEMA_CS_MAX:
      g_value_set_int (value, self->cs_max);
      break;

    case PROP_SCHEMA_COMPACT_PERCENT:
      g_value_set_int (value, self->compact_percent);
      break;

    case PROP_SCHEMA_REVISION:
      g_value_set_int64 (value, self->revision);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
schema_instance_init (Schema * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cid = 0;
  object->__isset_cid = FALSE;
  object->col_name = NULL;
  object->__isset_col_name = FALSE;
  object->__isset_col_type = FALSE;
  object->cell_versions = 0;
  object->__isset_cell_versions = FALSE;
  object->cell_ttl = 0;
  object->__isset_cell_ttl = FALSE;
  object->__isset_blk_encoding = FALSE;
  object->blk_size = 0;
  object->__isset_blk_size = FALSE;
  object->blk_cells = 0;
  object->__isset_blk_cells = FALSE;
  object->cs_replication = 0;
  object->__isset_cs_replication = FALSE;
  object->cs_size = 0;
  object->__isset_cs_size = FALSE;
  object->cs_max = 0;
  object->__isset_cs_max = FALSE;
  object->compact_percent = 0;
  object->__isset_compact_percent = FALSE;
  object->revision = 0;
  object->__isset_revision = FALSE;
}

static void 
schema_finalize (GObject *object)
{
  Schema *tobject = SCHEMA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->col_name != NULL)
  {
    g_free(tobject->col_name);
    tobject->col_name = NULL;
  }
}

static void
schema_class_init (SchemaClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = schema_read;
  struct_class->write = schema_write;

  gobject_class->finalize = schema_finalize;
  gobject_class->get_property = schema_get_property;
  gobject_class->set_property = schema_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_CID,
     g_param_spec_int64 ("cid",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_COL_NAME,
     g_param_spec_string ("col_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_COL_TYPE,
     g_param_spec_int ("col_type",
                       NULL,
                       NULL,
                       0,
                       15,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_CELL_VERSIONS,
     g_param_spec_int ("cell_versions",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_CELL_TTL,
     g_param_spec_int ("cell_ttl",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_BLK_ENCODING,
     g_param_spec_int ("blk_encoding",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_BLK_SIZE,
     g_param_spec_int ("blk_size",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_BLK_CELLS,
     g_param_spec_int ("blk_cells",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_CS_REPLICATION,
     g_param_spec_int ("cs_replication",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_CS_SIZE,
     g_param_spec_int ("cs_size",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_CS_MAX,
     g_param_spec_int ("cs_max",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_COMPACT_PERCENT,
     g_param_spec_int ("compact_percent",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_REVISION,
     g_param_spec_int64 ("revision",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
schema_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SchemaClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) schema_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Schema),
      0, /* n_preallocs */
      (GInstanceInitFunc) schema_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SchemaType",
                                   &type_info, 0);
  }

  return type;
}

enum _UCellProperties
{
  PROP_U_CELL_0,
  PROP_U_CELL_F,
  PROP_U_CELL_K,
  PROP_U_CELL_TS,
  PROP_U_CELL_V
};

/* reads a u_cell object */
static gint32
u_cell_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UCell * this_object = U_CELL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast2;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->f = (Flag)ecast2;
          this_object->__isset_f = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem3 = NULL;
              if (_elem3 != NULL)
              {
                g_free(_elem3);
                _elem3 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem3 = g_byte_array_new();
              g_byte_array_append (_elem3, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->k, _elem3);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_k = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->v != NULL)
          {
            g_free(this_object->v);
            this_object->v = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->v = g_byte_array_new();
          g_byte_array_append (this_object->v, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
u_cell_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UCell * this_object = U_CELL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UCell", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "f", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->f, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "k", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i4;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->k ? this_object->k->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i4 = 0; i4 < (this_object->k ? this_object->k->len : 0); i4++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i4)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i4)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i4)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i4)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ts == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_v == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->v ? ((GByteArray *) this_object->v)->data : NULL, this_object->v ? ((GByteArray *) this_object->v)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
u_cell_set_property (GObject *object,
                     guint property_id,
                     const GValue *value,
                     GParamSpec *pspec)
{
  UCell *self = U_CELL (object);

  switch (property_id)
  {
    case PROP_U_CELL_F:
      self->f = g_value_get_int (value);
      self->__isset_f = TRUE;
      break;

    case PROP_U_CELL_K:
      if (self->k != NULL)
        g_ptr_array_unref (self->k);
      self->k = g_value_dup_boxed (value);
      self->__isset_k = TRUE;
      break;

    case PROP_U_CELL_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_U_CELL_V:
      if (self->v != NULL)
        g_byte_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
u_cell_get_property (GObject *object,
                     guint property_id,
                     GValue *value,
                     GParamSpec *pspec)
{
  UCell *self = U_CELL (object);

  switch (property_id)
  {
    case PROP_U_CELL_F:
      g_value_set_int (value, self->f);
      break;

    case PROP_U_CELL_K:
      g_value_set_boxed (value, self->k);
      break;

    case PROP_U_CELL_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_U_CELL_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
u_cell_instance_init (UCell * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_f = FALSE;
  object->k = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_k = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = NULL;
  object->__isset_v = FALSE;
}

static void 
u_cell_finalize (GObject *object)
{
  UCell *tobject = U_CELL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->k != NULL)
  {
    g_ptr_array_unref (tobject->k);
    tobject->k = NULL;
  }
  if (tobject->v != NULL)
  {
    thrift_string_free(tobject->v);
    tobject->v = NULL;
  }
}

static void
u_cell_class_init (UCellClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = u_cell_read;
  struct_class->write = u_cell_write;

  gobject_class->finalize = u_cell_finalize;
  gobject_class->get_property = u_cell_get_property;
  gobject_class->set_property = u_cell_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_U_CELL_F,
     g_param_spec_int ("f",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_CELL_K,
     g_param_spec_boxed ("k",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_CELL_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_U_CELL_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
u_cell_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UCellClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) u_cell_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UCell),
      0, /* n_preallocs */
      (GInstanceInitFunc) u_cell_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UCellType",
                                   &type_info, 0);
  }

  return type;
}

enum _CellProperties
{
  PROP_CELL_0,
  PROP_CELL_C,
  PROP_CELL_K,
  PROP_CELL_TS,
  PROP_CELL_V
};

/* reads a cell object */
static gint32
cell_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Cell * this_object = CELL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->c != NULL)
          {
            g_free(this_object->c);
            this_object->c = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->c, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_c = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem5 = NULL;
              if (_elem5 != NULL)
              {
                g_free(_elem5);
                _elem5 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem5 = g_byte_array_new();
              g_byte_array_append (_elem5, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->k, _elem5);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_k = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->v != NULL)
          {
            g_free(this_object->v);
            this_object->v = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->v = g_byte_array_new();
          g_byte_array_append (this_object->v, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
cell_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Cell * this_object = CELL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Cell", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "c", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->c, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "k", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i6;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->k ? this_object->k->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i6 = 0; i6 < (this_object->k ? this_object->k->len : 0); i6++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i6)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i6)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i6)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i6)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_v == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->v ? ((GByteArray *) this_object->v)->data : NULL, this_object->v ? ((GByteArray *) this_object->v)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
cell_set_property (GObject *object,
                   guint property_id,
                   const GValue *value,
                   GParamSpec *pspec)
{
  Cell *self = CELL (object);

  switch (property_id)
  {
    case PROP_CELL_C:
      if (self->c != NULL)
        g_free (self->c);
      self->c = g_value_dup_string (value);
      self->__isset_c = TRUE;
      break;

    case PROP_CELL_K:
      if (self->k != NULL)
        g_ptr_array_unref (self->k);
      self->k = g_value_dup_boxed (value);
      self->__isset_k = TRUE;
      break;

    case PROP_CELL_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_CELL_V:
      if (self->v != NULL)
        g_byte_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
cell_get_property (GObject *object,
                   guint property_id,
                   GValue *value,
                   GParamSpec *pspec)
{
  Cell *self = CELL (object);

  switch (property_id)
  {
    case PROP_CELL_C:
      g_value_set_string (value, self->c);
      break;

    case PROP_CELL_K:
      g_value_set_boxed (value, self->k);
      break;

    case PROP_CELL_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_CELL_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
cell_instance_init (Cell * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->c = NULL;
  object->__isset_c = FALSE;
  object->k = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_k = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = NULL;
  object->__isset_v = FALSE;
}

static void 
cell_finalize (GObject *object)
{
  Cell *tobject = CELL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->c != NULL)
  {
    g_free(tobject->c);
    tobject->c = NULL;
  }
  if (tobject->k != NULL)
  {
    g_ptr_array_unref (tobject->k);
    tobject->k = NULL;
  }
  if (tobject->v != NULL)
  {
    thrift_string_free(tobject->v);
    tobject->v = NULL;
  }
}

static void
cell_class_init (CellClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = cell_read;
  struct_class->write = cell_write;

  gobject_class->finalize = cell_finalize;
  gobject_class->get_property = cell_get_property;
  gobject_class->set_property = cell_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CELL_C,
     g_param_spec_string ("c",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CELL_K,
     g_param_spec_boxed ("k",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CELL_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CELL_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
cell_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CellClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) cell_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Cell),
      0, /* n_preallocs */
      (GInstanceInitFunc) cell_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CellType",
                                   &type_info, 0);
  }

  return type;
}

enum _CCellProperties
{
  PROP_C_CELL_0,
  PROP_C_CELL_K,
  PROP_C_CELL_TS,
  PROP_C_CELL_V
};

/* reads a c_cell object */
static gint32
c_cell_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CCell * this_object = C_CELL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem7 = NULL;
              if (_elem7 != NULL)
              {
                g_free(_elem7);
                _elem7 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem7 = g_byte_array_new();
              g_byte_array_append (_elem7, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->k, _elem7);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_k = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->v != NULL)
          {
            g_free(this_object->v);
            this_object->v = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->v = g_byte_array_new();
          g_byte_array_append (this_object->v, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
c_cell_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CCell * this_object = C_CELL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CCell", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "k", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i8;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->k ? this_object->k->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i8 = 0; i8 < (this_object->k ? this_object->k->len : 0); i8++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i8)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i8)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i8)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i8)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_v == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->v ? ((GByteArray *) this_object->v)->data : NULL, this_object->v ? ((GByteArray *) this_object->v)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
c_cell_set_property (GObject *object,
                     guint property_id,
                     const GValue *value,
                     GParamSpec *pspec)
{
  CCell *self = C_CELL (object);

  switch (property_id)
  {
    case PROP_C_CELL_K:
      if (self->k != NULL)
        g_ptr_array_unref (self->k);
      self->k = g_value_dup_boxed (value);
      self->__isset_k = TRUE;
      break;

    case PROP_C_CELL_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_C_CELL_V:
      if (self->v != NULL)
        g_byte_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
c_cell_get_property (GObject *object,
                     guint property_id,
                     GValue *value,
                     GParamSpec *pspec)
{
  CCell *self = C_CELL (object);

  switch (property_id)
  {
    case PROP_C_CELL_K:
      g_value_set_boxed (value, self->k);
      break;

    case PROP_C_CELL_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_C_CELL_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
c_cell_instance_init (CCell * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->k = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_k = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = NULL;
  object->__isset_v = FALSE;
}

static void 
c_cell_finalize (GObject *object)
{
  CCell *tobject = C_CELL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->k != NULL)
  {
    g_ptr_array_unref (tobject->k);
    tobject->k = NULL;
  }
  if (tobject->v != NULL)
  {
    thrift_string_free(tobject->v);
    tobject->v = NULL;
  }
}

static void
c_cell_class_init (CCellClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = c_cell_read;
  struct_class->write = c_cell_write;

  gobject_class->finalize = c_cell_finalize;
  gobject_class->get_property = c_cell_get_property;
  gobject_class->set_property = c_cell_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_C_CELL_K,
     g_param_spec_boxed ("k",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_C_CELL_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_C_CELL_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
c_cell_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CCellClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) c_cell_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CCell),
      0, /* n_preallocs */
      (GInstanceInitFunc) c_cell_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CCellType",
                                   &type_info, 0);
  }

  return type;
}

enum _KCellProperties
{
  PROP_K_CELL_0,
  PROP_K_CELL_C,
  PROP_K_CELL_TS,
  PROP_K_CELL_V
};

/* reads a k_cell object */
static gint32
k_cell_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  KCell * this_object = K_CELL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->c != NULL)
          {
            g_free(this_object->c);
            this_object->c = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->c, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_c = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->v != NULL)
          {
            g_free(this_object->v);
            this_object->v = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->v = g_byte_array_new();
          g_byte_array_append (this_object->v, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
k_cell_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  KCell * this_object = K_CELL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "KCell", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "c", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->c, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_v == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->v ? ((GByteArray *) this_object->v)->data : NULL, this_object->v ? ((GByteArray *) this_object->v)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
k_cell_set_property (GObject *object,
                     guint property_id,
                     const GValue *value,
                     GParamSpec *pspec)
{
  KCell *self = K_CELL (object);

  switch (property_id)
  {
    case PROP_K_CELL_C:
      if (self->c != NULL)
        g_free (self->c);
      self->c = g_value_dup_string (value);
      self->__isset_c = TRUE;
      break;

    case PROP_K_CELL_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_K_CELL_V:
      if (self->v != NULL)
        g_byte_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
k_cell_get_property (GObject *object,
                     guint property_id,
                     GValue *value,
                     GParamSpec *pspec)
{
  KCell *self = K_CELL (object);

  switch (property_id)
  {
    case PROP_K_CELL_C:
      g_value_set_string (value, self->c);
      break;

    case PROP_K_CELL_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_K_CELL_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
k_cell_instance_init (KCell * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->c = NULL;
  object->__isset_c = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = NULL;
  object->__isset_v = FALSE;
}

static void 
k_cell_finalize (GObject *object)
{
  KCell *tobject = K_CELL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->c != NULL)
  {
    g_free(tobject->c);
    tobject->c = NULL;
  }
  if (tobject->v != NULL)
  {
    thrift_string_free(tobject->v);
    tobject->v = NULL;
  }
}

static void
k_cell_class_init (KCellClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = k_cell_read;
  struct_class->write = k_cell_write;

  gobject_class->finalize = k_cell_finalize;
  gobject_class->get_property = k_cell_get_property;
  gobject_class->set_property = k_cell_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_K_CELL_C,
     g_param_spec_string ("c",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_K_CELL_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_K_CELL_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
k_cell_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (KCellClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) k_cell_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (KCell),
      0, /* n_preallocs */
      (GInstanceInitFunc) k_cell_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "KCellType",
                                   &type_info, 0);
  }

  return type;
}

enum _kCellsProperties
{
  PROP_K_CELLS_0,
  PROP_K_CELLS_K,
  PROP_K_CELLS_CELLS
};

/* reads a k_cells object */
static gint32
k_cells_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  kCells * this_object = K_CELLS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem9 = NULL;
              if (_elem9 != NULL)
              {
                g_free(_elem9);
                _elem9 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem9 = g_byte_array_new();
              g_byte_array_append (_elem9, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->k, _elem9);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_k = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              KCell * _elem10 = NULL;
              if ( _elem10 != NULL)
              {
                g_object_unref (_elem10);
              }
              _elem10 = g_object_new (TYPE_K_CELL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem10), protocol, error)) < 0)
              {
                g_object_unref (_elem10);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->cells, _elem10);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
k_cells_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  kCells * this_object = K_CELLS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "kCells", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "k", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i11;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->k ? this_object->k->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i11 = 0; i11 < (this_object->k ? this_object->k->len : 0); i11++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i11)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i11)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i11)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i11)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cells", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i12;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->cells ? this_object->cells->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i12 = 0; i12 < (this_object->cells ? this_object->cells->len : 0); i12++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->cells, i12))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
k_cells_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  kCells *self = K_CELLS (object);

  switch (property_id)
  {
    case PROP_K_CELLS_K:
      if (self->k != NULL)
        g_ptr_array_unref (self->k);
      self->k = g_value_dup_boxed (value);
      self->__isset_k = TRUE;
      break;

    case PROP_K_CELLS_CELLS:
      if (self->cells != NULL)
        g_ptr_array_unref (self->cells);
      self->cells = g_value_dup_boxed (value);
      self->__isset_cells = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
k_cells_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  kCells *self = K_CELLS (object);

  switch (property_id)
  {
    case PROP_K_CELLS_K:
      g_value_set_boxed (value, self->k);
      break;

    case PROP_K_CELLS_CELLS:
      g_value_set_boxed (value, self->cells);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
k_cells_instance_init (kCells * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->k = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_k = FALSE;
  object->cells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_cells = FALSE;
}

static void 
k_cells_finalize (GObject *object)
{
  kCells *tobject = K_CELLS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->k != NULL)
  {
    g_ptr_array_unref (tobject->k);
    tobject->k = NULL;
  }
  if (tobject->cells != NULL)
  {
    g_ptr_array_unref (tobject->cells);
    tobject->cells = NULL;
  }
}

static void
k_cells_class_init (kCellsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = k_cells_read;
  struct_class->write = k_cells_write;

  gobject_class->finalize = k_cells_finalize;
  gobject_class->get_property = k_cells_get_property;
  gobject_class->set_property = k_cells_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_K_CELLS_K,
     g_param_spec_boxed ("k",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_K_CELLS_CELLS,
     g_param_spec_boxed ("cells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
k_cells_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (kCellsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) k_cells_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (kCells),
      0, /* n_preallocs */
      (GInstanceInitFunc) k_cells_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "kCellsType",
                                   &type_info, 0);
  }

  return type;
}

enum _FCellProperties
{
  PROP_F_CELL_0,
  PROP_F_CELL_C,
  PROP_F_CELL_TS,
  PROP_F_CELL_V
};

/* reads a f_cell object */
static gint32
f_cell_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  FCell * this_object = F_CELL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->c != NULL)
          {
            g_free(this_object->c);
            this_object->c = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->c, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_c = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->v != NULL)
          {
            g_free(this_object->v);
            this_object->v = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->v = g_byte_array_new();
          g_byte_array_append (this_object->v, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
f_cell_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  FCell * this_object = F_CELL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FCell", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "c", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->c, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_v == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->v ? ((GByteArray *) this_object->v)->data : NULL, this_object->v ? ((GByteArray *) this_object->v)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
f_cell_set_property (GObject *object,
                     guint property_id,
                     const GValue *value,
                     GParamSpec *pspec)
{
  FCell *self = F_CELL (object);

  switch (property_id)
  {
    case PROP_F_CELL_C:
      if (self->c != NULL)
        g_free (self->c);
      self->c = g_value_dup_string (value);
      self->__isset_c = TRUE;
      break;

    case PROP_F_CELL_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_F_CELL_V:
      if (self->v != NULL)
        g_byte_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
f_cell_get_property (GObject *object,
                     guint property_id,
                     GValue *value,
                     GParamSpec *pspec)
{
  FCell *self = F_CELL (object);

  switch (property_id)
  {
    case PROP_F_CELL_C:
      g_value_set_string (value, self->c);
      break;

    case PROP_F_CELL_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_F_CELL_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
f_cell_instance_init (FCell * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->c = NULL;
  object->__isset_c = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = NULL;
  object->__isset_v = FALSE;
}

static void 
f_cell_finalize (GObject *object)
{
  FCell *tobject = F_CELL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->c != NULL)
  {
    g_free(tobject->c);
    tobject->c = NULL;
  }
  if (tobject->v != NULL)
  {
    thrift_string_free(tobject->v);
    tobject->v = NULL;
  }
}

static void
f_cell_class_init (FCellClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = f_cell_read;
  struct_class->write = f_cell_write;

  gobject_class->finalize = f_cell_finalize;
  gobject_class->get_property = f_cell_get_property;
  gobject_class->set_property = f_cell_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_F_CELL_C,
     g_param_spec_string ("c",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_F_CELL_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_F_CELL_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
f_cell_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (FCellClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) f_cell_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (FCell),
      0, /* n_preallocs */
      (GInstanceInitFunc) f_cell_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "FCellType",
                                   &type_info, 0);
  }

  return type;
}

enum _FCellsProperties
{
  PROP_F_CELLS_0,
  PROP_F_CELLS_F,
  PROP_F_CELLS_CELLS
};

/* reads a f_cells object */
static gint32
f_cells_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  FCells * this_object = F_CELLS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GByteArray * key13 = NULL;
              FCells * val14 = NULL;
              if (key13 != NULL)
              {
                g_free(key13);
                key13 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key13 = g_byte_array_new();
              g_byte_array_append (key13, (guint8 *) data, (guint) len);
              g_free (data);
              if ( val14 != NULL)
              {
                g_object_unref (val14);
              }
              val14 = g_object_new (TYPE_F_CELLS, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val14), protocol, error)) < 0)
              {
                g_object_unref (val14);
                return -1;
              }
              xfer += ret;
              if (this_object->f && key13)
                g_hash_table_insert ((GHashTable *)this_object->f, (gpointer) key13, (gpointer) val14);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_f = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              FCell * _elem15 = NULL;
              if ( _elem15 != NULL)
              {
                g_object_unref (_elem15);
              }
              _elem15 = g_object_new (TYPE_F_CELL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem15), protocol, error)) < 0)
              {
                g_object_unref (_elem15);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->cells, _elem15);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
f_cells_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  FCells * this_object = F_CELLS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FCells", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "f", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    GByteArray * key16 = NULL;
    FCells * val17 = NULL;
    GList *key_list = NULL, *iter = NULL;
    GByteArray ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, this_object->f ? (gint32) g_hash_table_size ((GHashTable *) this_object->f) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->f)
      g_hash_table_foreach ((GHashTable *) this_object->f, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (GByteArray *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (GByteArray *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key16 = keys[i];
      val17 = (FCells *) g_hash_table_lookup (((GHashTable *) this_object->f), (gpointer) key16);

      if ((ret = thrift_protocol_write_binary (protocol,  key16 ? ((GByteArray *)  key16)->data : NULL,  key16 ? ((GByteArray *)  key16)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_struct_write (THRIFT_STRUCT ( val17), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_cells == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cells", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i18;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->cells ? this_object->cells->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i18 = 0; i18 < (this_object->cells ? this_object->cells->len : 0); i18++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->cells, i18))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
f_cells_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  FCells *self = F_CELLS (object);

  switch (property_id)
  {
    case PROP_F_CELLS_F:
      if (self->f != NULL)
        g_hash_table_unref (self->f);
      self->f = g_value_dup_boxed (value);
      self->__isset_f = TRUE;
      break;

    case PROP_F_CELLS_CELLS:
      if (self->cells != NULL)
        g_ptr_array_unref (self->cells);
      self->cells = g_value_dup_boxed (value);
      self->__isset_cells = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
f_cells_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  FCells *self = F_CELLS (object);

  switch (property_id)
  {
    case PROP_F_CELLS_F:
      g_value_set_boxed (value, self->f);
      break;

    case PROP_F_CELLS_CELLS:
      g_value_set_boxed (value, self->cells);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
f_cells_instance_init (FCells * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->f = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, g_object_unref);
  object->__isset_f = FALSE;
  object->cells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_cells = FALSE;
}

static void 
f_cells_finalize (GObject *object)
{
  FCells *tobject = F_CELLS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->f != NULL)
  {
    g_hash_table_destroy (tobject->f);
    tobject->f = NULL;
  }
  if (tobject->cells != NULL)
  {
    g_ptr_array_unref (tobject->cells);
    tobject->cells = NULL;
  }
}

static void
f_cells_class_init (FCellsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = f_cells_read;
  struct_class->write = f_cells_write;

  gobject_class->finalize = f_cells_finalize;
  gobject_class->get_property = f_cells_get_property;
  gobject_class->set_property = f_cells_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_F_CELLS_F,
     g_param_spec_boxed ("f",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_F_CELLS_CELLS,
     g_param_spec_boxed ("cells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
f_cells_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (FCellsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) f_cells_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (FCells),
      0, /* n_preallocs */
      (GInstanceInitFunc) f_cells_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "FCellsType",
                                   &type_info, 0);
  }

  return type;
}

enum _CellsGroupProperties
{
  PROP_CELLS_GROUP_0,
  PROP_CELLS_GROUP_CELLS,
  PROP_CELLS_GROUP_CCELLS,
  PROP_CELLS_GROUP_KCELLS,
  PROP_CELLS_GROUP_FCELLS
};

/* reads a cells_group object */
static gint32
cells_group_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CellsGroup * this_object = CELLS_GROUP(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Cell * _elem19 = NULL;
              if ( _elem19 != NULL)
              {
                g_object_unref (_elem19);
              }
              _elem19 = g_object_new (TYPE_CELL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem19), protocol, error)) < 0)
              {
                g_object_unref (_elem19);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->cells, _elem19);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key20 = NULL;
              ColCells * val21 = g_ptr_array_new_with_free_func (g_object_unref);
              if (key20 != NULL)
              {
                g_free(key20);
                key20 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key20, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  CCell * _elem22 = NULL;
                  if ( _elem22 != NULL)
                  {
                    g_object_unref (_elem22);
                  }
                  _elem22 = g_object_new (TYPE_C_CELL, NULL);
                  if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem22), protocol, error)) < 0)
                  {
                    g_object_unref (_elem22);
                    return -1;
                  }
                  xfer += ret;
                  g_ptr_array_add (val21, _elem22);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              if (this_object->ccells && key20)
                g_hash_table_insert ((GHashTable *)this_object->ccells, (gpointer) key20, (gpointer) val21);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_ccells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              kCells * _elem23 = NULL;
              if ( _elem23 != NULL)
              {
                g_object_unref (_elem23);
              }
              _elem23 = g_object_new (TYPE_K_CELLS, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem23), protocol, error)) < 0)
              {
                g_object_unref (_elem23);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->kcells, _elem23);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_kcells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->fcells), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_fcells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
cells_group_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CellsGroup * this_object = CELLS_GROUP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CellsGroup", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_cells == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cells", T_LIST, 1, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i24;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->cells ? this_object->cells->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i24 = 0; i24 < (this_object->cells ? this_object->cells->len : 0); i24++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->cells, i24))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ccells == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ccells", T_MAP, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key25 = NULL;
      ColCells * val26 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_LIST, this_object->ccells ? (gint32) g_hash_table_size ((GHashTable *) this_object->ccells) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->ccells)
        g_hash_table_foreach ((GHashTable *) this_object->ccells, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key25 = keys[i];
        val26 = (ColCells *) g_hash_table_lookup (((GHashTable *) this_object->ccells), (gpointer) key25);

        if ((ret = thrift_protocol_write_string (protocol,  key25, error)) < 0)
          return -1;
        xfer += ret;

        {
          guint i27;

          if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) ( val26 ?  val26->len : 0), error)) < 0)
            return -1;
          xfer += ret;
          for (i27 = 0; i27 < ( val26 ?  val26->len : 0); i27++)
          {
            if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *)  val26, i27))), protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
            return -1;
          xfer += ret;
        }
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_kcells == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "kcells", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i28;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->kcells ? this_object->kcells->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i28 = 0; i28 < (this_object->kcells ? this_object->kcells->len : 0); i28++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->kcells, i28))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_fcells == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "fcells", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->fcells), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
cells_group_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  CellsGroup *self = CELLS_GROUP (object);

  switch (property_id)
  {
    case PROP_CELLS_GROUP_CELLS:
      if (self->cells != NULL)
        g_ptr_array_unref (self->cells);
      self->cells = g_value_dup_boxed (value);
      self->__isset_cells = TRUE;
      break;

    case PROP_CELLS_GROUP_CCELLS:
      if (self->ccells != NULL)
        g_hash_table_unref (self->ccells);
      self->ccells = g_value_dup_boxed (value);
      self->__isset_ccells = TRUE;
      break;

    case PROP_CELLS_GROUP_KCELLS:
      if (self->kcells != NULL)
        g_ptr_array_unref (self->kcells);
      self->kcells = g_value_dup_boxed (value);
      self->__isset_kcells = TRUE;
      break;

    case PROP_CELLS_GROUP_FCELLS:
      if (self->fcells != NULL)
        g_object_unref (self->fcells);
      self->fcells = g_value_dup_object (value);
      self->__isset_fcells = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
cells_group_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  CellsGroup *self = CELLS_GROUP (object);

  switch (property_id)
  {
    case PROP_CELLS_GROUP_CELLS:
      g_value_set_boxed (value, self->cells);
      break;

    case PROP_CELLS_GROUP_CCELLS:
      g_value_set_boxed (value, self->ccells);
      break;

    case PROP_CELLS_GROUP_KCELLS:
      g_value_set_boxed (value, self->kcells);
      break;

    case PROP_CELLS_GROUP_FCELLS:
      g_value_set_object (value, self->fcells);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
cells_group_instance_init (CellsGroup * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_cells = FALSE;
  object->ccells = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify) g_ptr_array_unref);
  object->__isset_ccells = FALSE;
  object->kcells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_kcells = FALSE;
  object->fcells = g_object_new (TYPE_F_CELLS, NULL);
  object->__isset_fcells = FALSE;
}

static void 
cells_group_finalize (GObject *object)
{
  CellsGroup *tobject = CELLS_GROUP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->cells != NULL)
  {
    g_ptr_array_unref (tobject->cells);
    tobject->cells = NULL;
  }
  if (tobject->ccells != NULL)
  {
    g_hash_table_destroy (tobject->ccells);
    tobject->ccells = NULL;
  }
  if (tobject->kcells != NULL)
  {
    g_ptr_array_unref (tobject->kcells);
    tobject->kcells = NULL;
  }
  if (tobject->fcells != NULL)
  {
    g_object_unref(tobject->fcells);
    tobject->fcells = NULL;
  }
}

static void
cells_group_class_init (CellsGroupClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = cells_group_read;
  struct_class->write = cells_group_write;

  gobject_class->finalize = cells_group_finalize;
  gobject_class->get_property = cells_group_get_property;
  gobject_class->set_property = cells_group_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_CELLS_GROUP_CELLS,
     g_param_spec_boxed ("cells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CELLS_GROUP_CCELLS,
     g_param_spec_boxed ("ccells",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CELLS_GROUP_KCELLS,
     g_param_spec_boxed ("kcells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_CELLS_GROUP_FCELLS,
     g_param_spec_object ("fcells",
                         NULL,
                         NULL,
                         TYPE_F_CELLS,
                         G_PARAM_READWRITE));
}

GType
cells_group_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CellsGroupClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) cells_group_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CellsGroup),
      0, /* n_preallocs */
      (GInstanceInitFunc) cells_group_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CellsGroupType",
                                   &type_info, 0);
  }

  return type;
}

enum _CompactResultProperties
{
  PROP_COMPACT_RESULT_0,
  PROP_COMPACT_RESULT_CID,
  PROP_COMPACT_RESULT_ERR
};

/* reads a compact_result object */
static gint32
compact_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  CompactResult * this_object = COMPACT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->cid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->err, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_err = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
compact_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  CompactResult * this_object = COMPACT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CompactResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cid", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->cid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "err", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->err, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
compact_result_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  CompactResult *self = COMPACT_RESULT (object);

  switch (property_id)
  {
    case PROP_COMPACT_RESULT_CID:
      self->cid = g_value_get_int64 (value);
      self->__isset_cid = TRUE;
      break;

    case PROP_COMPACT_RESULT_ERR:
      self->err = g_value_get_int (value);
      self->__isset_err = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
compact_result_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  CompactResult *self = COMPACT_RESULT (object);

  switch (property_id)
  {
    case PROP_COMPACT_RESULT_CID:
      g_value_set_int64 (value, self->cid);
      break;

    case PROP_COMPACT_RESULT_ERR:
      g_value_set_int (value, self->err);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
compact_result_instance_init (CompactResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cid = 0;
  object->__isset_cid = FALSE;
  object->err = 0;
  object->__isset_err = FALSE;
}

static void 
compact_result_finalize (GObject *object)
{
  CompactResult *tobject = COMPACT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
compact_result_class_init (CompactResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = compact_result_read;
  struct_class->write = compact_result_write;

  gobject_class->finalize = compact_result_finalize;
  gobject_class->get_property = compact_result_get_property;
  gobject_class->set_property = compact_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_COMPACT_RESULT_CID,
     g_param_spec_int64 ("cid",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COMPACT_RESULT_ERR,
     g_param_spec_int ("err",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
compact_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (CompactResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) compact_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (CompactResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) compact_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "CompactResultType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _ServiceSqlMngColumnArgsProperties
{
  PROP_SERVICE_SQL_MNG_COLUMN_ARGS_0,
  PROP_SERVICE_SQL_MNG_COLUMN_ARGS_SQL
};

/* reads a service_sql_mng_column_args object */
static gint32
service_sql_mng_column_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlMngColumnArgs * this_object = SERVICE_SQL_MNG_COLUMN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_mng_column_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlMngColumnArgs * this_object = SERVICE_SQL_MNG_COLUMN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlMngColumnArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_mng_column_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  ServiceSqlMngColumnArgs *self = SERVICE_SQL_MNG_COLUMN_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_MNG_COLUMN_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_mng_column_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  ServiceSqlMngColumnArgs *self = SERVICE_SQL_MNG_COLUMN_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_MNG_COLUMN_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_mng_column_args_instance_init (ServiceSqlMngColumnArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
service_sql_mng_column_args_finalize (GObject *object)
{
  ServiceSqlMngColumnArgs *tobject = SERVICE_SQL_MNG_COLUMN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
service_sql_mng_column_args_class_init (ServiceSqlMngColumnArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_mng_column_args_read;
  struct_class->write = service_sql_mng_column_args_write;

  gobject_class->finalize = service_sql_mng_column_args_finalize;
  gobject_class->get_property = service_sql_mng_column_args_get_property;
  gobject_class->set_property = service_sql_mng_column_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_MNG_COLUMN_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
service_sql_mng_column_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlMngColumnArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_mng_column_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlMngColumnArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_mng_column_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlMngColumnArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlMngColumnResultProperties
{
  PROP_SERVICE_SQL_MNG_COLUMN_RESULT_0,
  PROP_SERVICE_SQL_MNG_COLUMN_RESULT_E
};

/* reads a service_sql_mng_column_result object */
static gint32
service_sql_mng_column_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlMngColumnResult * this_object = SERVICE_SQL_MNG_COLUMN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_mng_column_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlMngColumnResult * this_object = SERVICE_SQL_MNG_COLUMN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlMngColumnResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_mng_column_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  ServiceSqlMngColumnResult *self = SERVICE_SQL_MNG_COLUMN_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_MNG_COLUMN_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_mng_column_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  ServiceSqlMngColumnResult *self = SERVICE_SQL_MNG_COLUMN_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_MNG_COLUMN_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_mng_column_result_instance_init (ServiceSqlMngColumnResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
service_sql_mng_column_result_finalize (GObject *object)
{
  ServiceSqlMngColumnResult *tobject = SERVICE_SQL_MNG_COLUMN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
service_sql_mng_column_result_class_init (ServiceSqlMngColumnResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_mng_column_result_read;
  struct_class->write = service_sql_mng_column_result_write;

  gobject_class->finalize = service_sql_mng_column_result_finalize;
  gobject_class->get_property = service_sql_mng_column_result_get_property;
  gobject_class->set_property = service_sql_mng_column_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_MNG_COLUMN_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
service_sql_mng_column_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlMngColumnResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_mng_column_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlMngColumnResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_mng_column_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlMngColumnResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlListColumnsArgsProperties
{
  PROP_SERVICE_SQL_LIST_COLUMNS_ARGS_0,
  PROP_SERVICE_SQL_LIST_COLUMNS_ARGS_SQL
};

/* reads a service_sql_list_columns_args object */
static gint32
service_sql_list_columns_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlListColumnsArgs * this_object = SERVICE_SQL_LIST_COLUMNS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_list_columns_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlListColumnsArgs * this_object = SERVICE_SQL_LIST_COLUMNS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlListColumnsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_list_columns_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  ServiceSqlListColumnsArgs *self = SERVICE_SQL_LIST_COLUMNS_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_LIST_COLUMNS_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_list_columns_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  ServiceSqlListColumnsArgs *self = SERVICE_SQL_LIST_COLUMNS_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_LIST_COLUMNS_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_list_columns_args_instance_init (ServiceSqlListColumnsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
service_sql_list_columns_args_finalize (GObject *object)
{
  ServiceSqlListColumnsArgs *tobject = SERVICE_SQL_LIST_COLUMNS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
service_sql_list_columns_args_class_init (ServiceSqlListColumnsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_list_columns_args_read;
  struct_class->write = service_sql_list_columns_args_write;

  gobject_class->finalize = service_sql_list_columns_args_finalize;
  gobject_class->get_property = service_sql_list_columns_args_get_property;
  gobject_class->set_property = service_sql_list_columns_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_LIST_COLUMNS_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
service_sql_list_columns_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlListColumnsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_list_columns_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlListColumnsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_list_columns_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlListColumnsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlListColumnsResultProperties
{
  PROP_SERVICE_SQL_LIST_COLUMNS_RESULT_0,
  PROP_SERVICE_SQL_LIST_COLUMNS_RESULT_SUCCESS,
  PROP_SERVICE_SQL_LIST_COLUMNS_RESULT_E
};

/* reads a service_sql_list_columns_result object */
static gint32
service_sql_list_columns_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlListColumnsResult * this_object = SERVICE_SQL_LIST_COLUMNS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Schema * _elem29 = NULL;
              if ( _elem29 != NULL)
              {
                g_object_unref (_elem29);
              }
              _elem29 = g_object_new (TYPE_SCHEMA, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem29), protocol, error)) < 0)
              {
                g_object_unref (_elem29);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem29);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_list_columns_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlListColumnsResult * this_object = SERVICE_SQL_LIST_COLUMNS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlListColumnsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i30;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i30 = 0; i30 < (this_object->success ? this_object->success->len : 0); i30++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i30))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_list_columns_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  ServiceSqlListColumnsResult *self = SERVICE_SQL_LIST_COLUMNS_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_LIST_COLUMNS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SERVICE_SQL_LIST_COLUMNS_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_list_columns_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  ServiceSqlListColumnsResult *self = SERVICE_SQL_LIST_COLUMNS_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_LIST_COLUMNS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SERVICE_SQL_LIST_COLUMNS_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_list_columns_result_instance_init (ServiceSqlListColumnsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
service_sql_list_columns_result_finalize (GObject *object)
{
  ServiceSqlListColumnsResult *tobject = SERVICE_SQL_LIST_COLUMNS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
service_sql_list_columns_result_class_init (ServiceSqlListColumnsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_list_columns_result_read;
  struct_class->write = service_sql_list_columns_result_write;

  gobject_class->finalize = service_sql_list_columns_result_finalize;
  gobject_class->get_property = service_sql_list_columns_result_get_property;
  gobject_class->set_property = service_sql_list_columns_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_LIST_COLUMNS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_LIST_COLUMNS_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
service_sql_list_columns_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlListColumnsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_list_columns_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlListColumnsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_list_columns_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlListColumnsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlCompactColumnsArgsProperties
{
  PROP_SERVICE_SQL_COMPACT_COLUMNS_ARGS_0,
  PROP_SERVICE_SQL_COMPACT_COLUMNS_ARGS_SQL
};

/* reads a service_sql_compact_columns_args object */
static gint32
service_sql_compact_columns_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlCompactColumnsArgs * this_object = SERVICE_SQL_COMPACT_COLUMNS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_compact_columns_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlCompactColumnsArgs * this_object = SERVICE_SQL_COMPACT_COLUMNS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlCompactColumnsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_compact_columns_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  ServiceSqlCompactColumnsArgs *self = SERVICE_SQL_COMPACT_COLUMNS_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_COMPACT_COLUMNS_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_compact_columns_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  ServiceSqlCompactColumnsArgs *self = SERVICE_SQL_COMPACT_COLUMNS_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_COMPACT_COLUMNS_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_compact_columns_args_instance_init (ServiceSqlCompactColumnsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
service_sql_compact_columns_args_finalize (GObject *object)
{
  ServiceSqlCompactColumnsArgs *tobject = SERVICE_SQL_COMPACT_COLUMNS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
service_sql_compact_columns_args_class_init (ServiceSqlCompactColumnsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_compact_columns_args_read;
  struct_class->write = service_sql_compact_columns_args_write;

  gobject_class->finalize = service_sql_compact_columns_args_finalize;
  gobject_class->get_property = service_sql_compact_columns_args_get_property;
  gobject_class->set_property = service_sql_compact_columns_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_COMPACT_COLUMNS_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
service_sql_compact_columns_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlCompactColumnsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_compact_columns_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlCompactColumnsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_compact_columns_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlCompactColumnsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlCompactColumnsResultProperties
{
  PROP_SERVICE_SQL_COMPACT_COLUMNS_RESULT_0,
  PROP_SERVICE_SQL_COMPACT_COLUMNS_RESULT_SUCCESS,
  PROP_SERVICE_SQL_COMPACT_COLUMNS_RESULT_E
};

/* reads a service_sql_compact_columns_result object */
static gint32
service_sql_compact_columns_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlCompactColumnsResult * this_object = SERVICE_SQL_COMPACT_COLUMNS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              CompactResult * _elem31 = NULL;
              if ( _elem31 != NULL)
              {
                g_object_unref (_elem31);
              }
              _elem31 = g_object_new (TYPE_COMPACT_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem31), protocol, error)) < 0)
              {
                g_object_unref (_elem31);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem31);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_compact_columns_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlCompactColumnsResult * this_object = SERVICE_SQL_COMPACT_COLUMNS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlCompactColumnsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i32;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i32 = 0; i32 < (this_object->success ? this_object->success->len : 0); i32++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i32))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_compact_columns_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  ServiceSqlCompactColumnsResult *self = SERVICE_SQL_COMPACT_COLUMNS_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_COMPACT_COLUMNS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SERVICE_SQL_COMPACT_COLUMNS_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_compact_columns_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  ServiceSqlCompactColumnsResult *self = SERVICE_SQL_COMPACT_COLUMNS_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_COMPACT_COLUMNS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SERVICE_SQL_COMPACT_COLUMNS_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_compact_columns_result_instance_init (ServiceSqlCompactColumnsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
service_sql_compact_columns_result_finalize (GObject *object)
{
  ServiceSqlCompactColumnsResult *tobject = SERVICE_SQL_COMPACT_COLUMNS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
service_sql_compact_columns_result_class_init (ServiceSqlCompactColumnsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_compact_columns_result_read;
  struct_class->write = service_sql_compact_columns_result_write;

  gobject_class->finalize = service_sql_compact_columns_result_finalize;
  gobject_class->get_property = service_sql_compact_columns_result_get_property;
  gobject_class->set_property = service_sql_compact_columns_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_COMPACT_COLUMNS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_COMPACT_COLUMNS_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
service_sql_compact_columns_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlCompactColumnsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_compact_columns_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlCompactColumnsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_compact_columns_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlCompactColumnsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlSelectArgsProperties
{
  PROP_SERVICE_SQL_SELECT_ARGS_0,
  PROP_SERVICE_SQL_SELECT_ARGS_SQL
};

/* reads a service_sql_select_args object */
static gint32
service_sql_select_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlSelectArgs * this_object = SERVICE_SQL_SELECT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_select_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlSelectArgs * this_object = SERVICE_SQL_SELECT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_select_args_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  ServiceSqlSelectArgs *self = SERVICE_SQL_SELECT_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_SELECT_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_select_args_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  ServiceSqlSelectArgs *self = SERVICE_SQL_SELECT_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_SELECT_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_select_args_instance_init (ServiceSqlSelectArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
service_sql_select_args_finalize (GObject *object)
{
  ServiceSqlSelectArgs *tobject = SERVICE_SQL_SELECT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
service_sql_select_args_class_init (ServiceSqlSelectArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_select_args_read;
  struct_class->write = service_sql_select_args_write;

  gobject_class->finalize = service_sql_select_args_finalize;
  gobject_class->get_property = service_sql_select_args_get_property;
  gobject_class->set_property = service_sql_select_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_SELECT_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
service_sql_select_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlSelectArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_select_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlSelectArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_select_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlSelectArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlSelectResultProperties
{
  PROP_SERVICE_SQL_SELECT_RESULT_0,
  PROP_SERVICE_SQL_SELECT_RESULT_SUCCESS,
  PROP_SERVICE_SQL_SELECT_RESULT_E
};

/* reads a service_sql_select_result object */
static gint32
service_sql_select_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlSelectResult * this_object = SERVICE_SQL_SELECT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Cell * _elem33 = NULL;
              if ( _elem33 != NULL)
              {
                g_object_unref (_elem33);
              }
              _elem33 = g_object_new (TYPE_CELL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem33), protocol, error)) < 0)
              {
                g_object_unref (_elem33);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem33);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_select_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlSelectResult * this_object = SERVICE_SQL_SELECT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i34;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i34 = 0; i34 < (this_object->success ? this_object->success->len : 0); i34++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i34))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_select_result_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  ServiceSqlSelectResult *self = SERVICE_SQL_SELECT_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_SELECT_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SERVICE_SQL_SELECT_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_select_result_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  ServiceSqlSelectResult *self = SERVICE_SQL_SELECT_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_SELECT_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SERVICE_SQL_SELECT_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_select_result_instance_init (ServiceSqlSelectResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
service_sql_select_result_finalize (GObject *object)
{
  ServiceSqlSelectResult *tobject = SERVICE_SQL_SELECT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
service_sql_select_result_class_init (ServiceSqlSelectResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_select_result_read;
  struct_class->write = service_sql_select_result_write;

  gobject_class->finalize = service_sql_select_result_finalize;
  gobject_class->get_property = service_sql_select_result_get_property;
  gobject_class->set_property = service_sql_select_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_SELECT_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_SELECT_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
service_sql_select_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlSelectResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_select_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlSelectResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_select_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlSelectResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlSelectRsltOnColumnArgsProperties
{
  PROP_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS_0,
  PROP_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS_SQL
};

/* reads a service_sql_select_rslt_on_column_args object */
static gint32
service_sql_select_rslt_on_column_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlSelectRsltOnColumnArgs * this_object = SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_select_rslt_on_column_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlSelectRsltOnColumnArgs * this_object = SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectRsltOnColumnArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_select_rslt_on_column_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  ServiceSqlSelectRsltOnColumnArgs *self = SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_select_rslt_on_column_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  ServiceSqlSelectRsltOnColumnArgs *self = SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_select_rslt_on_column_args_instance_init (ServiceSqlSelectRsltOnColumnArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
service_sql_select_rslt_on_column_args_finalize (GObject *object)
{
  ServiceSqlSelectRsltOnColumnArgs *tobject = SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
service_sql_select_rslt_on_column_args_class_init (ServiceSqlSelectRsltOnColumnArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_select_rslt_on_column_args_read;
  struct_class->write = service_sql_select_rslt_on_column_args_write;

  gobject_class->finalize = service_sql_select_rslt_on_column_args_finalize;
  gobject_class->get_property = service_sql_select_rslt_on_column_args_get_property;
  gobject_class->set_property = service_sql_select_rslt_on_column_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
service_sql_select_rslt_on_column_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlSelectRsltOnColumnArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_select_rslt_on_column_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlSelectRsltOnColumnArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_select_rslt_on_column_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlSelectRsltOnColumnArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlSelectRsltOnColumnResultProperties
{
  PROP_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_0,
  PROP_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_SUCCESS,
  PROP_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_E
};

/* reads a service_sql_select_rslt_on_column_result object */
static gint32
service_sql_select_rslt_on_column_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlSelectRsltOnColumnResult * this_object = SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key35 = NULL;
              ColCells * val36 = g_ptr_array_new_with_free_func (g_object_unref);
              if (key35 != NULL)
              {
                g_free(key35);
                key35 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key35, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  CCell * _elem37 = NULL;
                  if ( _elem37 != NULL)
                  {
                    g_object_unref (_elem37);
                  }
                  _elem37 = g_object_new (TYPE_C_CELL, NULL);
                  if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem37), protocol, error)) < 0)
                  {
                    g_object_unref (_elem37);
                    return -1;
                  }
                  xfer += ret;
                  g_ptr_array_add (val36, _elem37);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              if (this_object->success && key35)
                g_hash_table_insert ((GHashTable *)this_object->success, (gpointer) key35, (gpointer) val36);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_select_rslt_on_column_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlSelectRsltOnColumnResult * this_object = SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectRsltOnColumnResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_MAP, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key38 = NULL;
      ColCells * val39 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_LIST, this_object->success ? (gint32) g_hash_table_size ((GHashTable *) this_object->success) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->success)
        g_hash_table_foreach ((GHashTable *) this_object->success, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key38 = keys[i];
        val39 = (ColCells *) g_hash_table_lookup (((GHashTable *) this_object->success), (gpointer) key38);

        if ((ret = thrift_protocol_write_string (protocol,  key38, error)) < 0)
          return -1;
        xfer += ret;

        {
          guint i40;

          if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) ( val39 ?  val39->len : 0), error)) < 0)
            return -1;
          xfer += ret;
          for (i40 = 0; i40 < ( val39 ?  val39->len : 0); i40++)
          {
            if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *)  val39, i40))), protocol, error)) < 0)
              return -1;
            xfer += ret;

          }
          if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
            return -1;
          xfer += ret;
        }
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_select_rslt_on_column_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  ServiceSqlSelectRsltOnColumnResult *self = SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_SUCCESS:
      if (self->success != NULL)
        g_hash_table_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_select_rslt_on_column_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  ServiceSqlSelectRsltOnColumnResult *self = SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_select_rslt_on_column_result_instance_init (ServiceSqlSelectRsltOnColumnResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify) g_ptr_array_unref);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
service_sql_select_rslt_on_column_result_finalize (GObject *object)
{
  ServiceSqlSelectRsltOnColumnResult *tobject = SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_hash_table_destroy (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
service_sql_select_rslt_on_column_result_class_init (ServiceSqlSelectRsltOnColumnResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_select_rslt_on_column_result_read;
  struct_class->write = service_sql_select_rslt_on_column_result_write;

  gobject_class->finalize = service_sql_select_rslt_on_column_result_finalize;
  gobject_class->get_property = service_sql_select_rslt_on_column_result_get_property;
  gobject_class->set_property = service_sql_select_rslt_on_column_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
service_sql_select_rslt_on_column_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlSelectRsltOnColumnResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_select_rslt_on_column_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlSelectRsltOnColumnResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_select_rslt_on_column_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlSelectRsltOnColumnResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlSelectRsltOnKeyArgsProperties
{
  PROP_SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS_0,
  PROP_SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS_SQL
};

/* reads a service_sql_select_rslt_on_key_args object */
static gint32
service_sql_select_rslt_on_key_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlSelectRsltOnKeyArgs * this_object = SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_select_rslt_on_key_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlSelectRsltOnKeyArgs * this_object = SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectRsltOnKeyArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_select_rslt_on_key_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  ServiceSqlSelectRsltOnKeyArgs *self = SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_select_rslt_on_key_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  ServiceSqlSelectRsltOnKeyArgs *self = SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_select_rslt_on_key_args_instance_init (ServiceSqlSelectRsltOnKeyArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
service_sql_select_rslt_on_key_args_finalize (GObject *object)
{
  ServiceSqlSelectRsltOnKeyArgs *tobject = SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
service_sql_select_rslt_on_key_args_class_init (ServiceSqlSelectRsltOnKeyArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_select_rslt_on_key_args_read;
  struct_class->write = service_sql_select_rslt_on_key_args_write;

  gobject_class->finalize = service_sql_select_rslt_on_key_args_finalize;
  gobject_class->get_property = service_sql_select_rslt_on_key_args_get_property;
  gobject_class->set_property = service_sql_select_rslt_on_key_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
service_sql_select_rslt_on_key_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlSelectRsltOnKeyArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_select_rslt_on_key_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlSelectRsltOnKeyArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_select_rslt_on_key_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlSelectRsltOnKeyArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlSelectRsltOnKeyResultProperties
{
  PROP_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_0,
  PROP_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_SUCCESS,
  PROP_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_E
};

/* reads a service_sql_select_rslt_on_key_result object */
static gint32
service_sql_select_rslt_on_key_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlSelectRsltOnKeyResult * this_object = SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              kCells * _elem41 = NULL;
              if ( _elem41 != NULL)
              {
                g_object_unref (_elem41);
              }
              _elem41 = g_object_new (TYPE_K_CELLS, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem41), protocol, error)) < 0)
              {
                g_object_unref (_elem41);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem41);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_select_rslt_on_key_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlSelectRsltOnKeyResult * this_object = SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectRsltOnKeyResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i42;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i42 = 0; i42 < (this_object->success ? this_object->success->len : 0); i42++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i42))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_select_rslt_on_key_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  ServiceSqlSelectRsltOnKeyResult *self = SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_select_rslt_on_key_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  ServiceSqlSelectRsltOnKeyResult *self = SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_select_rslt_on_key_result_instance_init (ServiceSqlSelectRsltOnKeyResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
service_sql_select_rslt_on_key_result_finalize (GObject *object)
{
  ServiceSqlSelectRsltOnKeyResult *tobject = SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
service_sql_select_rslt_on_key_result_class_init (ServiceSqlSelectRsltOnKeyResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_select_rslt_on_key_result_read;
  struct_class->write = service_sql_select_rslt_on_key_result_write;

  gobject_class->finalize = service_sql_select_rslt_on_key_result_finalize;
  gobject_class->get_property = service_sql_select_rslt_on_key_result_get_property;
  gobject_class->set_property = service_sql_select_rslt_on_key_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
service_sql_select_rslt_on_key_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlSelectRsltOnKeyResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_select_rslt_on_key_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlSelectRsltOnKeyResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_select_rslt_on_key_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlSelectRsltOnKeyResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlSelectRsltOnFractionArgsProperties
{
  PROP_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS_0,
  PROP_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS_SQL
};

/* reads a service_sql_select_rslt_on_fraction_args object */
static gint32
service_sql_select_rslt_on_fraction_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlSelectRsltOnFractionArgs * this_object = SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_select_rslt_on_fraction_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlSelectRsltOnFractionArgs * this_object = SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectRsltOnFractionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_select_rslt_on_fraction_args_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  ServiceSqlSelectRsltOnFractionArgs *self = SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_select_rslt_on_fraction_args_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  ServiceSqlSelectRsltOnFractionArgs *self = SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_select_rslt_on_fraction_args_instance_init (ServiceSqlSelectRsltOnFractionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
service_sql_select_rslt_on_fraction_args_finalize (GObject *object)
{
  ServiceSqlSelectRsltOnFractionArgs *tobject = SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
service_sql_select_rslt_on_fraction_args_class_init (ServiceSqlSelectRsltOnFractionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_select_rslt_on_fraction_args_read;
  struct_class->write = service_sql_select_rslt_on_fraction_args_write;

  gobject_class->finalize = service_sql_select_rslt_on_fraction_args_finalize;
  gobject_class->get_property = service_sql_select_rslt_on_fraction_args_get_property;
  gobject_class->set_property = service_sql_select_rslt_on_fraction_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
service_sql_select_rslt_on_fraction_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlSelectRsltOnFractionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_select_rslt_on_fraction_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlSelectRsltOnFractionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_select_rslt_on_fraction_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlSelectRsltOnFractionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlSelectRsltOnFractionResultProperties
{
  PROP_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_0,
  PROP_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_SUCCESS,
  PROP_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_E
};

/* reads a service_sql_select_rslt_on_fraction_result object */
static gint32
service_sql_select_rslt_on_fraction_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlSelectRsltOnFractionResult * this_object = SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_select_rslt_on_fraction_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlSelectRsltOnFractionResult * this_object = SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectRsltOnFractionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_select_rslt_on_fraction_result_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  ServiceSqlSelectRsltOnFractionResult *self = SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_select_rslt_on_fraction_result_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  ServiceSqlSelectRsltOnFractionResult *self = SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_select_rslt_on_fraction_result_instance_init (ServiceSqlSelectRsltOnFractionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_F_CELLS, NULL);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
service_sql_select_rslt_on_fraction_result_finalize (GObject *object)
{
  ServiceSqlSelectRsltOnFractionResult *tobject = SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
service_sql_select_rslt_on_fraction_result_class_init (ServiceSqlSelectRsltOnFractionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_select_rslt_on_fraction_result_read;
  struct_class->write = service_sql_select_rslt_on_fraction_result_write;

  gobject_class->finalize = service_sql_select_rslt_on_fraction_result_finalize;
  gobject_class->get_property = service_sql_select_rslt_on_fraction_result_get_property;
  gobject_class->set_property = service_sql_select_rslt_on_fraction_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_F_CELLS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
service_sql_select_rslt_on_fraction_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlSelectRsltOnFractionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_select_rslt_on_fraction_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlSelectRsltOnFractionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_select_rslt_on_fraction_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlSelectRsltOnFractionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlQueryArgsProperties
{
  PROP_SERVICE_SQL_QUERY_ARGS_0,
  PROP_SERVICE_SQL_QUERY_ARGS_SQL,
  PROP_SERVICE_SQL_QUERY_ARGS_RSLT
};

/* reads a service_sql_query_args object */
static gint32
service_sql_query_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlQueryArgs * this_object = SERVICE_SQL_QUERY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast43;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast43, error)) < 0)
            return -1;
          xfer += ret;
          this_object->rslt = (CellsResult)ecast43;
          this_object->__isset_rslt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_query_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlQueryArgs * this_object = SERVICE_SQL_QUERY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlQueryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rslt", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->rslt, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_query_args_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  ServiceSqlQueryArgs *self = SERVICE_SQL_QUERY_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_QUERY_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    case PROP_SERVICE_SQL_QUERY_ARGS_RSLT:
      self->rslt = g_value_get_int (value);
      self->__isset_rslt = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_query_args_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  ServiceSqlQueryArgs *self = SERVICE_SQL_QUERY_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_QUERY_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    case PROP_SERVICE_SQL_QUERY_ARGS_RSLT:
      g_value_set_int (value, self->rslt);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_query_args_instance_init (ServiceSqlQueryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
  object->__isset_rslt = FALSE;
}

static void 
service_sql_query_args_finalize (GObject *object)
{
  ServiceSqlQueryArgs *tobject = SERVICE_SQL_QUERY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
service_sql_query_args_class_init (ServiceSqlQueryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_query_args_read;
  struct_class->write = service_sql_query_args_write;

  gobject_class->finalize = service_sql_query_args_finalize;
  gobject_class->get_property = service_sql_query_args_get_property;
  gobject_class->set_property = service_sql_query_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_QUERY_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_QUERY_ARGS_RSLT,
     g_param_spec_int ("rslt",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));
}

GType
service_sql_query_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlQueryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_query_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlQueryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_query_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlQueryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlQueryResultProperties
{
  PROP_SERVICE_SQL_QUERY_RESULT_0,
  PROP_SERVICE_SQL_QUERY_RESULT_SUCCESS,
  PROP_SERVICE_SQL_QUERY_RESULT_E
};

/* reads a service_sql_query_result object */
static gint32
service_sql_query_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlQueryResult * this_object = SERVICE_SQL_QUERY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_query_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlQueryResult * this_object = SERVICE_SQL_QUERY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlQueryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_query_result_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  ServiceSqlQueryResult *self = SERVICE_SQL_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_QUERY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SERVICE_SQL_QUERY_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_query_result_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  ServiceSqlQueryResult *self = SERVICE_SQL_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_QUERY_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_SERVICE_SQL_QUERY_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_query_result_instance_init (ServiceSqlQueryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_CELLS_GROUP, NULL);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
service_sql_query_result_finalize (GObject *object)
{
  ServiceSqlQueryResult *tobject = SERVICE_SQL_QUERY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
service_sql_query_result_class_init (ServiceSqlQueryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_query_result_read;
  struct_class->write = service_sql_query_result_write;

  gobject_class->finalize = service_sql_query_result_finalize;
  gobject_class->get_property = service_sql_query_result_get_property;
  gobject_class->set_property = service_sql_query_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_QUERY_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_CELLS_GROUP,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_QUERY_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
service_sql_query_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlQueryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_query_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlQueryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_query_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlQueryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlUpdateArgsProperties
{
  PROP_SERVICE_SQL_UPDATE_ARGS_0,
  PROP_SERVICE_SQL_UPDATE_ARGS_SQL,
  PROP_SERVICE_SQL_UPDATE_ARGS_UPDATER_ID
};

/* reads a service_sql_update_args object */
static gint32
service_sql_update_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlUpdateArgs * this_object = SERVICE_SQL_UPDATE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->updater_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updater_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_update_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlUpdateArgs * this_object = SERVICE_SQL_UPDATE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlUpdateArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "updater_id", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->updater_id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_update_args_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  ServiceSqlUpdateArgs *self = SERVICE_SQL_UPDATE_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_UPDATE_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    case PROP_SERVICE_SQL_UPDATE_ARGS_UPDATER_ID:
      self->updater_id = g_value_get_int64 (value);
      self->__isset_updater_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_update_args_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  ServiceSqlUpdateArgs *self = SERVICE_SQL_UPDATE_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_UPDATE_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    case PROP_SERVICE_SQL_UPDATE_ARGS_UPDATER_ID:
      g_value_set_int64 (value, self->updater_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_update_args_instance_init (ServiceSqlUpdateArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
  object->updater_id = G_GINT64_CONSTANT (0);
  object->__isset_updater_id = FALSE;
}

static void 
service_sql_update_args_finalize (GObject *object)
{
  ServiceSqlUpdateArgs *tobject = SERVICE_SQL_UPDATE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
service_sql_update_args_class_init (ServiceSqlUpdateArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_update_args_read;
  struct_class->write = service_sql_update_args_write;

  gobject_class->finalize = service_sql_update_args_finalize;
  gobject_class->get_property = service_sql_update_args_get_property;
  gobject_class->set_property = service_sql_update_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_UPDATE_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_UPDATE_ARGS_UPDATER_ID,
     g_param_spec_int64 ("updater_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
service_sql_update_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlUpdateArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_update_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlUpdateArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_update_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlUpdateArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSqlUpdateResultProperties
{
  PROP_SERVICE_SQL_UPDATE_RESULT_0,
  PROP_SERVICE_SQL_UPDATE_RESULT_E
};

/* reads a service_sql_update_result object */
static gint32
service_sql_update_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSqlUpdateResult * this_object = SERVICE_SQL_UPDATE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_sql_update_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSqlUpdateResult * this_object = SERVICE_SQL_UPDATE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlUpdateResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_sql_update_result_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  ServiceSqlUpdateResult *self = SERVICE_SQL_UPDATE_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_UPDATE_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_sql_update_result_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  ServiceSqlUpdateResult *self = SERVICE_SQL_UPDATE_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_SQL_UPDATE_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_sql_update_result_instance_init (ServiceSqlUpdateResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
service_sql_update_result_finalize (GObject *object)
{
  ServiceSqlUpdateResult *tobject = SERVICE_SQL_UPDATE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
service_sql_update_result_class_init (ServiceSqlUpdateResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_sql_update_result_read;
  struct_class->write = service_sql_update_result_write;

  gobject_class->finalize = service_sql_update_result_finalize;
  gobject_class->get_property = service_sql_update_result_get_property;
  gobject_class->set_property = service_sql_update_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SQL_UPDATE_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
service_sql_update_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSqlUpdateResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_sql_update_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSqlUpdateResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_sql_update_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSqlUpdateResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceUpdaterCreateArgsProperties
{
  PROP_SERVICE_UPDATER_CREATE_ARGS_0,
  PROP_SERVICE_UPDATER_CREATE_ARGS_BUFFER_SIZE
};

/* reads a service_updater_create_args object */
static gint32
service_updater_create_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceUpdaterCreateArgs * this_object = SERVICE_UPDATER_CREATE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->buffer_size, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_buffer_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_updater_create_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceUpdaterCreateArgs * this_object = SERVICE_UPDATER_CREATE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdaterCreateArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "buffer_size", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->buffer_size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_updater_create_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  ServiceUpdaterCreateArgs *self = SERVICE_UPDATER_CREATE_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_UPDATER_CREATE_ARGS_BUFFER_SIZE:
      self->buffer_size = g_value_get_int (value);
      self->__isset_buffer_size = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_updater_create_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  ServiceUpdaterCreateArgs *self = SERVICE_UPDATER_CREATE_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_UPDATER_CREATE_ARGS_BUFFER_SIZE:
      g_value_set_int (value, self->buffer_size);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_updater_create_args_instance_init (ServiceUpdaterCreateArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->buffer_size = 0;
  object->__isset_buffer_size = FALSE;
}

static void 
service_updater_create_args_finalize (GObject *object)
{
  ServiceUpdaterCreateArgs *tobject = SERVICE_UPDATER_CREATE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
service_updater_create_args_class_init (ServiceUpdaterCreateArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_updater_create_args_read;
  struct_class->write = service_updater_create_args_write;

  gobject_class->finalize = service_updater_create_args_finalize;
  gobject_class->get_property = service_updater_create_args_get_property;
  gobject_class->set_property = service_updater_create_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_UPDATER_CREATE_ARGS_BUFFER_SIZE,
     g_param_spec_int ("buffer_size",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
service_updater_create_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceUpdaterCreateArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_updater_create_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceUpdaterCreateArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_updater_create_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceUpdaterCreateArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceUpdaterCreateResultProperties
{
  PROP_SERVICE_UPDATER_CREATE_RESULT_0,
  PROP_SERVICE_UPDATER_CREATE_RESULT_SUCCESS,
  PROP_SERVICE_UPDATER_CREATE_RESULT_E
};

/* reads a service_updater_create_result object */
static gint32
service_updater_create_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceUpdaterCreateResult * this_object = SERVICE_UPDATER_CREATE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_updater_create_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceUpdaterCreateResult * this_object = SERVICE_UPDATER_CREATE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdaterCreateResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_updater_create_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  ServiceUpdaterCreateResult *self = SERVICE_UPDATER_CREATE_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_UPDATER_CREATE_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SERVICE_UPDATER_CREATE_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_updater_create_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  ServiceUpdaterCreateResult *self = SERVICE_UPDATER_CREATE_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_UPDATER_CREATE_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    case PROP_SERVICE_UPDATER_CREATE_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_updater_create_result_instance_init (ServiceUpdaterCreateResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
service_updater_create_result_finalize (GObject *object)
{
  ServiceUpdaterCreateResult *tobject = SERVICE_UPDATER_CREATE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
service_updater_create_result_class_init (ServiceUpdaterCreateResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_updater_create_result_read;
  struct_class->write = service_updater_create_result_write;

  gobject_class->finalize = service_updater_create_result_finalize;
  gobject_class->get_property = service_updater_create_result_get_property;
  gobject_class->set_property = service_updater_create_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_UPDATER_CREATE_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_UPDATER_CREATE_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
service_updater_create_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceUpdaterCreateResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_updater_create_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceUpdaterCreateResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_updater_create_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceUpdaterCreateResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceUpdaterCloseArgsProperties
{
  PROP_SERVICE_UPDATER_CLOSE_ARGS_0,
  PROP_SERVICE_UPDATER_CLOSE_ARGS_ID
};

/* reads a service_updater_close_args object */
static gint32
service_updater_close_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceUpdaterCloseArgs * this_object = SERVICE_UPDATER_CLOSE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_updater_close_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceUpdaterCloseArgs * this_object = SERVICE_UPDATER_CLOSE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdaterCloseArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_updater_close_args_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  ServiceUpdaterCloseArgs *self = SERVICE_UPDATER_CLOSE_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_UPDATER_CLOSE_ARGS_ID:
      self->id = g_value_get_int64 (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_updater_close_args_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  ServiceUpdaterCloseArgs *self = SERVICE_UPDATER_CLOSE_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_UPDATER_CLOSE_ARGS_ID:
      g_value_set_int64 (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_updater_close_args_instance_init (ServiceUpdaterCloseArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = 0;
  object->__isset_id = FALSE;
}

static void 
service_updater_close_args_finalize (GObject *object)
{
  ServiceUpdaterCloseArgs *tobject = SERVICE_UPDATER_CLOSE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
service_updater_close_args_class_init (ServiceUpdaterCloseArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_updater_close_args_read;
  struct_class->write = service_updater_close_args_write;

  gobject_class->finalize = service_updater_close_args_finalize;
  gobject_class->get_property = service_updater_close_args_get_property;
  gobject_class->set_property = service_updater_close_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_UPDATER_CLOSE_ARGS_ID,
     g_param_spec_int64 ("id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
service_updater_close_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceUpdaterCloseArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_updater_close_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceUpdaterCloseArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_updater_close_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceUpdaterCloseArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceUpdaterCloseResultProperties
{
  PROP_SERVICE_UPDATER_CLOSE_RESULT_0,
  PROP_SERVICE_UPDATER_CLOSE_RESULT_E
};

/* reads a service_updater_close_result object */
static gint32
service_updater_close_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceUpdaterCloseResult * this_object = SERVICE_UPDATER_CLOSE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_updater_close_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceUpdaterCloseResult * this_object = SERVICE_UPDATER_CLOSE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdaterCloseResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_updater_close_result_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  ServiceUpdaterCloseResult *self = SERVICE_UPDATER_CLOSE_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_UPDATER_CLOSE_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_updater_close_result_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  ServiceUpdaterCloseResult *self = SERVICE_UPDATER_CLOSE_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_UPDATER_CLOSE_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_updater_close_result_instance_init (ServiceUpdaterCloseResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
service_updater_close_result_finalize (GObject *object)
{
  ServiceUpdaterCloseResult *tobject = SERVICE_UPDATER_CLOSE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
service_updater_close_result_class_init (ServiceUpdaterCloseResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_updater_close_result_read;
  struct_class->write = service_updater_close_result_write;

  gobject_class->finalize = service_updater_close_result_finalize;
  gobject_class->get_property = service_updater_close_result_get_property;
  gobject_class->set_property = service_updater_close_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_UPDATER_CLOSE_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
service_updater_close_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceUpdaterCloseResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_updater_close_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceUpdaterCloseResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_updater_close_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceUpdaterCloseResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceUpdateArgsProperties
{
  PROP_SERVICE_UPDATE_ARGS_0,
  PROP_SERVICE_UPDATE_ARGS_CELLS,
  PROP_SERVICE_UPDATE_ARGS_UPDATER_ID
};

/* reads a service_update_args object */
static gint32
service_update_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceUpdateArgs * this_object = SERVICE_UPDATE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint64* key44 = g_new (gint64, 1);
              UCells * val45 = g_ptr_array_new_with_free_func (g_object_unref);
              if ((ret = thrift_protocol_read_i64 (protocol, &*key44, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  UCell * _elem46 = NULL;
                  if ( _elem46 != NULL)
                  {
                    g_object_unref (_elem46);
                  }
                  _elem46 = g_object_new (TYPE_U_CELL, NULL);
                  if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem46), protocol, error)) < 0)
                  {
                    g_object_unref (_elem46);
                    return -1;
                  }
                  xfer += ret;
                  g_ptr_array_add (val45, _elem46);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              if (this_object->cells && key44)
                g_hash_table_insert ((GHashTable *)this_object->cells, (gpointer) key44, (gpointer) val45);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->updater_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updater_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_update_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceUpdateArgs * this_object = SERVICE_UPDATE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdateArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cells", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint64* key47 = NULL;
    UCells * val48 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gint64** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I64, T_LIST, this_object->cells ? (gint32) g_hash_table_size ((GHashTable *) this_object->cells) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->cells)
      g_hash_table_foreach ((GHashTable *) this_object->cells, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint64*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint64*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key47 = keys[i];
      val48 = (UCells *) g_hash_table_lookup (((GHashTable *) this_object->cells), (gpointer) key47);

      if ((ret = thrift_protocol_write_i64 (protocol, * key47, error)) < 0)
        return -1;
      xfer += ret;

      {
        guint i49;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) ( val48 ?  val48->len : 0), error)) < 0)
          return -1;
        xfer += ret;
        for (i49 = 0; i49 < ( val48 ?  val48->len : 0); i49++)
        {
          if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *)  val48, i49))), protocol, error)) < 0)
            return -1;
          xfer += ret;

        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "updater_id", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->updater_id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_update_args_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  ServiceUpdateArgs *self = SERVICE_UPDATE_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_UPDATE_ARGS_CELLS:
      if (self->cells != NULL)
        g_hash_table_unref (self->cells);
      self->cells = g_value_dup_boxed (value);
      self->__isset_cells = TRUE;
      break;

    case PROP_SERVICE_UPDATE_ARGS_UPDATER_ID:
      self->updater_id = g_value_get_int64 (value);
      self->__isset_updater_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_update_args_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  ServiceUpdateArgs *self = SERVICE_UPDATE_ARGS (object);

  switch (property_id)
  {
    case PROP_SERVICE_UPDATE_ARGS_CELLS:
      g_value_set_boxed (value, self->cells);
      break;

    case PROP_SERVICE_UPDATE_ARGS_UPDATER_ID:
      g_value_set_int64 (value, self->updater_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_update_args_instance_init (ServiceUpdateArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cells = g_hash_table_new_full (g_int64_hash, g_int64_equal, g_free, (GDestroyNotify) g_ptr_array_unref);
  object->__isset_cells = FALSE;
  object->updater_id = G_GINT64_CONSTANT (0);
  object->__isset_updater_id = FALSE;
}

static void 
service_update_args_finalize (GObject *object)
{
  ServiceUpdateArgs *tobject = SERVICE_UPDATE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->cells != NULL)
  {
    g_hash_table_destroy (tobject->cells);
    tobject->cells = NULL;
  }
}

static void
service_update_args_class_init (ServiceUpdateArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_update_args_read;
  struct_class->write = service_update_args_write;

  gobject_class->finalize = service_update_args_finalize;
  gobject_class->get_property = service_update_args_get_property;
  gobject_class->set_property = service_update_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_UPDATE_ARGS_CELLS,
     g_param_spec_boxed ("cells",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_UPDATE_ARGS_UPDATER_ID,
     g_param_spec_int64 ("updater_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
service_update_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceUpdateArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_update_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceUpdateArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_update_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceUpdateArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceUpdateResultProperties
{
  PROP_SERVICE_UPDATE_RESULT_0,
  PROP_SERVICE_UPDATE_RESULT_E
};

/* reads a service_update_result object */
static gint32
service_update_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceUpdateResult * this_object = SERVICE_UPDATE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_update_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceUpdateResult * this_object = SERVICE_UPDATE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdateResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_update_result_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  ServiceUpdateResult *self = SERVICE_UPDATE_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_UPDATE_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_update_result_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  ServiceUpdateResult *self = SERVICE_UPDATE_RESULT (object);

  switch (property_id)
  {
    case PROP_SERVICE_UPDATE_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_update_result_instance_init (ServiceUpdateResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
service_update_result_finalize (GObject *object)
{
  ServiceUpdateResult *tobject = SERVICE_UPDATE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
service_update_result_class_init (ServiceUpdateResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_update_result_read;
  struct_class->write = service_update_result_write;

  gobject_class->finalize = service_update_result_finalize;
  gobject_class->get_property = service_update_result_get_property;
  gobject_class->set_property = service_update_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_UPDATE_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
service_update_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceUpdateResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_update_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceUpdateResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_update_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceUpdateResultType",
                                   &type_info, 0);
  }

  return type;
}

