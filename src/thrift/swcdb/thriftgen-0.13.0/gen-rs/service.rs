// Autogenerated by Thrift Compiler (0.13.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments, type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate thrift;

use thrift::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

/// Column Key Sequences
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum KeySeq {
  /// Unknown/Unrecognized Type
  Unknown = 0,
  /// The Lexical Key Order Sequence
  Lexic = 1,
  /// The Volumetric Key Order Sequence
  Volume = 2,
  /// The by Fractions Count on Lexical Key Order Sequence
  FcLexic = 3,
  /// The by Fractions Count on Volumetric Key Order Sequence
  FcVolume = 4,
}

impl KeySeq {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<KeySeq> {
    let enum_value = i_prot.read_i32()?;
    KeySeq::try_from(enum_value)  }
}

impl TryFrom<i32> for KeySeq {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(KeySeq::Unknown),
      1 => Ok(KeySeq::Lexic),
      2 => Ok(KeySeq::Volume),
      3 => Ok(KeySeq::FcLexic),
      4 => Ok(KeySeq::FcVolume),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to KeySeq", i)
            )
          )
        )
      },
    }
  }
}

/// Column Value Types
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum ColumnType {
  /// Unknown/Unrecognized Type
  Unknown = 0,
  /// A Plain Column Value
  Plain = 1,
  /// A Counter Column Value with integrity of signed-64bit
  CounterI64 = 2,
  /// A Counter Column Value with integrity of signed-32bit
  CounterI32 = 3,
  /// A Counter Column Value with integrity of signed-16bit
  CounterI16 = 4,
  /// A Counter Column Value with integrity of signed-8bit
  CounterI8 = 5,
  /// A Serial Column Value
  Serial = 6,
  /// Not used - experimental
  CellDefined = 15,
}

impl ColumnType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ColumnType> {
    let enum_value = i_prot.read_i32()?;
    ColumnType::try_from(enum_value)  }
}

impl TryFrom<i32> for ColumnType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(ColumnType::Unknown),
      1 => Ok(ColumnType::Plain),
      2 => Ok(ColumnType::CounterI64),
      3 => Ok(ColumnType::CounterI32),
      4 => Ok(ColumnType::CounterI16),
      5 => Ok(ColumnType::CounterI8),
      6 => Ok(ColumnType::Serial),
      15 => Ok(ColumnType::CellDefined),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to ColumnType", i)
            )
          )
        )
      },
    }
  }
}

/// Data Encoding Types
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum EncodingType {
  /// Encoding by Ranger DEFAULT configurations
  Default = 0,
  /// No Encoding
  Plain = 1,
  /// Encode with zlib
  Zlib = 2,
  /// Encode with snappy
  Snappy = 3,
  /// Encode with zstandard
  Zstd = 4,
  /// Unrecognized Type
  Unknown = 255,
}

impl EncodingType {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EncodingType> {
    let enum_value = i_prot.read_i32()?;
    EncodingType::try_from(enum_value)  }
}

impl TryFrom<i32> for EncodingType {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(EncodingType::Default),
      1 => Ok(EncodingType::Plain),
      2 => Ok(EncodingType::Zlib),
      3 => Ok(EncodingType::Snappy),
      4 => Ok(EncodingType::Zstd),
      255 => Ok(EncodingType::Unknown),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to EncodingType", i)
            )
          )
        )
      },
    }
  }
}

/// Manage Columns schema function Flags
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum SchemaFunc {
  /// Create Column Function
  Create = 3,
  /// Delete Column Function
  Delete = 5,
  /// Modify Column Function
  Modify = 7,
}

impl SchemaFunc {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SchemaFunc> {
    let enum_value = i_prot.read_i32()?;
    SchemaFunc::try_from(enum_value)  }
}

impl TryFrom<i32> for SchemaFunc {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      3 => Ok(SchemaFunc::Create),
      5 => Ok(SchemaFunc::Delete),
      7 => Ok(SchemaFunc::Modify),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to SchemaFunc", i)
            )
          )
        )
      },
    }
  }
}

/// The available logical Comparators, plus extended logic options applied with 'v' for VOLUME
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Comp {
  /// [      ]  :   none           (no comparison aplied)
  None = 0,
  /// [  =^  ]  :   -pf [prefix]   (starts-with)
  Pf = 1,
  /// [  >   ]  :   -gt            (greater-than)
  Gt = 2,
  /// [  >=  ]  :   -ge            (greater-equal)
  Ge = 3,
  /// [  =   ]  :   -eq            (equal)
  Eq = 4,
  /// [  <=  ]  :   -le            (lower-equal)
  Le = 5,
  /// [  <   ]  :   -lt            (lower-than)
  Lt = 6,
  /// [  !=  ]  :   -ne            (not-equal)
  Ne = 7,
  /// [  re  ]  :   -re [r,regexp] (regular-expression)
  Re = 8,
  /// [  v>  ]  :   -vgt           (vol greater-than)
  Vgt = 9,
  /// [  v>= ]  :   -vge           (vol greater-equal)
  Vge = 10,
  /// [  v<= ]  :   -vle           (vol lower-equal)
  Vle = 11,
  /// [  v<  ]  :   -vlt           (vol lower-than)
  Vlt = 12,
  /// [  %>  ] :    -subset [sbs]  (subset)
  Sbs = 13,
  /// [  <%  ] :    -supset [sps]  (superset)
  Sps = 14,
  /// [  ~>  ] :    -posubset [posbs] (eq/part ordered subset)
  Posbs = 15,
  /// [  <~  ] :    -posupset [posps] (eq/part ordered superset)
  Posps = 16,
  /// [  ->  ] :    -fosubset [fosbs] (eq/full ordered subset)
  Fosbs = 17,
  /// [  <-  ] :    -fosupset [fosps] (eq/full ordered superset)
  Fosps = 18,
}

impl Comp {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Comp> {
    let enum_value = i_prot.read_i32()?;
    Comp::try_from(enum_value)  }
}

impl TryFrom<i32> for Comp {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(Comp::None),
      1 => Ok(Comp::Pf),
      2 => Ok(Comp::Gt),
      3 => Ok(Comp::Ge),
      4 => Ok(Comp::Eq),
      5 => Ok(Comp::Le),
      6 => Ok(Comp::Lt),
      7 => Ok(Comp::Ne),
      8 => Ok(Comp::Re),
      9 => Ok(Comp::Vgt),
      10 => Ok(Comp::Vge),
      11 => Ok(Comp::Vle),
      12 => Ok(Comp::Vlt),
      13 => Ok(Comp::Sbs),
      14 => Ok(Comp::Sps),
      15 => Ok(Comp::Posbs),
      16 => Ok(Comp::Posps),
      17 => Ok(Comp::Fosbs),
      18 => Ok(Comp::Fosps),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to Comp", i)
            )
          )
        )
      },
    }
  }
}

/// The Scan options Flags Specifications for the SpecFlags 'options' bit
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum SpecFlagsOpt {
  /// No Flag Applied
  None = 0,
  /// Cells Limit by Keys
  LimitByKeys = 1,
  /// Cells Offset by Keys
  OffsetByKeys = 4,
  /// Select Cells Only Keys without Value data
  OnlyKeys = 8,
  /// Select Cells Only with DELETE(cell-flag)
  OnlyDeletes = 10,
}

impl SpecFlagsOpt {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecFlagsOpt> {
    let enum_value = i_prot.read_i32()?;
    SpecFlagsOpt::try_from(enum_value)  }
}

impl TryFrom<i32> for SpecFlagsOpt {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(SpecFlagsOpt::None),
      1 => Ok(SpecFlagsOpt::LimitByKeys),
      4 => Ok(SpecFlagsOpt::OffsetByKeys),
      8 => Ok(SpecFlagsOpt::OnlyKeys),
      10 => Ok(SpecFlagsOpt::OnlyDeletes),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to SpecFlagsOpt", i)
            )
          )
        )
      },
    }
  }
}

/// The Cell Flag
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Flag {
  /// Unknown/Undefined
  None = 0,
  /// The Cell is an insert
  Insert = 1,
  /// The Cell is a delete
  Delete = 2,
  /// The Cell is a delete-version
  DeleteVersion = 3,
}

impl Flag {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Flag> {
    let enum_value = i_prot.read_i32()?;
    Flag::try_from(enum_value)  }
}

impl TryFrom<i32> for Flag {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(Flag::None),
      1 => Ok(Flag::Insert),
      2 => Ok(Flag::Delete),
      3 => Ok(Flag::DeleteVersion),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to Flag", i)
            )
          )
        )
      },
    }
  }
}

/// The Cells Results types for using with CellsGroup requests
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum CellsResult {
  /// Correspond to result on Cells (Cells in list)
  InList = 0,
  /// Correspond to result on CCells (Columns Cells)
  OnColumn = 1,
  /// Correspond to result on KCells (Keys Cells)
  OnKey = 2,
  /// Correspond to result on FCells (Fraction Cells)
  OnFraction = 3,
}

impl CellsResult {
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CellsResult> {
    let enum_value = i_prot.read_i32()?;
    CellsResult::try_from(enum_value)  }
}

impl TryFrom<i32> for CellsResult {
  type Error = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Error> {
    match i {
      0 => Ok(CellsResult::InList),
      1 => Ok(CellsResult::OnColumn),
      2 => Ok(CellsResult::OnKey),
      3 => Ok(CellsResult::OnFraction),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to CellsResult", i)
            )
          )
        )
      },
    }
  }
}

pub type Schemas = Vec<Schema>;

pub type Key = Vec<Vec<u8>>;

pub type SpecKey = Vec<SpecFraction>;

pub type SpecKeyIntervals = Vec<SpecKeyInterval>;

pub type SpecValues = Vec<SpecValue>;

pub type SpecValueSerialFields = Vec<SpecValueSerialField>;

pub type SpecValuesSerial = Vec<SpecValueSerial>;

pub type UCells = Vec<UCell>;

pub type UCCells = BTreeMap<i64, UCells>;

pub type CellValuesSerial = Vec<CellValueSerial>;

pub type UCellsSerial = Vec<UCellSerial>;

pub type UCCellsSerial = BTreeMap<i64, UCellsSerial>;

pub type CCells = BTreeMap<String, ColCells>;

pub type KCells = Vec<KCells>;

pub type CompactResults = Vec<CompactResult>;

//
// Exception
//

/// The SWC::Thrift::Exception a base for any Exceptions
/// both for the Thrift-Protocol and SWC-DB Errors.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Exception {
  /// The corresponding Thrift-Procotol or SWC-DB Error Code
  pub code: Option<i32>,
  /// The message describing the error code
  pub message: Option<String>,
}

impl Exception {
  pub fn new<F1, F2>(code: F1, message: F2) -> Exception where F1: Into<Option<i32>>, F2: Into<Option<String>> {
    Exception {
      code: code.into(),
      message: message.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Exception> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Exception {
      code: f_1,
      message: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Exception");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.code {
      o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Exception {
  fn default() -> Self {
    Exception{
      code: Some(0),
      message: Some("".to_owned()),
    }
  }
}

impl Error for Exception {
  fn description(&self) -> &str {
    "remote service threw Exception"
  }
}

impl From<Exception> for thrift::Error {
  fn from(e: Exception) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for Exception {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    self.description().fmt(f)
  }
}

//
// Schema
//

/// The Schema Definition
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Schema {
  /// Column ID
  pub cid: Option<i64>,
  /// Column Name
  pub col_name: Option<String>,
  /// Column Key Sequence
  pub col_seq: Option<KeySeq>,
  /// Column Type
  pub col_type: Option<ColumnType>,
  /// Cell Versions
  pub cell_versions: Option<i32>,
  /// Cell Time to Live
  pub cell_ttl: Option<i32>,
  /// Block Encoding
  pub blk_encoding: Option<EncodingType>,
  /// Block Size in Bytes
  pub blk_size: Option<i32>,
  /// Number of Cells in Block
  pub blk_cells: Option<i32>,
  /// CellStore file Replication
  pub cs_replication: Option<i8>,
  /// CellStore Size in Bytes
  pub cs_size: Option<i32>,
  /// Max CellStores in a Range
  pub cs_max: Option<i8>,
  /// Write Fragment File on ratio reached
  pub log_rollout_ratio: Option<i8>,
  /// Min. Cointervaling Fragments for Compaction
  pub log_compact_cointervaling: Option<i8>,
  /// Number of Fragment to Preload
  pub log_fragment_preload: Option<i8>,
  /// Compact at percent reach
  pub compact_percent: Option<i8>,
  /// Schema's revision/id
  pub revision: Option<i64>,
}

impl Schema {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17>(cid: F1, col_name: F2, col_seq: F3, col_type: F4, cell_versions: F5, cell_ttl: F6, blk_encoding: F7, blk_size: F8, blk_cells: F9, cs_replication: F10, cs_size: F11, cs_max: F12, log_rollout_ratio: F13, log_compact_cointervaling: F14, log_fragment_preload: F15, compact_percent: F16, revision: F17) -> Schema where F1: Into<Option<i64>>, F2: Into<Option<String>>, F3: Into<Option<KeySeq>>, F4: Into<Option<ColumnType>>, F5: Into<Option<i32>>, F6: Into<Option<i32>>, F7: Into<Option<EncodingType>>, F8: Into<Option<i32>>, F9: Into<Option<i32>>, F10: Into<Option<i8>>, F11: Into<Option<i32>>, F12: Into<Option<i8>>, F13: Into<Option<i8>>, F14: Into<Option<i8>>, F15: Into<Option<i8>>, F16: Into<Option<i8>>, F17: Into<Option<i64>> {
    Schema {
      cid: cid.into(),
      col_name: col_name.into(),
      col_seq: col_seq.into(),
      col_type: col_type.into(),
      cell_versions: cell_versions.into(),
      cell_ttl: cell_ttl.into(),
      blk_encoding: blk_encoding.into(),
      blk_size: blk_size.into(),
      blk_cells: blk_cells.into(),
      cs_replication: cs_replication.into(),
      cs_size: cs_size.into(),
      cs_max: cs_max.into(),
      log_rollout_ratio: log_rollout_ratio.into(),
      log_compact_cointervaling: log_compact_cointervaling.into(),
      log_fragment_preload: log_fragment_preload.into(),
      compact_percent: compact_percent.into(),
      revision: revision.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Schema> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<KeySeq> = None;
    let mut f_4: Option<ColumnType> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<EncodingType> = None;
    let mut f_8: Option<i32> = None;
    let mut f_9: Option<i32> = None;
    let mut f_10: Option<i8> = None;
    let mut f_11: Option<i32> = None;
    let mut f_12: Option<i8> = None;
    let mut f_13: Option<i8> = None;
    let mut f_14: Option<i8> = None;
    let mut f_15: Option<i8> = None;
    let mut f_16: Option<i8> = None;
    let mut f_17: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = KeySeq::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = ColumnType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = EncodingType::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i32()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i8()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i32()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i8()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i8()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i8()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_i8()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_i8()?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_i64()?;
          f_17 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Schema {
      cid: f_1,
      col_name: f_2,
      col_seq: f_3,
      col_type: f_4,
      cell_versions: f_5,
      cell_ttl: f_6,
      blk_encoding: f_7,
      blk_size: f_8,
      blk_cells: f_9,
      cs_replication: f_10,
      cs_size: f_11,
      cs_max: f_12,
      log_rollout_ratio: f_13,
      log_compact_cointervaling: f_14,
      log_fragment_preload: f_15,
      compact_percent: f_16,
      revision: f_17,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Schema");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.cid {
      o_prot.write_field_begin(&TFieldIdentifier::new("cid", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.col_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.col_seq {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_seq", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.col_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_type", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.cell_versions {
      o_prot.write_field_begin(&TFieldIdentifier::new("cell_versions", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.cell_ttl {
      o_prot.write_field_begin(&TFieldIdentifier::new("cell_ttl", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.blk_encoding {
      o_prot.write_field_begin(&TFieldIdentifier::new("blk_encoding", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.blk_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("blk_size", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.blk_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("blk_cells", TType::I32, 9))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.cs_replication {
      o_prot.write_field_begin(&TFieldIdentifier::new("cs_replication", TType::I08, 10))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.cs_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("cs_size", TType::I32, 11))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.cs_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("cs_max", TType::I08, 12))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.log_rollout_ratio {
      o_prot.write_field_begin(&TFieldIdentifier::new("log_rollout_ratio", TType::I08, 13))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.log_compact_cointervaling {
      o_prot.write_field_begin(&TFieldIdentifier::new("log_compact_cointervaling", TType::I08, 14))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.log_fragment_preload {
      o_prot.write_field_begin(&TFieldIdentifier::new("log_fragment_preload", TType::I08, 15))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.compact_percent {
      o_prot.write_field_begin(&TFieldIdentifier::new("compact_percent", TType::I08, 16))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.revision {
      o_prot.write_field_begin(&TFieldIdentifier::new("revision", TType::I64, 17))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Schema {
  fn default() -> Self {
    Schema{
      cid: Some(0),
      col_name: Some("".to_owned()),
      col_seq: None,
      col_type: None,
      cell_versions: Some(0),
      cell_ttl: Some(0),
      blk_encoding: None,
      blk_size: Some(0),
      blk_cells: Some(0),
      cs_replication: Some(0),
      cs_size: Some(0),
      cs_max: Some(0),
      log_rollout_ratio: Some(0),
      log_compact_cointervaling: Some(0),
      log_fragment_preload: Some(0),
      compact_percent: Some(0),
      revision: Some(0),
    }
  }
}

//
// SchemaPattern
//

/// The Schema Matching Pattern for the SpecSchema patterns
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SchemaPattern {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The patern value to match against schema's column name
  pub value: Option<String>,
}

impl SchemaPattern {
  pub fn new<F1, F2>(comp: F1, value: F2) -> SchemaPattern where F1: Into<Option<Comp>>, F2: Into<Option<String>> {
    SchemaPattern {
      comp: comp.into(),
      value: value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SchemaPattern> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SchemaPattern {
      comp: f_1,
      value: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SchemaPattern");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SchemaPattern {
  fn default() -> Self {
    SchemaPattern{
      comp: None,
      value: Some("".to_owned()),
    }
  }
}

//
// SpecSchemas
//

/// The Specs for Schemas for using with list_columns or compact_columns
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecSchemas {
  /// The Column IDs
  pub cids: Option<Vec<i64>>,
  /// The Column Names
  pub names: Option<Vec<String>>,
  /// The Schema's Column Name patterns
  pub patterns: Option<Vec<SchemaPattern>>,
}

impl SpecSchemas {
  pub fn new<F1, F2, F3>(cids: F1, names: F2, patterns: F3) -> SpecSchemas where F1: Into<Option<Vec<i64>>>, F2: Into<Option<Vec<String>>>, F3: Into<Option<Vec<SchemaPattern>>> {
    SpecSchemas {
      cids: cids.into(),
      names: names.into(),
      patterns: patterns.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecSchemas> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<i64>> = Some(Vec::new());
    let mut f_2: Option<Vec<String>> = Some(Vec::new());
    let mut f_3: Option<Vec<SchemaPattern>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = i_prot.read_i64()?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = i_prot.read_string()?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SchemaPattern> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = SchemaPattern::read_from_in_protocol(i_prot)?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecSchemas {
      cids: f_1,
      names: f_2,
      patterns: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecSchemas");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cids {
      o_prot.write_field_begin(&TFieldIdentifier::new("cids", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.names {
      o_prot.write_field_begin(&TFieldIdentifier::new("names", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.patterns {
      o_prot.write_field_begin(&TFieldIdentifier::new("patterns", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecSchemas {
  fn default() -> Self {
    SpecSchemas{
      cids: Some(Vec::new()),
      names: Some(Vec::new()),
      patterns: Some(Vec::new()),
    }
  }
}

//
// SpecFlags
//

/// The Scan Specifications Flags
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecFlags {
  /// Limit to this number of cells
  pub limit: Option<i64>,
  /// Scan from this number of cells Offset on matching Cell-Interval
  pub offset: Option<i64>,
  /// Select only this number of Versions of a given Cell-Key
  pub max_versions: Option<i32>,
  /// return results with reach of this Buffer size in bytes
  pub max_buffer: Option<i32>,
  /// The options bit by SpecFlagsOpt
  pub options: Option<i8>,
}

impl SpecFlags {
  pub fn new<F1, F2, F3, F4, F5>(limit: F1, offset: F2, max_versions: F3, max_buffer: F4, options: F5) -> SpecFlags where F1: Into<Option<i64>>, F2: Into<Option<i64>>, F3: Into<Option<i32>>, F4: Into<Option<i32>>, F5: Into<Option<i8>> {
    SpecFlags {
      limit: limit.into(),
      offset: offset.into(),
      max_versions: max_versions.into(),
      max_buffer: max_buffer.into(),
      options: options.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecFlags> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i8> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i8()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecFlags {
      limit: f_1,
      offset: f_2,
      max_versions: f_3,
      max_buffer: f_4,
      options: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecFlags");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("limit", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("offset", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.max_versions {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_versions", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.max_buffer {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_buffer", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.options {
      o_prot.write_field_begin(&TFieldIdentifier::new("options", TType::I08, 5))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecFlags {
  fn default() -> Self {
    SpecFlags{
      limit: Some(0),
      offset: Some(0),
      max_versions: Some(0),
      max_buffer: Some(0),
      options: Some(0),
    }
  }
}

//
// SpecFraction
//

/// The Fraction Specifications
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecFraction {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The binary(bytes) to match against a fraction of a Cell-Key
  pub f: Option<Vec<u8>>,
}

impl SpecFraction {
  pub fn new<F1, F2>(comp: F1, f: F2) -> SpecFraction where F1: Into<Option<Comp>>, F2: Into<Option<Vec<u8>>> {
    SpecFraction {
      comp: comp.into(),
      f: f.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecFraction> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecFraction {
      comp: f_1,
      f: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecFraction");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.f {
      o_prot.write_field_begin(&TFieldIdentifier::new("f", TType::String, 2))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecFraction {
  fn default() -> Self {
    SpecFraction{
      comp: None,
      f: Some(Vec::new()),
    }
  }
}

//
// SpecTimestamp
//

/// The Timestamp Specifications
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecTimestamp {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The timestamp in nanoseconds to match against the Cell timestamp/version (not the revision)
  pub ts: Option<i64>,
}

impl SpecTimestamp {
  pub fn new<F1, F2>(comp: F1, ts: F2) -> SpecTimestamp where F1: Into<Option<Comp>>, F2: Into<Option<i64>> {
    SpecTimestamp {
      comp: comp.into(),
      ts: ts.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecTimestamp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecTimestamp {
      comp: f_1,
      ts: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecTimestamp");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecTimestamp {
  fn default() -> Self {
    SpecTimestamp{
      comp: None,
      ts: Some(0),
    }
  }
}

//
// SpecKeyInterval
//

/// The Key Interval Specifications
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecKeyInterval {
  /// The Key Start Spec, the start of cells-interval key match
  pub start: Option<SpecKey>,
  /// The Key Finish Spec, the finish of cells-interval key match
  pub finish: Option<SpecKey>,
}

impl SpecKeyInterval {
  pub fn new<F1, F2>(start: F1, finish: F2) -> SpecKeyInterval where F1: Into<Option<SpecKey>>, F2: Into<Option<SpecKey>> {
    SpecKeyInterval {
      start: start.into(),
      finish: finish.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecKeyInterval> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SpecKey> = Some(Vec::new());
    let mut f_2: Option<SpecKey> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecFraction> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = SpecFraction::read_from_in_protocol(i_prot)?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecFraction> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = SpecFraction::read_from_in_protocol(i_prot)?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecKeyInterval {
      start: f_1,
      finish: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecKeyInterval");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.start {
      o_prot.write_field_begin(&TFieldIdentifier::new("start", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.finish {
      o_prot.write_field_begin(&TFieldIdentifier::new("finish", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecKeyInterval {
  fn default() -> Self {
    SpecKeyInterval{
      start: Some(Vec::new()),
      finish: Some(Vec::new()),
    }
  }
}

//
// SpecValue
//

/// The Value Specifications, option to use with Extended Logical Comparators
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValue {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The binary(bytes) to match against the Cell value
  pub v: Option<Vec<u8>>,
}

impl SpecValue {
  pub fn new<F1, F2>(comp: F1, v: F2) -> SpecValue where F1: Into<Option<Comp>>, F2: Into<Option<Vec<u8>>> {
    SpecValue {
      comp: comp.into(),
      v: v.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValue> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValue {
      comp: f_1,
      v: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValue");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::String, 2))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValue {
  fn default() -> Self {
    SpecValue{
      comp: None,
      v: Some(Vec::new()),
    }
  }
}

//
// SpecInterval
//

/// The Cells Interval Specifications with interval-scope Flags
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecInterval {
  /// Begin of Ranges evaluation with this Key inclusive
  pub range_begin: Option<Key>,
  /// End of Ranges evaluation with this Key inclusive
  pub range_end: Option<Key>,
  /// Offset of Ranges evaluation with this Key inclusive
  pub range_offset: Option<Key>,
  /// Offset Cell Key of a Scan, select cells from this key inclusive
  pub offset_key: Option<Key>,
  /// Offset Cell Timestamp of a Scan, select cells after this timestamp
  pub offset_rev: Option<i64>,
  /// The Key Intervals
  pub key_intervals: Option<SpecKeyIntervals>,
  /// The Cell Value Specifications, cell-value match
  pub values: Option<SpecValues>,
  /// The Timestamp Start Spec, the start of cells-interval timestamp match
  pub ts_start: Option<SpecTimestamp>,
  /// The Timestamp Finish Spec, the finish of cells-interval timestamp match
  pub ts_finish: Option<SpecTimestamp>,
  /// The Interval Flags Specification
  pub flags: Option<SpecFlags>,
}

impl SpecInterval {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>(range_begin: F1, range_end: F2, range_offset: F3, offset_key: F4, offset_rev: F5, key_intervals: F6, values: F7, ts_start: F8, ts_finish: F9, flags: F10) -> SpecInterval where F1: Into<Option<Key>>, F2: Into<Option<Key>>, F3: Into<Option<Key>>, F4: Into<Option<Key>>, F5: Into<Option<i64>>, F6: Into<Option<SpecKeyIntervals>>, F7: Into<Option<SpecValues>>, F8: Into<Option<SpecTimestamp>>, F9: Into<Option<SpecTimestamp>>, F10: Into<Option<SpecFlags>> {
    SpecInterval {
      range_begin: range_begin.into(),
      range_end: range_end.into(),
      range_offset: range_offset.into(),
      offset_key: offset_key.into(),
      offset_rev: offset_rev.into(),
      key_intervals: key_intervals.into(),
      values: values.into(),
      ts_start: ts_start.into(),
      ts_finish: ts_finish.into(),
      flags: flags.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecInterval> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Key> = Some(Vec::new());
    let mut f_2: Option<Key> = Some(Vec::new());
    let mut f_3: Option<Key> = Some(Vec::new());
    let mut f_4: Option<Key> = Some(Vec::new());
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<SpecKeyIntervals> = Some(Vec::new());
    let mut f_7: Option<SpecValues> = Some(Vec::new());
    let mut f_8: Option<SpecTimestamp> = None;
    let mut f_9: Option<SpecTimestamp> = None;
    let mut f_10: Option<SpecFlags> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = i_prot.read_bytes()?;
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_6 = i_prot.read_bytes()?;
            val.push(list_elem_6);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = i_prot.read_bytes()?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = i_prot.read_bytes()?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecKeyInterval> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_9 = SpecKeyInterval::read_from_in_protocol(i_prot)?;
            val.push(list_elem_9);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecValue> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_10 = SpecValue::read_from_in_protocol(i_prot)?;
            val.push(list_elem_10);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = SpecTimestamp::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = SpecTimestamp::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = SpecFlags::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecInterval {
      range_begin: f_1,
      range_end: f_2,
      range_offset: f_3,
      offset_key: f_4,
      offset_rev: f_5,
      key_intervals: f_6,
      values: f_7,
      ts_start: f_8,
      ts_finish: f_9,
      flags: f_10,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecInterval");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.range_begin {
      o_prot.write_field_begin(&TFieldIdentifier::new("range_begin", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.range_end {
      o_prot.write_field_begin(&TFieldIdentifier::new("range_end", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.range_offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("range_offset", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.offset_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("offset_key", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.offset_rev {
      o_prot.write_field_begin(&TFieldIdentifier::new("offset_rev", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.key_intervals {
      o_prot.write_field_begin(&TFieldIdentifier::new("key_intervals", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.values {
      o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.ts_start {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts_start", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.ts_finish {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts_finish", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.flags {
      o_prot.write_field_begin(&TFieldIdentifier::new("flags", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecInterval {
  fn default() -> Self {
    SpecInterval{
      range_begin: Some(Vec::new()),
      range_end: Some(Vec::new()),
      range_offset: Some(Vec::new()),
      offset_key: Some(Vec::new()),
      offset_rev: Some(0),
      key_intervals: Some(Vec::new()),
      values: Some(Vec::new()),
      ts_start: None,
      ts_finish: None,
      flags: None,
    }
  }
}

//
// SpecColumn
//

/// The Column Specifications, the Cells-Intervals(SpecInterval/s) specification for a column
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecColumn {
  /// The Column ID
  pub cid: Option<i64>,
  /// The Cells Interval in a list-container
  pub intervals: Option<Vec<SpecInterval>>,
}

impl SpecColumn {
  pub fn new<F1, F2>(cid: F1, intervals: F2) -> SpecColumn where F1: Into<Option<i64>>, F2: Into<Option<Vec<SpecInterval>>> {
    SpecColumn {
      cid: cid.into(),
      intervals: intervals.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecColumn> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<Vec<SpecInterval>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecInterval> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_11 = SpecInterval::read_from_in_protocol(i_prot)?;
            val.push(list_elem_11);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecColumn {
      cid: f_1,
      intervals: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecColumn");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.cid {
      o_prot.write_field_begin(&TFieldIdentifier::new("cid", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.intervals {
      o_prot.write_field_begin(&TFieldIdentifier::new("intervals", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecColumn {
  fn default() -> Self {
    SpecColumn{
      cid: Some(0),
      intervals: Some(Vec::new()),
    }
  }
}

//
// SpecValueSerialINT64
//

/// The Specifications of INT64 Serial Value Field
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueSerialINT64 {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The int64 to match against the value field
  pub v: Option<i64>,
}

impl SpecValueSerialINT64 {
  pub fn new<F1, F2>(comp: F1, v: F2) -> SpecValueSerialINT64 where F1: Into<Option<Comp>>, F2: Into<Option<i64>> {
    SpecValueSerialINT64 {
      comp: comp.into(),
      v: v.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueSerialINT64> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueSerialINT64 {
      comp: f_1,
      v: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueSerial_INT64");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueSerialINT64 {
  fn default() -> Self {
    SpecValueSerialINT64{
      comp: None,
      v: Some(0),
    }
  }
}

//
// SpecValueSerialDOUBLE
//

/// The Specifications of DOUBLE Serial Value Field
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueSerialDOUBLE {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The double to match against the value field
  pub v: Option<OrderedFloat<f64>>,
}

impl SpecValueSerialDOUBLE {
  pub fn new<F1, F2>(comp: F1, v: F2) -> SpecValueSerialDOUBLE where F1: Into<Option<Comp>>, F2: Into<Option<OrderedFloat<f64>>> {
    SpecValueSerialDOUBLE {
      comp: comp.into(),
      v: v.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueSerialDOUBLE> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueSerialDOUBLE {
      comp: f_1,
      v: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueSerial_DOUBLE");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueSerialDOUBLE {
  fn default() -> Self {
    SpecValueSerialDOUBLE{
      comp: None,
      v: Some(OrderedFloat::from(0.0)),
    }
  }
}

//
// SpecValueSerialBYTES
//

/// The Specifications of BYTES Serial Value Field
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueSerialBYTES {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The binary(bytes) to match against the value field
  pub v: Option<Vec<u8>>,
}

impl SpecValueSerialBYTES {
  pub fn new<F1, F2>(comp: F1, v: F2) -> SpecValueSerialBYTES where F1: Into<Option<Comp>>, F2: Into<Option<Vec<u8>>> {
    SpecValueSerialBYTES {
      comp: comp.into(),
      v: v.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueSerialBYTES> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueSerialBYTES {
      comp: f_1,
      v: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueSerial_BYTES");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::String, 2))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueSerialBYTES {
  fn default() -> Self {
    SpecValueSerialBYTES{
      comp: None,
      v: Some(Vec::new()),
    }
  }
}

//
// SpecValueSerialKEY
//

/// The Specifications of KEY Serial Value Field
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueSerialKEY {
  /// The Key Sequence to use
  pub seq: Option<KeySeq>,
  /// The Specification of the Key to match against the value field
  pub v: Option<SpecKey>,
}

impl SpecValueSerialKEY {
  pub fn new<F1, F2>(seq: F1, v: F2) -> SpecValueSerialKEY where F1: Into<Option<KeySeq>>, F2: Into<Option<SpecKey>> {
    SpecValueSerialKEY {
      seq: seq.into(),
      v: v.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueSerialKEY> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<KeySeq> = None;
    let mut f_2: Option<SpecKey> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = KeySeq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecFraction> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = SpecFraction::read_from_in_protocol(i_prot)?;
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueSerialKEY {
      seq: f_1,
      v: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueSerial_KEY");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.seq {
      o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueSerialKEY {
  fn default() -> Self {
    SpecValueSerialKEY{
      seq: None,
      v: Some(Vec::new()),
    }
  }
}

//
// SpecValueSerialLI
//

/// The Specifications of LIST_INT64(LI) Serial Value Field
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueSerialLI {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The List of Int64 to match against the value field
  pub v: Option<Vec<SpecValueSerialINT64>>,
}

impl SpecValueSerialLI {
  pub fn new<F1, F2>(comp: F1, v: F2) -> SpecValueSerialLI where F1: Into<Option<Comp>>, F2: Into<Option<Vec<SpecValueSerialINT64>>> {
    SpecValueSerialLI {
      comp: comp.into(),
      v: v.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueSerialLI> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<Vec<SpecValueSerialINT64>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecValueSerialINT64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_13 = SpecValueSerialINT64::read_from_in_protocol(i_prot)?;
            val.push(list_elem_13);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueSerialLI {
      comp: f_1,
      v: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueSerial_LI");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueSerialLI {
  fn default() -> Self {
    SpecValueSerialLI{
      comp: None,
      v: Some(Vec::new()),
    }
  }
}

//
// SpecValueSerialLB
//

/// The Specifications of LIST_BYTES(LB) Serial Value Field
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueSerialLB {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The List of Bytes to match against the value field
  pub v: Option<Vec<SpecValueSerialBYTES>>,
}

impl SpecValueSerialLB {
  pub fn new<F1, F2>(comp: F1, v: F2) -> SpecValueSerialLB where F1: Into<Option<Comp>>, F2: Into<Option<Vec<SpecValueSerialBYTES>>> {
    SpecValueSerialLB {
      comp: comp.into(),
      v: v.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueSerialLB> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<Vec<SpecValueSerialBYTES>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecValueSerialBYTES> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_14 = SpecValueSerialBYTES::read_from_in_protocol(i_prot)?;
            val.push(list_elem_14);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueSerialLB {
      comp: f_1,
      v: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueSerial_LB");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueSerialLB {
  fn default() -> Self {
    SpecValueSerialLB{
      comp: None,
      v: Some(Vec::new()),
    }
  }
}

//
// SpecValueSerialField
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueSerialField {
  /// The Field Id of the Value Field
  pub field_id: Option<i32>,
  /// The specifications of Int64 for the field
  pub spec_int64: Option<SpecValueSerialINT64>,
  /// The specifications of Double for the field
  pub spec_double: Option<SpecValueSerialDOUBLE>,
  /// The specifications of Bytes for the field
  pub spec_bytes: Option<SpecValueSerialBYTES>,
  /// The specifications of Cell-Key for the field
  pub spec_key: Option<SpecValueSerialKEY>,
  /// The specifications of List Int64 for the field
  pub spec_li: Option<SpecValueSerialLI>,
  /// The specifications of List Bytes for the field
  pub spec_lb: Option<SpecValueSerialLB>,
}

impl SpecValueSerialField {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(field_id: F1, spec_int64: F2, spec_double: F3, spec_bytes: F4, spec_key: F5, spec_li: F6, spec_lb: F7) -> SpecValueSerialField where F1: Into<Option<i32>>, F2: Into<Option<SpecValueSerialINT64>>, F3: Into<Option<SpecValueSerialDOUBLE>>, F4: Into<Option<SpecValueSerialBYTES>>, F5: Into<Option<SpecValueSerialKEY>>, F6: Into<Option<SpecValueSerialLI>>, F7: Into<Option<SpecValueSerialLB>> {
    SpecValueSerialField {
      field_id: field_id.into(),
      spec_int64: spec_int64.into(),
      spec_double: spec_double.into(),
      spec_bytes: spec_bytes.into(),
      spec_key: spec_key.into(),
      spec_li: spec_li.into(),
      spec_lb: spec_lb.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueSerialField> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<SpecValueSerialINT64> = None;
    let mut f_3: Option<SpecValueSerialDOUBLE> = None;
    let mut f_4: Option<SpecValueSerialBYTES> = None;
    let mut f_5: Option<SpecValueSerialKEY> = None;
    let mut f_6: Option<SpecValueSerialLI> = None;
    let mut f_7: Option<SpecValueSerialLB> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = SpecValueSerialINT64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = SpecValueSerialDOUBLE::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = SpecValueSerialBYTES::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = SpecValueSerialKEY::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = SpecValueSerialLI::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = SpecValueSerialLB::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueSerialField {
      field_id: f_1,
      spec_int64: f_2,
      spec_double: f_3,
      spec_bytes: f_4,
      spec_key: f_5,
      spec_li: f_6,
      spec_lb: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueSerialField");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.field_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("field_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.spec_int64 {
      o_prot.write_field_begin(&TFieldIdentifier::new("spec_int64", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.spec_double {
      o_prot.write_field_begin(&TFieldIdentifier::new("spec_double", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.spec_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("spec_bytes", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.spec_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("spec_key", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.spec_li {
      o_prot.write_field_begin(&TFieldIdentifier::new("spec_li", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.spec_lb {
      o_prot.write_field_begin(&TFieldIdentifier::new("spec_lb", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueSerialField {
  fn default() -> Self {
    SpecValueSerialField{
      field_id: Some(0),
      spec_int64: None,
      spec_double: None,
      spec_bytes: None,
      spec_key: None,
      spec_li: None,
      spec_lb: None,
    }
  }
}

//
// SpecValueSerial
//

/// The Serial Value Specifications
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueSerial {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The Serial Value Specifications to match against the SERIAL Cell value fields
  pub fields: Option<SpecValueSerialFields>,
}

impl SpecValueSerial {
  pub fn new<F1, F2>(comp: F1, fields: F2) -> SpecValueSerial where F1: Into<Option<Comp>>, F2: Into<Option<SpecValueSerialFields>> {
    SpecValueSerial {
      comp: comp.into(),
      fields: fields.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<SpecValueSerialFields> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecValueSerialField> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_15 = SpecValueSerialField::read_from_in_protocol(i_prot)?;
            val.push(list_elem_15);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueSerial {
      comp: f_1,
      fields: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.fields {
      o_prot.write_field_begin(&TFieldIdentifier::new("fields", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueSerial {
  fn default() -> Self {
    SpecValueSerial{
      comp: None,
      fields: Some(Vec::new()),
    }
  }
}

//
// SpecIntervalSerial
//

/// The Serial Value Cells Interval Specifications with interval-scope Flags
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecIntervalSerial {
  /// Begin of Ranges evaluation with this Key inclusive
  pub range_begin: Option<Key>,
  /// End of Ranges evaluation with this Key inclusive
  pub range_end: Option<Key>,
  /// Offset of Ranges evaluation with this Key inclusive
  pub range_offset: Option<Key>,
  /// Offset Cell Key of a Scan, select cells from this key inclusive
  pub offset_key: Option<Key>,
  /// Offset Cell Timestamp of a Scan, select cells after this timestamp
  pub offset_rev: Option<i64>,
  /// The Key Intervals
  pub key_intervals: Option<SpecKeyIntervals>,
  /// The Serial Cell Value Specifications, cell-value fields match
  pub values: Option<SpecValuesSerial>,
  /// The Timestamp Start Spec, the start of cells-interval timestamp match
  pub ts_start: Option<SpecTimestamp>,
  /// The Timestamp Finish Spec, the finish of cells-interval timestamp match
  pub ts_finish: Option<SpecTimestamp>,
  /// The Interval Flags Specification
  pub flags: Option<SpecFlags>,
}

impl SpecIntervalSerial {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10>(range_begin: F1, range_end: F2, range_offset: F3, offset_key: F4, offset_rev: F5, key_intervals: F6, values: F7, ts_start: F8, ts_finish: F9, flags: F10) -> SpecIntervalSerial where F1: Into<Option<Key>>, F2: Into<Option<Key>>, F3: Into<Option<Key>>, F4: Into<Option<Key>>, F5: Into<Option<i64>>, F6: Into<Option<SpecKeyIntervals>>, F7: Into<Option<SpecValuesSerial>>, F8: Into<Option<SpecTimestamp>>, F9: Into<Option<SpecTimestamp>>, F10: Into<Option<SpecFlags>> {
    SpecIntervalSerial {
      range_begin: range_begin.into(),
      range_end: range_end.into(),
      range_offset: range_offset.into(),
      offset_key: offset_key.into(),
      offset_rev: offset_rev.into(),
      key_intervals: key_intervals.into(),
      values: values.into(),
      ts_start: ts_start.into(),
      ts_finish: ts_finish.into(),
      flags: flags.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecIntervalSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Key> = Some(Vec::new());
    let mut f_2: Option<Key> = Some(Vec::new());
    let mut f_3: Option<Key> = Some(Vec::new());
    let mut f_4: Option<Key> = Some(Vec::new());
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<SpecKeyIntervals> = Some(Vec::new());
    let mut f_7: Option<SpecValuesSerial> = Some(Vec::new());
    let mut f_8: Option<SpecTimestamp> = None;
    let mut f_9: Option<SpecTimestamp> = None;
    let mut f_10: Option<SpecFlags> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_16 = i_prot.read_bytes()?;
            val.push(list_elem_16);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_17 = i_prot.read_bytes()?;
            val.push(list_elem_17);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_18 = i_prot.read_bytes()?;
            val.push(list_elem_18);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_19 = i_prot.read_bytes()?;
            val.push(list_elem_19);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecKeyInterval> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_20 = SpecKeyInterval::read_from_in_protocol(i_prot)?;
            val.push(list_elem_20);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecValueSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_21 = SpecValueSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_21);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = SpecTimestamp::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = SpecTimestamp::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = SpecFlags::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecIntervalSerial {
      range_begin: f_1,
      range_end: f_2,
      range_offset: f_3,
      offset_key: f_4,
      offset_rev: f_5,
      key_intervals: f_6,
      values: f_7,
      ts_start: f_8,
      ts_finish: f_9,
      flags: f_10,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecIntervalSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.range_begin {
      o_prot.write_field_begin(&TFieldIdentifier::new("range_begin", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.range_end {
      o_prot.write_field_begin(&TFieldIdentifier::new("range_end", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.range_offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("range_offset", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.offset_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("offset_key", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.offset_rev {
      o_prot.write_field_begin(&TFieldIdentifier::new("offset_rev", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.key_intervals {
      o_prot.write_field_begin(&TFieldIdentifier::new("key_intervals", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.values {
      o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.ts_start {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts_start", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.ts_finish {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts_finish", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.flags {
      o_prot.write_field_begin(&TFieldIdentifier::new("flags", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecIntervalSerial {
  fn default() -> Self {
    SpecIntervalSerial{
      range_begin: Some(Vec::new()),
      range_end: Some(Vec::new()),
      range_offset: Some(Vec::new()),
      offset_key: Some(Vec::new()),
      offset_rev: Some(0),
      key_intervals: Some(Vec::new()),
      values: Some(Vec::new()),
      ts_start: None,
      ts_finish: None,
      flags: None,
    }
  }
}

//
// SpecColumnSerial
//

/// The Column Specifications, the Cells-Intervals(SpecInterval/s) specification for a SERIAL Type Column
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecColumnSerial {
  /// The Column ID
  pub cid: Option<i64>,
  /// The Serial Cells Interval in a list-container
  pub intervals: Option<Vec<SpecIntervalSerial>>,
}

impl SpecColumnSerial {
  pub fn new<F1, F2>(cid: F1, intervals: F2) -> SpecColumnSerial where F1: Into<Option<i64>>, F2: Into<Option<Vec<SpecIntervalSerial>>> {
    SpecColumnSerial {
      cid: cid.into(),
      intervals: intervals.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecColumnSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<Vec<SpecIntervalSerial>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecIntervalSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_22 = SpecIntervalSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_22);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecColumnSerial {
      cid: f_1,
      intervals: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecColumnSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.cid {
      o_prot.write_field_begin(&TFieldIdentifier::new("cid", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.intervals {
      o_prot.write_field_begin(&TFieldIdentifier::new("intervals", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecColumnSerial {
  fn default() -> Self {
    SpecColumnSerial{
      cid: Some(0),
      intervals: Some(Vec::new()),
    }
  }
}

//
// SpecScan
//

/// The Scan Specifications, the Columns-Intervals(SpecColumn/s) with global-scope Flags
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecScan {
  /// The Column Intervals(SpecColumn) in a list-container
  pub columns: Option<Vec<SpecColumn>>,
  /// The Serial Column Intervals(SpecColumnSerial) in a list-container
  pub columns_serial: Option<Vec<SpecColumnSerial>>,
  /// The Global Flags Specification
  pub flags: Option<SpecFlags>,
}

impl SpecScan {
  pub fn new<F1, F2, F3>(columns: F1, columns_serial: F2, flags: F3) -> SpecScan where F1: Into<Option<Vec<SpecColumn>>>, F2: Into<Option<Vec<SpecColumnSerial>>>, F3: Into<Option<SpecFlags>> {
    SpecScan {
      columns: columns.into(),
      columns_serial: columns_serial.into(),
      flags: flags.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecScan> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SpecColumn>> = Some(Vec::new());
    let mut f_2: Option<Vec<SpecColumnSerial>> = Some(Vec::new());
    let mut f_3: Option<SpecFlags> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecColumn> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_23 = SpecColumn::read_from_in_protocol(i_prot)?;
            val.push(list_elem_23);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecColumnSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_24 = SpecColumnSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_24);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = SpecFlags::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecScan {
      columns: f_1,
      columns_serial: f_2,
      flags: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecScan");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.columns {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.columns_serial {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns_serial", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.flags {
      o_prot.write_field_begin(&TFieldIdentifier::new("flags", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecScan {
  fn default() -> Self {
    SpecScan{
      columns: Some(Vec::new()),
      columns_serial: Some(Vec::new()),
      flags: None,
    }
  }
}

//
// UCell
//

/// The Cell data for using with Update
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UCell {
  /// The Cell Flag
  pub f: Option<Flag>,
  /// The Cell Key
  pub k: Option<Key>,
  /// The Cell Timestamp in nanoseconds
  pub ts: Option<i64>,
  /// The Cell Version is in timestamp descending
  pub ts_desc: Option<bool>,
  /// The Cell Value
  pub v: Option<Vec<u8>>,
  /// Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
  pub encoder: Option<EncodingType>,
}

impl UCell {
  pub fn new<F1, F2, F3, F4, F5, F6>(f: F1, k: F2, ts: F3, ts_desc: F4, v: F5, encoder: F6) -> UCell where F1: Into<Option<Flag>>, F2: Into<Option<Key>>, F3: Into<Option<i64>>, F4: Into<Option<bool>>, F5: Into<Option<Vec<u8>>>, F6: Into<Option<EncodingType>> {
    UCell {
      f: f.into(),
      k: k.into(),
      ts: ts.into(),
      ts_desc: ts_desc.into(),
      v: v.into(),
      encoder: encoder.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UCell> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Flag> = None;
    let mut f_2: Option<Key> = Some(Vec::new());
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<Vec<u8>> = Some(Vec::new());
    let mut f_6: Option<EncodingType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Flag::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_25 = i_prot.read_bytes()?;
            val.push(list_elem_25);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        6 => {
          let val = EncodingType::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UCell {
      f: f_1,
      k: f_2,
      ts: f_3,
      ts_desc: f_4,
      v: f_5,
      encoder: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UCell");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.f {
      o_prot.write_field_begin(&TFieldIdentifier::new("f", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.ts_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts_desc", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.encoder {
      o_prot.write_field_begin(&TFieldIdentifier::new("encoder", TType::I32, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for UCell {
  fn default() -> Self {
    UCell{
      f: None,
      k: Some(Vec::new()),
      ts: Some(0),
      ts_desc: Some(false),
      v: Some(Vec::new()),
      encoder: None,
    }
  }
}

//
// CellValueSerial
//

/// The Serial Value Cell field
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CellValueSerial {
  /// The Field ID, a single ID can have any/all the field types
  pub field_id: Option<i32>,
  /// The INT64 type field
  pub v_int64: Option<i64>,
  /// The DOUBLE type field
  pub v_double: Option<OrderedFloat<f64>>,
  /// The BYTES type field
  pub v_bytes: Option<Vec<u8>>,
  /// The Cell KEY type field
  pub v_key: Option<Key>,
  /// The LIST INT64 type field
  pub v_li: Option<Vec<i64>>,
  /// The LIST BYTES type field
  pub v_lb: Option<Vec<Vec<u8>>>,
}

impl CellValueSerial {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(field_id: F1, v_int64: F2, v_double: F3, v_bytes: F4, v_key: F5, v_li: F6, v_lb: F7) -> CellValueSerial where F1: Into<Option<i32>>, F2: Into<Option<i64>>, F3: Into<Option<OrderedFloat<f64>>>, F4: Into<Option<Vec<u8>>>, F5: Into<Option<Key>>, F6: Into<Option<Vec<i64>>>, F7: Into<Option<Vec<Vec<u8>>>> {
    CellValueSerial {
      field_id: field_id.into(),
      v_int64: v_int64.into(),
      v_double: v_double.into(),
      v_bytes: v_bytes.into(),
      v_key: v_key.into(),
      v_li: v_li.into(),
      v_lb: v_lb.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CellValueSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<OrderedFloat<f64>> = None;
    let mut f_4: Option<Vec<u8>> = Some(Vec::new());
    let mut f_5: Option<Key> = Some(Vec::new());
    let mut f_6: Option<Vec<i64>> = Some(Vec::new());
    let mut f_7: Option<Vec<Vec<u8>>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_26 = i_prot.read_bytes()?;
            val.push(list_elem_26);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_27 = i_prot.read_i64()?;
            val.push(list_elem_27);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_28 = i_prot.read_bytes()?;
            val.push(list_elem_28);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CellValueSerial {
      field_id: f_1,
      v_int64: f_2,
      v_double: f_3,
      v_bytes: f_4,
      v_key: f_5,
      v_li: f_6,
      v_lb: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CellValueSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.field_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("field_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.v_int64 {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_int64", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.v_double {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_double", TType::Double, 3))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_bytes", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_key", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v_li {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_li", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v_lb {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_lb", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CellValueSerial {
  fn default() -> Self {
    CellValueSerial{
      field_id: Some(0),
      v_int64: Some(0),
      v_double: Some(OrderedFloat::from(0.0)),
      v_bytes: Some(Vec::new()),
      v_key: Some(Vec::new()),
      v_li: Some(Vec::new()),
      v_lb: Some(Vec::new()),
    }
  }
}

//
// UCellSerial
//

/// The Cell data for using with Update of SERIAL Column Type
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UCellSerial {
  /// The Cell Flag
  pub f: Option<Flag>,
  /// The Cell Key
  pub k: Option<Key>,
  /// The Cell Timestamp in nanoseconds
  pub ts: Option<i64>,
  /// The Cell Version is in timestamp descending
  pub ts_desc: Option<bool>,
  /// The Serial Cell Value fields
  pub v: Option<CellValuesSerial>,
  /// Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
  pub encoder: Option<EncodingType>,
}

impl UCellSerial {
  pub fn new<F1, F2, F3, F4, F5, F6>(f: F1, k: F2, ts: F3, ts_desc: F4, v: F5, encoder: F6) -> UCellSerial where F1: Into<Option<Flag>>, F2: Into<Option<Key>>, F3: Into<Option<i64>>, F4: Into<Option<bool>>, F5: Into<Option<CellValuesSerial>>, F6: Into<Option<EncodingType>> {
    UCellSerial {
      f: f.into(),
      k: k.into(),
      ts: ts.into(),
      ts_desc: ts_desc.into(),
      v: v.into(),
      encoder: encoder.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UCellSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Flag> = None;
    let mut f_2: Option<Key> = Some(Vec::new());
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<CellValuesSerial> = Some(Vec::new());
    let mut f_6: Option<EncodingType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Flag::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_29 = i_prot.read_bytes()?;
            val.push(list_elem_29);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellValueSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_30 = CellValueSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_30);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = EncodingType::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UCellSerial {
      f: f_1,
      k: f_2,
      ts: f_3,
      ts_desc: f_4,
      v: f_5,
      encoder: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UCellSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.f {
      o_prot.write_field_begin(&TFieldIdentifier::new("f", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.ts_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts_desc", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.encoder {
      o_prot.write_field_begin(&TFieldIdentifier::new("encoder", TType::I32, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for UCellSerial {
  fn default() -> Self {
    UCellSerial{
      f: None,
      k: Some(Vec::new()),
      ts: Some(0),
      ts_desc: Some(false),
      v: Some(Vec::new()),
      encoder: None,
    }
  }
}

//
// Cell
//

/// The Cell for results list of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Cell {
  /// The Column Name
  pub c: Option<String>,
  /// The Cell Key
  pub k: Option<Key>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Value
  pub v: Option<Vec<u8>>,
}

impl Cell {
  pub fn new<F1, F2, F3, F4>(c: F1, k: F2, ts: F3, v: F4) -> Cell where F1: Into<Option<String>>, F2: Into<Option<Key>>, F3: Into<Option<i64>>, F4: Into<Option<Vec<u8>>> {
    Cell {
      c: c.into(),
      k: k.into(),
      ts: ts.into(),
      v: v.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Cell> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Key> = Some(Vec::new());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_31 = i_prot.read_bytes()?;
            val.push(list_elem_31);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Cell {
      c: f_1,
      k: f_2,
      ts: f_3,
      v: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Cell");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.c {
      o_prot.write_field_begin(&TFieldIdentifier::new("c", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Cell {
  fn default() -> Self {
    Cell{
      c: Some("".to_owned()),
      k: Some(Vec::new()),
      ts: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// CellSerial
//

/// The Serial Cell for results list of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CellSerial {
  /// The Column Name
  pub c: Option<String>,
  /// The Cell Key
  pub k: Option<Key>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Serial Value
  pub v: Option<CellValuesSerial>,
}

impl CellSerial {
  pub fn new<F1, F2, F3, F4>(c: F1, k: F2, ts: F3, v: F4) -> CellSerial where F1: Into<Option<String>>, F2: Into<Option<Key>>, F3: Into<Option<i64>>, F4: Into<Option<CellValuesSerial>> {
    CellSerial {
      c: c.into(),
      k: k.into(),
      ts: ts.into(),
      v: v.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CellSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Key> = Some(Vec::new());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<CellValuesSerial> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_32 = i_prot.read_bytes()?;
            val.push(list_elem_32);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellValueSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_33 = CellValueSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_33);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CellSerial {
      c: f_1,
      k: f_2,
      ts: f_3,
      v: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CellSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.c {
      o_prot.write_field_begin(&TFieldIdentifier::new("c", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CellSerial {
  fn default() -> Self {
    CellSerial{
      c: Some("".to_owned()),
      k: Some(Vec::new()),
      ts: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// Cells
//

/// The Cells for results list of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Cells {
  /// The Cells, defined as Cell items in a list-container
  pub cells: Option<Vec<Cell>>,
  /// The Serial Cells, defined as CellSerial items in a list-container
  pub serial_cells: Option<Vec<CellSerial>>,
}

impl Cells {
  pub fn new<F1, F2>(cells: F1, serial_cells: F2) -> Cells where F1: Into<Option<Vec<Cell>>>, F2: Into<Option<Vec<CellSerial>>> {
    Cells {
      cells: cells.into(),
      serial_cells: serial_cells.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Cells> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<Cell>> = Some(Vec::new());
    let mut f_2: Option<Vec<CellSerial>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Cell> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_34 = Cell::read_from_in_protocol(i_prot)?;
            val.push(list_elem_34);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_35 = CellSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_35);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Cells {
      cells: f_1,
      serial_cells: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Cells");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("cells", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.serial_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("serial_cells", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Cells {
  fn default() -> Self {
    Cells{
      cells: Some(Vec::new()),
      serial_cells: Some(Vec::new()),
    }
  }
}

//
// CCell
//

/// The Column Cell for results on Columns of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CCell {
  /// The Cell Key
  pub k: Option<Key>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Value
  pub v: Option<Vec<u8>>,
}

impl CCell {
  pub fn new<F1, F2, F3>(k: F1, ts: F2, v: F3) -> CCell where F1: Into<Option<Key>>, F2: Into<Option<i64>>, F3: Into<Option<Vec<u8>>> {
    CCell {
      k: k.into(),
      ts: ts.into(),
      v: v.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CCell> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Key> = Some(Vec::new());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_36 = i_prot.read_bytes()?;
            val.push(list_elem_36);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CCell {
      k: f_1,
      ts: f_2,
      v: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CCell");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CCell {
  fn default() -> Self {
    CCell{
      k: Some(Vec::new()),
      ts: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// CCellSerial
//

/// The Column Serial Cell for results on Columns of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CCellSerial {
  /// The Cell Key
  pub k: Option<Key>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Serial Value
  pub v: Option<CellValuesSerial>,
}

impl CCellSerial {
  pub fn new<F1, F2, F3>(k: F1, ts: F2, v: F3) -> CCellSerial where F1: Into<Option<Key>>, F2: Into<Option<i64>>, F3: Into<Option<CellValuesSerial>> {
    CCellSerial {
      k: k.into(),
      ts: ts.into(),
      v: v.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CCellSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Key> = Some(Vec::new());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<CellValuesSerial> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_37 = i_prot.read_bytes()?;
            val.push(list_elem_37);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellValueSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_38 = CellValueSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_38);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CCellSerial {
      k: f_1,
      ts: f_2,
      v: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CCellSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CCellSerial {
  fn default() -> Self {
    CCellSerial{
      k: Some(Vec::new()),
      ts: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// ColCells
//

/// The Column Cells for results on Columns of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ColCells {
  /// The Cells, defined as CCell items in a list-container
  pub cells: Option<Vec<CCell>>,
  /// The Serial Cells, defined as CCellSerial items in a list-container
  pub serial_cells: Option<Vec<CCellSerial>>,
}

impl ColCells {
  pub fn new<F1, F2>(cells: F1, serial_cells: F2) -> ColCells where F1: Into<Option<Vec<CCell>>>, F2: Into<Option<Vec<CCellSerial>>> {
    ColCells {
      cells: cells.into(),
      serial_cells: serial_cells.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ColCells> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<CCell>> = Some(Vec::new());
    let mut f_2: Option<Vec<CCellSerial>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CCell> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_39 = CCell::read_from_in_protocol(i_prot)?;
            val.push(list_elem_39);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CCellSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_40 = CCellSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_40);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ColCells {
      cells: f_1,
      serial_cells: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ColCells");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("cells", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.serial_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("serial_cells", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ColCells {
  fn default() -> Self {
    ColCells{
      cells: Some(Vec::new()),
      serial_cells: Some(Vec::new()),
    }
  }
}

//
// KCell
//

/// The Key Cell for results on Key of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct KCell {
  /// The Column Name
  pub c: Option<String>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Value
  pub v: Option<Vec<u8>>,
}

impl KCell {
  pub fn new<F1, F2, F3>(c: F1, ts: F2, v: F3) -> KCell where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<Vec<u8>>> {
    KCell {
      c: c.into(),
      ts: ts.into(),
      v: v.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<KCell> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = KCell {
      c: f_1,
      ts: f_2,
      v: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("KCell");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.c {
      o_prot.write_field_begin(&TFieldIdentifier::new("c", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for KCell {
  fn default() -> Self {
    KCell{
      c: Some("".to_owned()),
      ts: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// KCellSerial
//

/// The Key Serial Cell for results on Key of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct KCellSerial {
  /// The Column Name
  pub c: Option<String>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Serial Value
  pub v: Option<CellValuesSerial>,
}

impl KCellSerial {
  pub fn new<F1, F2, F3>(c: F1, ts: F2, v: F3) -> KCellSerial where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<CellValuesSerial>> {
    KCellSerial {
      c: c.into(),
      ts: ts.into(),
      v: v.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<KCellSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<CellValuesSerial> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellValueSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_41 = CellValueSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_41);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = KCellSerial {
      c: f_1,
      ts: f_2,
      v: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("KCellSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.c {
      o_prot.write_field_begin(&TFieldIdentifier::new("c", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for KCellSerial {
  fn default() -> Self {
    KCellSerial{
      c: Some("".to_owned()),
      ts: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// KCells
//

/// The Key Cells for results on Key of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct KCells {
  /// The Cell Key
  pub k: Option<Key>,
  /// The Key's Cells, defined as KCell items in a list-container
  pub cells: Option<Vec<KCell>>,
  /// The Key's Serial Cells, defined as KCellSerial items in a list-container
  pub serial_cells: Option<Vec<KCellSerial>>,
}

impl KCells {
  pub fn new<F1, F2, F3>(k: F1, cells: F2, serial_cells: F3) -> KCells where F1: Into<Option<Key>>, F2: Into<Option<Vec<KCell>>>, F3: Into<Option<Vec<KCellSerial>>> {
    KCells {
      k: k.into(),
      cells: cells.into(),
      serial_cells: serial_cells.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<KCells> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Key> = Some(Vec::new());
    let mut f_2: Option<Vec<KCell>> = Some(Vec::new());
    let mut f_3: Option<Vec<KCellSerial>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_42 = i_prot.read_bytes()?;
            val.push(list_elem_42);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<KCell> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_43 = KCell::read_from_in_protocol(i_prot)?;
            val.push(list_elem_43);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<KCellSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_44 = KCellSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_44);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = KCells {
      k: f_1,
      cells: f_2,
      serial_cells: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("kCells");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("cells", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.serial_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("serial_cells", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for KCells {
  fn default() -> Self {
    KCells{
      k: Some(Vec::new()),
      cells: Some(Vec::new()),
      serial_cells: Some(Vec::new()),
    }
  }
}

//
// FCell
//

/// The Fraction Cell for results on Fraction of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FCell {
  /// The Column Name
  pub c: Option<String>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Value
  pub v: Option<Vec<u8>>,
}

impl FCell {
  pub fn new<F1, F2, F3>(c: F1, ts: F2, v: F3) -> FCell where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<Vec<u8>>> {
    FCell {
      c: c.into(),
      ts: ts.into(),
      v: v.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FCell> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FCell {
      c: f_1,
      ts: f_2,
      v: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FCell");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.c {
      o_prot.write_field_begin(&TFieldIdentifier::new("c", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FCell {
  fn default() -> Self {
    FCell{
      c: Some("".to_owned()),
      ts: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// FCellSerial
//

/// The Fraction Serial Cell for results on Fraction of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FCellSerial {
  /// The Column Name
  pub c: Option<String>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Serial Value
  pub v: Option<CellValuesSerial>,
}

impl FCellSerial {
  pub fn new<F1, F2, F3>(c: F1, ts: F2, v: F3) -> FCellSerial where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<CellValuesSerial>> {
    FCellSerial {
      c: c.into(),
      ts: ts.into(),
      v: v.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FCellSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<CellValuesSerial> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellValueSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_45 = CellValueSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_45);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FCellSerial {
      c: f_1,
      ts: f_2,
      v: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FCellSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.c {
      o_prot.write_field_begin(&TFieldIdentifier::new("c", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FCellSerial {
  fn default() -> Self {
    FCellSerial{
      c: Some("".to_owned()),
      ts: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// FCells
//

/// The Fraction Cells for results on Fraction of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FCells {
  /// The Fraction Container for the Next Fractions Tree,  defined as FCells items in a map-container by current Fraction bytes
  pub f: Option<BTreeMap<Vec<u8>, Box<FCells>>>,
  /// The current Fraction's Cells, defined as FCell items in a list-container
  pub cells: Option<Vec<FCell>>,
  /// The current Fraction's Serial Cells, defined as FCellSerial items in a list-container
  pub serial_cells: Option<Vec<FCellSerial>>,
}

impl FCells {
  pub fn new<F1, F2, F3>(f: F1, cells: F2, serial_cells: F3) -> FCells where F1: Into<Option<BTreeMap<Vec<u8>, Box<FCells>>>>, F2: Into<Option<Vec<FCell>>>, F3: Into<Option<Vec<FCellSerial>>> {
    FCells {
      f: f.into(),
      cells: cells.into(),
      serial_cells: serial_cells.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FCells> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<Vec<u8>, Box<FCells>>> = Some(BTreeMap::new());
    let mut f_2: Option<Vec<FCell>> = Some(Vec::new());
    let mut f_3: Option<Vec<FCellSerial>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<Vec<u8>, Box<FCells>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_46 = i_prot.read_bytes()?;
            let map_val_47 = Box::new(FCells::read_from_in_protocol(i_prot)?);
            val.insert(map_key_46, map_val_47);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FCell> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_48 = FCell::read_from_in_protocol(i_prot)?;
            val.push(list_elem_48);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FCellSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_49 = FCellSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_49);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FCells {
      f: f_1,
      cells: f_2,
      serial_cells: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FCells");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.f {
      o_prot.write_field_begin(&TFieldIdentifier::new("f", TType::Map, 1))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_bytes(k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("cells", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.serial_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("serial_cells", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FCells {
  fn default() -> Self {
    FCells{
      f: Some(BTreeMap::new()),
      cells: Some(Vec::new()),
      serial_cells: Some(Vec::new()),
    }
  }
}

//
// CellsGroup
//

/// A Grouped Cells result for results of scan, determined by the request's CellsResult enum
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CellsGroup {
  /// The Cells in a list, defined as Cell items in a list-container
  pub cells: Option<Cells>,
  /// The Columns Cells in a map-container, defined as ColCells items by Column Name
  pub ccells: Option<CCells>,
  /// The Keys Cells in a list, defined as kCells items in a list-container
  pub kcells: Option<KCells>,
  /// The Fraction Cells in struct FCells
  pub fcells: Option<FCells>,
}

impl CellsGroup {
  pub fn new<F1, F2, F3, F4>(cells: F1, ccells: F2, kcells: F3, fcells: F4) -> CellsGroup where F1: Into<Option<Cells>>, F2: Into<Option<CCells>>, F3: Into<Option<KCells>>, F4: Into<Option<FCells>> {
    CellsGroup {
      cells: cells.into(),
      ccells: ccells.into(),
      kcells: kcells.into(),
      fcells: fcells.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CellsGroup> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Cells> = None;
    let mut f_2: Option<CCells> = Some(BTreeMap::new());
    let mut f_3: Option<KCells> = Some(Vec::new());
    let mut f_4: Option<FCells> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Cells::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, ColCells> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_50 = i_prot.read_string()?;
            let map_val_51 = ColCells::read_from_in_protocol(i_prot)?;
            val.insert(map_key_50, map_val_51);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<KCells> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_52 = KCells::read_from_in_protocol(i_prot)?;
            val.push(list_elem_52);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = FCells::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CellsGroup {
      cells: f_1,
      ccells: f_2,
      kcells: f_3,
      fcells: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CellsGroup");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("cells", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.ccells {
      o_prot.write_field_begin(&TFieldIdentifier::new("ccells", TType::Map, 2))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.kcells {
      o_prot.write_field_begin(&TFieldIdentifier::new("kcells", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.fcells {
      o_prot.write_field_begin(&TFieldIdentifier::new("fcells", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CellsGroup {
  fn default() -> Self {
    CellsGroup{
      cells: None,
      ccells: Some(BTreeMap::new()),
      kcells: Some(Vec::new()),
      fcells: None,
    }
  }
}

//
// CompactResult
//

/// The Compact Result
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CompactResult {
  /// Column ID
  pub cid: Option<i64>,
  /// Error
  pub err: Option<i32>,
}

impl CompactResult {
  pub fn new<F1, F2>(cid: F1, err: F2) -> CompactResult where F1: Into<Option<i64>>, F2: Into<Option<i32>> {
    CompactResult {
      cid: cid.into(),
      err: err.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CompactResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CompactResult {
      cid: f_1,
      err: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CompactResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.cid {
      o_prot.write_field_begin(&TFieldIdentifier::new("cid", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.err {
      o_prot.write_field_begin(&TFieldIdentifier::new("err", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CompactResult {
  fn default() -> Self {
    CompactResult{
      cid: Some(0),
      err: Some(0),
    }
  }
}

//
// Result
//

/// The Result of 'exec_sql'
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Result {
  /// Set with result for 'list columns' query
  pub schemas: Option<Schemas>,
  /// Set with result for 'select' query
  pub cells: Option<Cells>,
  /// Set with result for 'compact columns' query
  pub compact: Option<CompactResults>,
}

impl Result {
  pub fn new<F1, F2, F3>(schemas: F1, cells: F2, compact: F3) -> Result where F1: Into<Option<Schemas>>, F2: Into<Option<Cells>>, F3: Into<Option<CompactResults>> {
    Result {
      schemas: schemas.into(),
      cells: cells.into(),
      compact: compact.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Result> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Schemas> = Some(Vec::new());
    let mut f_2: Option<Cells> = None;
    let mut f_3: Option<CompactResults> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Schema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_53 = Schema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_53);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Cells::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CompactResult> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_54 = CompactResult::read_from_in_protocol(i_prot)?;
            val.push(list_elem_54);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Result {
      schemas: f_1,
      cells: f_2,
      compact: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.schemas {
      o_prot.write_field_begin(&TFieldIdentifier::new("schemas", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("cells", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.compact {
      o_prot.write_field_begin(&TFieldIdentifier::new("compact", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Result {
  fn default() -> Self {
    Result{
      schemas: Some(Vec::new()),
      cells: None,
      compact: Some(Vec::new()),
    }
  }
}

//
// Service service client
//

/// The SWC-DB Thrift Service
pub trait TServiceSyncClient {
  /// The direct SQL method to Manage Column.
  fn sql_mng_column(&mut self, sql: String) -> thrift::Result<()>;
  /// The direct SQL method to List Columns
  fn sql_list_columns(&mut self, sql: String) -> thrift::Result<Schemas>;
  /// The direct SQL method to Compact Columns
  fn sql_compact_columns(&mut self, sql: String) -> thrift::Result<CompactResults>;
  /// The direct SQL method to select cells with result in Cells List.
  fn sql_select(&mut self, sql: String) -> thrift::Result<Cells>;
  /// The direct SQL method to select cells with result in Columns Cells map.
  fn sql_select_rslt_on_column(&mut self, sql: String) -> thrift::Result<CCells>;
  /// The direct SQL method to select cells with result in Key Cells list.
  fn sql_select_rslt_on_key(&mut self, sql: String) -> thrift::Result<KCells>;
  /// The direct SQL method to select cells with result in Fractons Cells.
  fn sql_select_rslt_on_fraction(&mut self, sql: String) -> thrift::Result<FCells>;
  /// The SQL method to select cells with result set by the request's type of CellsResult.
  fn sql_query(&mut self, sql: String, rslt: CellsResult) -> thrift::Result<CellsGroup>;
  /// The direct SQL method to update cells optionally to work with updater-id.
  fn sql_update(&mut self, sql: String, updater_id: i64) -> thrift::Result<()>;
  /// The SQL method to execute any query.
  fn exec_sql(&mut self, sql: String) -> thrift::Result<Result>;
  /// The method to Create an Updater ID with buffering size in bytes.
  fn updater_create(&mut self, buffer_size: i32) -> thrift::Result<i64>;
  /// The method to Close an Updater ID.
  fn updater_close(&mut self, id: i64) -> thrift::Result<()>;
  /// The direct method to update cells with cell in Update-Columns-Cells,
  /// optionally to work with updater-id.
  fn update(&mut self, cells: UCCells, updater_id: i64) -> thrift::Result<()>;
  /// The direct method to update cells with cell in Update-Columns-Cells-Serial,
  /// optionally to work with updater-id.
  fn update_serial(&mut self, cells: UCCellsSerial, updater_id: i64) -> thrift::Result<()>;
  /// The direct method to Manage Column
  fn mng_column(&mut self, func: SchemaFunc, schema: Schema) -> thrift::Result<()>;
  /// The direct method to List Columns
  fn list_columns(&mut self, spec: SpecSchemas) -> thrift::Result<Schemas>;
  /// The direct method to Compact Columns
  fn compact_columns(&mut self, spec: SpecSchemas) -> thrift::Result<CompactResults>;
  /// The direct method to select cells with result in Cells List.
  fn scan(&mut self, spec: SpecScan) -> thrift::Result<Cells>;
  /// The direct method to select cells with result in Columns Cells map.
  fn scan_rslt_on_column(&mut self, spec: SpecScan) -> thrift::Result<CCells>;
  /// The direct method to select cells with result in Key Cells list.
  fn scan_rslt_on_key(&mut self, spec: SpecScan) -> thrift::Result<KCells>;
  /// The direct method to select cells with result in Fractons Cells.
  fn scan_rslt_on_fraction(&mut self, spec: SpecScan) -> thrift::Result<FCells>;
  /// The method to select cells with result set by the request's type of CellsResult.
  fn scan_rslt_on(&mut self, spec: SpecScan, rslt: CellsResult) -> thrift::Result<CellsGroup>;
}

pub trait TServiceSyncClientMarker {}

pub struct ServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> ServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> ServiceSyncClient<IP, OP> {
    ServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for ServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TServiceSyncClientMarker for ServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TServiceSyncClientMarker> TServiceSyncClient for C {
  fn sql_mng_column(&mut self, sql: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_mng_column", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlMngColumnArgs { sql: sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_mng_column", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlMngColumnResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_list_columns(&mut self, sql: String) -> thrift::Result<Schemas> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_list_columns", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlListColumnsArgs { sql: sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_list_columns", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlListColumnsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_compact_columns(&mut self, sql: String) -> thrift::Result<CompactResults> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_compact_columns", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlCompactColumnsArgs { sql: sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_compact_columns", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlCompactColumnsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_select(&mut self, sql: String) -> thrift::Result<Cells> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_select", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlSelectArgs { sql: sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_select", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlSelectResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_select_rslt_on_column(&mut self, sql: String) -> thrift::Result<CCells> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_select_rslt_on_column", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlSelectRsltOnColumnArgs { sql: sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_select_rslt_on_column", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlSelectRsltOnColumnResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_select_rslt_on_key(&mut self, sql: String) -> thrift::Result<KCells> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_select_rslt_on_key", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlSelectRsltOnKeyArgs { sql: sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_select_rslt_on_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlSelectRsltOnKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_select_rslt_on_fraction(&mut self, sql: String) -> thrift::Result<FCells> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_select_rslt_on_fraction", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlSelectRsltOnFractionArgs { sql: sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_select_rslt_on_fraction", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlSelectRsltOnFractionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_query(&mut self, sql: String, rslt: CellsResult) -> thrift::Result<CellsGroup> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_query", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlQueryArgs { sql: sql, rslt: rslt };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_query", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlQueryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_update(&mut self, sql: String, updater_id: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_update", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlUpdateArgs { sql: sql, updater_id: updater_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_update", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlUpdateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn exec_sql(&mut self, sql: String) -> thrift::Result<Result> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("exec_sql", TMessageType::Call, self.sequence_number());
        let call_args = ServiceExecSqlArgs { sql: sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("exec_sql", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceExecSqlResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn updater_create(&mut self, buffer_size: i32) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updater_create", TMessageType::Call, self.sequence_number());
        let call_args = ServiceUpdaterCreateArgs { buffer_size: buffer_size };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updater_create", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceUpdaterCreateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn updater_close(&mut self, id: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updater_close", TMessageType::Call, self.sequence_number());
        let call_args = ServiceUpdaterCloseArgs { id: id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updater_close", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceUpdaterCloseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update(&mut self, cells: UCCells, updater_id: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("update", TMessageType::Call, self.sequence_number());
        let call_args = ServiceUpdateArgs { cells: cells, updater_id: updater_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("update", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceUpdateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_serial(&mut self, cells: UCCellsSerial, updater_id: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("update_serial", TMessageType::Call, self.sequence_number());
        let call_args = ServiceUpdateSerialArgs { cells: cells, updater_id: updater_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("update_serial", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceUpdateSerialResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn mng_column(&mut self, func: SchemaFunc, schema: Schema) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("mng_column", TMessageType::Call, self.sequence_number());
        let call_args = ServiceMngColumnArgs { func: func, schema: schema };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("mng_column", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceMngColumnResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_columns(&mut self, spec: SpecSchemas) -> thrift::Result<Schemas> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("list_columns", TMessageType::Call, self.sequence_number());
        let call_args = ServiceListColumnsArgs { spec: spec };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("list_columns", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceListColumnsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn compact_columns(&mut self, spec: SpecSchemas) -> thrift::Result<CompactResults> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("compact_columns", TMessageType::Call, self.sequence_number());
        let call_args = ServiceCompactColumnsArgs { spec: spec };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("compact_columns", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceCompactColumnsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn scan(&mut self, spec: SpecScan) -> thrift::Result<Cells> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("scan", TMessageType::Call, self.sequence_number());
        let call_args = ServiceScanArgs { spec: spec };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("scan", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceScanResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn scan_rslt_on_column(&mut self, spec: SpecScan) -> thrift::Result<CCells> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("scan_rslt_on_column", TMessageType::Call, self.sequence_number());
        let call_args = ServiceScanRsltOnColumnArgs { spec: spec };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("scan_rslt_on_column", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceScanRsltOnColumnResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn scan_rslt_on_key(&mut self, spec: SpecScan) -> thrift::Result<KCells> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("scan_rslt_on_key", TMessageType::Call, self.sequence_number());
        let call_args = ServiceScanRsltOnKeyArgs { spec: spec };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("scan_rslt_on_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceScanRsltOnKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn scan_rslt_on_fraction(&mut self, spec: SpecScan) -> thrift::Result<FCells> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("scan_rslt_on_fraction", TMessageType::Call, self.sequence_number());
        let call_args = ServiceScanRsltOnFractionArgs { spec: spec };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("scan_rslt_on_fraction", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceScanRsltOnFractionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn scan_rslt_on(&mut self, spec: SpecScan, rslt: CellsResult) -> thrift::Result<CellsGroup> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("scan_rslt_on", TMessageType::Call, self.sequence_number());
        let call_args = ServiceScanRsltOnArgs { spec: spec, rslt: rslt };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("scan_rslt_on", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceScanRsltOnResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// Service service processor
//

/// The SWC-DB Thrift Service
pub trait ServiceSyncHandler {
  /// The direct SQL method to Manage Column.
  fn handle_sql_mng_column(&self, sql: String) -> thrift::Result<()>;
  /// The direct SQL method to List Columns
  fn handle_sql_list_columns(&self, sql: String) -> thrift::Result<Schemas>;
  /// The direct SQL method to Compact Columns
  fn handle_sql_compact_columns(&self, sql: String) -> thrift::Result<CompactResults>;
  /// The direct SQL method to select cells with result in Cells List.
  fn handle_sql_select(&self, sql: String) -> thrift::Result<Cells>;
  /// The direct SQL method to select cells with result in Columns Cells map.
  fn handle_sql_select_rslt_on_column(&self, sql: String) -> thrift::Result<CCells>;
  /// The direct SQL method to select cells with result in Key Cells list.
  fn handle_sql_select_rslt_on_key(&self, sql: String) -> thrift::Result<KCells>;
  /// The direct SQL method to select cells with result in Fractons Cells.
  fn handle_sql_select_rslt_on_fraction(&self, sql: String) -> thrift::Result<FCells>;
  /// The SQL method to select cells with result set by the request's type of CellsResult.
  fn handle_sql_query(&self, sql: String, rslt: CellsResult) -> thrift::Result<CellsGroup>;
  /// The direct SQL method to update cells optionally to work with updater-id.
  fn handle_sql_update(&self, sql: String, updater_id: i64) -> thrift::Result<()>;
  /// The SQL method to execute any query.
  fn handle_exec_sql(&self, sql: String) -> thrift::Result<Result>;
  /// The method to Create an Updater ID with buffering size in bytes.
  fn handle_updater_create(&self, buffer_size: i32) -> thrift::Result<i64>;
  /// The method to Close an Updater ID.
  fn handle_updater_close(&self, id: i64) -> thrift::Result<()>;
  /// The direct method to update cells with cell in Update-Columns-Cells,
  /// optionally to work with updater-id.
  fn handle_update(&self, cells: UCCells, updater_id: i64) -> thrift::Result<()>;
  /// The direct method to update cells with cell in Update-Columns-Cells-Serial,
  /// optionally to work with updater-id.
  fn handle_update_serial(&self, cells: UCCellsSerial, updater_id: i64) -> thrift::Result<()>;
  /// The direct method to Manage Column
  fn handle_mng_column(&self, func: SchemaFunc, schema: Schema) -> thrift::Result<()>;
  /// The direct method to List Columns
  fn handle_list_columns(&self, spec: SpecSchemas) -> thrift::Result<Schemas>;
  /// The direct method to Compact Columns
  fn handle_compact_columns(&self, spec: SpecSchemas) -> thrift::Result<CompactResults>;
  /// The direct method to select cells with result in Cells List.
  fn handle_scan(&self, spec: SpecScan) -> thrift::Result<Cells>;
  /// The direct method to select cells with result in Columns Cells map.
  fn handle_scan_rslt_on_column(&self, spec: SpecScan) -> thrift::Result<CCells>;
  /// The direct method to select cells with result in Key Cells list.
  fn handle_scan_rslt_on_key(&self, spec: SpecScan) -> thrift::Result<KCells>;
  /// The direct method to select cells with result in Fractons Cells.
  fn handle_scan_rslt_on_fraction(&self, spec: SpecScan) -> thrift::Result<FCells>;
  /// The method to select cells with result set by the request's type of CellsResult.
  fn handle_scan_rslt_on(&self, spec: SpecScan, rslt: CellsResult) -> thrift::Result<CellsGroup>;
}

pub struct ServiceSyncProcessor<H: ServiceSyncHandler> {
  handler: H,
}

impl <H: ServiceSyncHandler> ServiceSyncProcessor<H> {
  pub fn new(handler: H) -> ServiceSyncProcessor<H> {
    ServiceSyncProcessor {
      handler,
    }
  }
  fn process_sql_mng_column(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_mng_column(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_list_columns(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_list_columns(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_compact_columns(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_compact_columns(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_select(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_select(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_select_rslt_on_column(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_select_rslt_on_column(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_select_rslt_on_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_select_rslt_on_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_select_rslt_on_fraction(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_select_rslt_on_fraction(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_query(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_query(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_update(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_update(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_exec_sql(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_exec_sql(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_updater_create(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_updater_create(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_updater_close(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_updater_close(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_update(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_serial(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_update_serial(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_mng_column(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_mng_column(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_columns(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_list_columns(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_compact_columns(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_compact_columns(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_scan(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_scan(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_scan_rslt_on_column(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_scan_rslt_on_column(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_scan_rslt_on_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_scan_rslt_on_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_scan_rslt_on_fraction(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_scan_rslt_on_fraction(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_scan_rslt_on(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_scan_rslt_on(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TServiceProcessFunctions;

impl TServiceProcessFunctions {
  pub fn process_sql_mng_column<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlMngColumnArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_mng_column(args.sql) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("sql_mng_column", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlMngColumnResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlMngColumnResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_mng_column", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_mng_column", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_mng_column", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_mng_column", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_list_columns<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlListColumnsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_list_columns(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_list_columns", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlListColumnsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlListColumnsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_list_columns", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_list_columns", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_list_columns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_list_columns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_compact_columns<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlCompactColumnsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_compact_columns(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_compact_columns", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlCompactColumnsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlCompactColumnsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_compact_columns", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_compact_columns", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_compact_columns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_compact_columns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_select<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlSelectArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_select(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_select", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlSelectResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlSelectResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_select", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_select", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_select", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_select", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_select_rslt_on_column<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlSelectRsltOnColumnArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_select_rslt_on_column(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_select_rslt_on_column", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlSelectRsltOnColumnResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlSelectRsltOnColumnResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_select_rslt_on_column", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_select_rslt_on_column", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_select_rslt_on_column", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_select_rslt_on_column", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_select_rslt_on_key<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlSelectRsltOnKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_select_rslt_on_key(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_select_rslt_on_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlSelectRsltOnKeyResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlSelectRsltOnKeyResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_select_rslt_on_key", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_select_rslt_on_key", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_select_rslt_on_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_select_rslt_on_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_select_rslt_on_fraction<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlSelectRsltOnFractionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_select_rslt_on_fraction(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_select_rslt_on_fraction", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlSelectRsltOnFractionResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlSelectRsltOnFractionResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_select_rslt_on_fraction", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_select_rslt_on_fraction", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_select_rslt_on_fraction", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_select_rslt_on_fraction", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_query<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlQueryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_query(args.sql, args.rslt) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_query", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlQueryResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlQueryResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_query", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_query", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_update<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlUpdateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_update(args.sql, args.updater_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("sql_update", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlUpdateResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlUpdateResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_update", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_update", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_exec_sql<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceExecSqlArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_exec_sql(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("exec_sql", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceExecSqlResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceExecSqlResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("exec_sql", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("exec_sql", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("exec_sql", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("exec_sql", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_updater_create<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceUpdaterCreateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_updater_create(args.buffer_size) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("updater_create", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceUpdaterCreateResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceUpdaterCreateResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updater_create", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updater_create", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updater_create", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updater_create", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_updater_close<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceUpdaterCloseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_updater_close(args.id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updater_close", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceUpdaterCloseResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceUpdaterCloseResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updater_close", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("updater_close", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updater_close", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("updater_close", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceUpdateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update(args.cells, args.updater_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("update", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceUpdateResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceUpdateResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("update", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("update", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_serial<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceUpdateSerialArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_serial(args.cells, args.updater_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("update_serial", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceUpdateSerialResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceUpdateSerialResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("update_serial", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("update_serial", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("update_serial", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("update_serial", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_mng_column<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceMngColumnArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_mng_column(args.func, args.schema) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("mng_column", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceMngColumnResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceMngColumnResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("mng_column", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("mng_column", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("mng_column", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("mng_column", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_columns<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceListColumnsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_columns(args.spec) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("list_columns", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceListColumnsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceListColumnsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("list_columns", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("list_columns", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("list_columns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("list_columns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_compact_columns<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceCompactColumnsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_compact_columns(args.spec) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("compact_columns", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceCompactColumnsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceCompactColumnsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("compact_columns", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("compact_columns", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("compact_columns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("compact_columns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_scan<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceScanArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_scan(args.spec) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("scan", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceScanResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceScanResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("scan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("scan", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("scan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("scan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_scan_rslt_on_column<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceScanRsltOnColumnArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_scan_rslt_on_column(args.spec) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("scan_rslt_on_column", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceScanRsltOnColumnResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceScanRsltOnColumnResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("scan_rslt_on_column", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("scan_rslt_on_column", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("scan_rslt_on_column", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("scan_rslt_on_column", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_scan_rslt_on_key<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceScanRsltOnKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_scan_rslt_on_key(args.spec) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("scan_rslt_on_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceScanRsltOnKeyResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceScanRsltOnKeyResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("scan_rslt_on_key", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("scan_rslt_on_key", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("scan_rslt_on_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("scan_rslt_on_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_scan_rslt_on_fraction<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceScanRsltOnFractionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_scan_rslt_on_fraction(args.spec) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("scan_rslt_on_fraction", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceScanRsltOnFractionResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceScanRsltOnFractionResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("scan_rslt_on_fraction", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("scan_rslt_on_fraction", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("scan_rslt_on_fraction", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("scan_rslt_on_fraction", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_scan_rslt_on<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceScanRsltOnArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_scan_rslt_on(args.spec, args.rslt) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("scan_rslt_on", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceScanRsltOnResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceScanRsltOnResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("scan_rslt_on", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("scan_rslt_on", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("scan_rslt_on", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("scan_rslt_on", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: ServiceSyncHandler> TProcessor for ServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "sql_mng_column" => {
        self.process_sql_mng_column(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_list_columns" => {
        self.process_sql_list_columns(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_compact_columns" => {
        self.process_sql_compact_columns(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_select" => {
        self.process_sql_select(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_select_rslt_on_column" => {
        self.process_sql_select_rslt_on_column(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_select_rslt_on_key" => {
        self.process_sql_select_rslt_on_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_select_rslt_on_fraction" => {
        self.process_sql_select_rslt_on_fraction(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_query" => {
        self.process_sql_query(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_update" => {
        self.process_sql_update(message_ident.sequence_number, i_prot, o_prot)
      },
      "exec_sql" => {
        self.process_exec_sql(message_ident.sequence_number, i_prot, o_prot)
      },
      "updater_create" => {
        self.process_updater_create(message_ident.sequence_number, i_prot, o_prot)
      },
      "updater_close" => {
        self.process_updater_close(message_ident.sequence_number, i_prot, o_prot)
      },
      "update" => {
        self.process_update(message_ident.sequence_number, i_prot, o_prot)
      },
      "update_serial" => {
        self.process_update_serial(message_ident.sequence_number, i_prot, o_prot)
      },
      "mng_column" => {
        self.process_mng_column(message_ident.sequence_number, i_prot, o_prot)
      },
      "list_columns" => {
        self.process_list_columns(message_ident.sequence_number, i_prot, o_prot)
      },
      "compact_columns" => {
        self.process_compact_columns(message_ident.sequence_number, i_prot, o_prot)
      },
      "scan" => {
        self.process_scan(message_ident.sequence_number, i_prot, o_prot)
      },
      "scan_rslt_on_column" => {
        self.process_scan_rslt_on_column(message_ident.sequence_number, i_prot, o_prot)
      },
      "scan_rslt_on_key" => {
        self.process_scan_rslt_on_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "scan_rslt_on_fraction" => {
        self.process_scan_rslt_on_fraction(message_ident.sequence_number, i_prot, o_prot)
      },
      "scan_rslt_on" => {
        self.process_scan_rslt_on(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// ServiceSqlMngColumnArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlMngColumnArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlMngColumnArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlMngColumnArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlMngColumnArgs.sql", &f_1)?;
    let ret = ServiceSqlMngColumnArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_mng_column_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlMngColumnResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlMngColumnResult {
  e: Option<Exception>,
}

impl ServiceSqlMngColumnResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlMngColumnResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlMngColumnResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlMngColumnResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ServiceSqlListColumnsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlListColumnsArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlListColumnsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlListColumnsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlListColumnsArgs.sql", &f_1)?;
    let ret = ServiceSqlListColumnsArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_list_columns_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlListColumnsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlListColumnsResult {
  result_value: Option<Schemas>,
  e: Option<Exception>,
}

impl ServiceSqlListColumnsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlListColumnsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Schemas> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Schema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_55 = Schema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_55);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlListColumnsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlListColumnsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Schemas> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlListColumns"
          )
        )
      )
    }
  }
}

//
// ServiceSqlCompactColumnsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlCompactColumnsArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlCompactColumnsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlCompactColumnsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlCompactColumnsArgs.sql", &f_1)?;
    let ret = ServiceSqlCompactColumnsArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_compact_columns_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlCompactColumnsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlCompactColumnsResult {
  result_value: Option<CompactResults>,
  e: Option<Exception>,
}

impl ServiceSqlCompactColumnsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlCompactColumnsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CompactResults> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CompactResult> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_56 = CompactResult::read_from_in_protocol(i_prot)?;
            val.push(list_elem_56);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlCompactColumnsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlCompactColumnsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<CompactResults> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlCompactColumns"
          )
        )
      )
    }
  }
}

//
// ServiceSqlSelectArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlSelectArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlSelectArgs.sql", &f_1)?;
    let ret = ServiceSqlSelectArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_select_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectResult {
  result_value: Option<Cells>,
  e: Option<Exception>,
}

impl ServiceSqlSelectResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Cells> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Cells::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlSelectResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlSelectResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Cells> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlSelect"
          )
        )
      )
    }
  }
}

//
// ServiceSqlSelectRsltOnColumnArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectRsltOnColumnArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlSelectRsltOnColumnArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectRsltOnColumnArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlSelectRsltOnColumnArgs.sql", &f_1)?;
    let ret = ServiceSqlSelectRsltOnColumnArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_select_rslt_on_column_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectRsltOnColumnResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectRsltOnColumnResult {
  result_value: Option<CCells>,
  e: Option<Exception>,
}

impl ServiceSqlSelectRsltOnColumnResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectRsltOnColumnResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CCells> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, ColCells> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_57 = i_prot.read_string()?;
            let map_val_58 = ColCells::read_from_in_protocol(i_prot)?;
            val.insert(map_key_57, map_val_58);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlSelectRsltOnColumnResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlSelectRsltOnColumnResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<CCells> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlSelectRsltOnColumn"
          )
        )
      )
    }
  }
}

//
// ServiceSqlSelectRsltOnKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectRsltOnKeyArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlSelectRsltOnKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectRsltOnKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlSelectRsltOnKeyArgs.sql", &f_1)?;
    let ret = ServiceSqlSelectRsltOnKeyArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_select_rslt_on_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectRsltOnKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectRsltOnKeyResult {
  result_value: Option<KCells>,
  e: Option<Exception>,
}

impl ServiceSqlSelectRsltOnKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectRsltOnKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<KCells> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<KCells> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_59 = KCells::read_from_in_protocol(i_prot)?;
            val.push(list_elem_59);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlSelectRsltOnKeyResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlSelectRsltOnKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<KCells> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlSelectRsltOnKey"
          )
        )
      )
    }
  }
}

//
// ServiceSqlSelectRsltOnFractionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectRsltOnFractionArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlSelectRsltOnFractionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectRsltOnFractionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlSelectRsltOnFractionArgs.sql", &f_1)?;
    let ret = ServiceSqlSelectRsltOnFractionArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_select_rslt_on_fraction_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectRsltOnFractionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectRsltOnFractionResult {
  result_value: Option<FCells>,
  e: Option<Exception>,
}

impl ServiceSqlSelectRsltOnFractionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectRsltOnFractionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FCells> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FCells::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlSelectRsltOnFractionResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlSelectRsltOnFractionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<FCells> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlSelectRsltOnFraction"
          )
        )
      )
    }
  }
}

//
// ServiceSqlQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlQueryArgs {
  /// The SQL string to Execute
  sql: String,
  /// The Type of Cells Result for the response
  rslt: CellsResult,
}

impl ServiceSqlQueryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlQueryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<CellsResult> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = CellsResult::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlQueryArgs.sql", &f_1)?;
    verify_required_field_exists("ServiceSqlQueryArgs.rslt", &f_2)?;
    let ret = ServiceSqlQueryArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
      rslt: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_query_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rslt", TType::I32, 2))?;
    self.rslt.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlQueryResult {
  result_value: Option<CellsGroup>,
  e: Option<Exception>,
}

impl ServiceSqlQueryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CellsGroup> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = CellsGroup::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlQueryResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<CellsGroup> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlQuery"
          )
        )
      )
    }
  }
}

//
// ServiceSqlUpdateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlUpdateArgs {
  /// The SQL string to Execute
  sql: String,
  /// The Updater ID to work with
  updater_id: i64,
}

impl ServiceSqlUpdateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlUpdateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlUpdateArgs.sql", &f_1)?;
    verify_required_field_exists("ServiceSqlUpdateArgs.updater_id", &f_2)?;
    let ret = ServiceSqlUpdateArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
      updater_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_update_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("updater_id", TType::I64, 2))?;
    o_prot.write_i64(self.updater_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlUpdateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlUpdateResult {
  e: Option<Exception>,
}

impl ServiceSqlUpdateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlUpdateResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlUpdateResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlUpdateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ServiceExecSqlArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceExecSqlArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceExecSqlArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceExecSqlArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceExecSqlArgs.sql", &f_1)?;
    let ret = ServiceExecSqlArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("exec_sql_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceExecSqlResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceExecSqlResult {
  result_value: Option<Result>,
  e: Option<Exception>,
}

impl ServiceExecSqlResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceExecSqlResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Result> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Result::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceExecSqlResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceExecSqlResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Result> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceExecSql"
          )
        )
      )
    }
  }
}

//
// ServiceUpdaterCreateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdaterCreateArgs {
  /// The buffer size of the Updater
  buffer_size: i32,
}

impl ServiceUpdaterCreateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdaterCreateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceUpdaterCreateArgs.buffer_size", &f_1)?;
    let ret = ServiceUpdaterCreateArgs {
      buffer_size: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updater_create_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("buffer_size", TType::I32, 1))?;
    o_prot.write_i32(self.buffer_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceUpdaterCreateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdaterCreateResult {
  result_value: Option<i64>,
  e: Option<Exception>,
}

impl ServiceUpdaterCreateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdaterCreateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceUpdaterCreateResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceUpdaterCreateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceUpdaterCreate"
          )
        )
      )
    }
  }
}

//
// ServiceUpdaterCloseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdaterCloseArgs {
  /// The Updater ID to close
  id: i64,
}

impl ServiceUpdaterCloseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdaterCloseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceUpdaterCloseArgs.id", &f_1)?;
    let ret = ServiceUpdaterCloseArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updater_close_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
    o_prot.write_i64(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceUpdaterCloseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdaterCloseResult {
  e: Option<Exception>,
}

impl ServiceUpdaterCloseResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdaterCloseResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceUpdaterCloseResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceUpdaterCloseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ServiceUpdateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdateArgs {
  /// The Cells to update
  cells: UCCells,
  /// The Updater ID to use for write
  updater_id: i64,
}

impl ServiceUpdateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<UCCells> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i64, UCells> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_60 = i_prot.read_i64()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_61: Vec<UCell> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_62 = UCell::read_from_in_protocol(i_prot)?;
              map_val_61.push(list_elem_62);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_60, map_val_61);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceUpdateArgs.cells", &f_1)?;
    verify_required_field_exists("ServiceUpdateArgs.updater_id", &f_2)?;
    let ret = ServiceUpdateArgs {
      cells: f_1.expect("auto-generated code should have checked for presence of required fields"),
      updater_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("update_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cells", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::I64, TType::List, self.cells.len() as i32))?;
    for (k, v) in &self.cells {
      o_prot.write_i64(*k)?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
      for e in v {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("updater_id", TType::I64, 2))?;
    o_prot.write_i64(self.updater_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceUpdateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdateResult {
  e: Option<Exception>,
}

impl ServiceUpdateResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdateResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceUpdateResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceUpdateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ServiceUpdateSerialArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdateSerialArgs {
  /// The Serial Cells to update
  cells: UCCellsSerial,
  /// The Updater ID to use for write
  updater_id: i64,
}

impl ServiceUpdateSerialArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdateSerialArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<UCCellsSerial> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i64, UCellsSerial> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_63 = i_prot.read_i64()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_64: Vec<UCellSerial> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_65 = UCellSerial::read_from_in_protocol(i_prot)?;
              map_val_64.push(list_elem_65);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_63, map_val_64);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceUpdateSerialArgs.cells", &f_1)?;
    verify_required_field_exists("ServiceUpdateSerialArgs.updater_id", &f_2)?;
    let ret = ServiceUpdateSerialArgs {
      cells: f_1.expect("auto-generated code should have checked for presence of required fields"),
      updater_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("update_serial_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cells", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::I64, TType::List, self.cells.len() as i32))?;
    for (k, v) in &self.cells {
      o_prot.write_i64(*k)?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
      for e in v {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("updater_id", TType::I64, 2))?;
    o_prot.write_i64(self.updater_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceUpdateSerialResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdateSerialResult {
  e: Option<Exception>,
}

impl ServiceUpdateSerialResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdateSerialResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceUpdateSerialResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceUpdateSerialResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ServiceMngColumnArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceMngColumnArgs {
  /// The Action Function to use
  func: SchemaFunc,
  /// The Schema for the Action
  schema: Schema,
}

impl ServiceMngColumnArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceMngColumnArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SchemaFunc> = None;
    let mut f_2: Option<Schema> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SchemaFunc::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Schema::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceMngColumnArgs.func", &f_1)?;
    verify_required_field_exists("ServiceMngColumnArgs.schema", &f_2)?;
    let ret = ServiceMngColumnArgs {
      func: f_1.expect("auto-generated code should have checked for presence of required fields"),
      schema: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("mng_column_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("func", TType::I32, 1))?;
    self.func.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("schema", TType::Struct, 2))?;
    self.schema.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceMngColumnResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceMngColumnResult {
  e: Option<Exception>,
}

impl ServiceMngColumnResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceMngColumnResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceMngColumnResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceMngColumnResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
}

//
// ServiceListColumnsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceListColumnsArgs {
  /// The Schemas Specifications to match Schema for response
  spec: SpecSchemas,
}

impl ServiceListColumnsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceListColumnsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SpecSchemas> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SpecSchemas::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceListColumnsArgs.spec", &f_1)?;
    let ret = ServiceListColumnsArgs {
      spec: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("list_columns_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spec", TType::Struct, 1))?;
    self.spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceListColumnsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceListColumnsResult {
  result_value: Option<Schemas>,
  e: Option<Exception>,
}

impl ServiceListColumnsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceListColumnsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Schemas> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Schema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_66 = Schema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_66);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceListColumnsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceListColumnsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Schemas> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceListColumns"
          )
        )
      )
    }
  }
}

//
// ServiceCompactColumnsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceCompactColumnsArgs {
  /// The Schemas Specifications to match columns to Compact
  spec: SpecSchemas,
}

impl ServiceCompactColumnsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceCompactColumnsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SpecSchemas> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SpecSchemas::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceCompactColumnsArgs.spec", &f_1)?;
    let ret = ServiceCompactColumnsArgs {
      spec: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("compact_columns_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spec", TType::Struct, 1))?;
    self.spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceCompactColumnsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceCompactColumnsResult {
  result_value: Option<CompactResults>,
  e: Option<Exception>,
}

impl ServiceCompactColumnsResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceCompactColumnsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CompactResults> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CompactResult> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_67 = CompactResult::read_from_in_protocol(i_prot)?;
            val.push(list_elem_67);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceCompactColumnsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceCompactColumnsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<CompactResults> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceCompactColumns"
          )
        )
      )
    }
  }
}

//
// ServiceScanArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanArgs {
  /// The Scan Specifications for the scan
  spec: SpecScan,
}

impl ServiceScanArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SpecScan> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SpecScan::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceScanArgs.spec", &f_1)?;
    let ret = ServiceScanArgs {
      spec: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("scan_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spec", TType::Struct, 1))?;
    self.spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceScanResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanResult {
  result_value: Option<Cells>,
  e: Option<Exception>,
}

impl ServiceScanResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Cells> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Cells::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceScanResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceScanResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Cells> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceScan"
          )
        )
      )
    }
  }
}

//
// ServiceScanRsltOnColumnArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanRsltOnColumnArgs {
  /// The Scan Specifications for the scan
  spec: SpecScan,
}

impl ServiceScanRsltOnColumnArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanRsltOnColumnArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SpecScan> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SpecScan::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceScanRsltOnColumnArgs.spec", &f_1)?;
    let ret = ServiceScanRsltOnColumnArgs {
      spec: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("scan_rslt_on_column_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spec", TType::Struct, 1))?;
    self.spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceScanRsltOnColumnResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanRsltOnColumnResult {
  result_value: Option<CCells>,
  e: Option<Exception>,
}

impl ServiceScanRsltOnColumnResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanRsltOnColumnResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CCells> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, ColCells> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_68 = i_prot.read_string()?;
            let map_val_69 = ColCells::read_from_in_protocol(i_prot)?;
            val.insert(map_key_68, map_val_69);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceScanRsltOnColumnResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceScanRsltOnColumnResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<CCells> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceScanRsltOnColumn"
          )
        )
      )
    }
  }
}

//
// ServiceScanRsltOnKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanRsltOnKeyArgs {
  /// The Scan Specifications for the scan
  spec: SpecScan,
}

impl ServiceScanRsltOnKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanRsltOnKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SpecScan> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SpecScan::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceScanRsltOnKeyArgs.spec", &f_1)?;
    let ret = ServiceScanRsltOnKeyArgs {
      spec: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("scan_rslt_on_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spec", TType::Struct, 1))?;
    self.spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceScanRsltOnKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanRsltOnKeyResult {
  result_value: Option<KCells>,
  e: Option<Exception>,
}

impl ServiceScanRsltOnKeyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanRsltOnKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<KCells> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<KCells> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_70 = KCells::read_from_in_protocol(i_prot)?;
            val.push(list_elem_70);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceScanRsltOnKeyResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceScanRsltOnKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<KCells> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceScanRsltOnKey"
          )
        )
      )
    }
  }
}

//
// ServiceScanRsltOnFractionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanRsltOnFractionArgs {
  /// The Scan Specifications for the scan
  spec: SpecScan,
}

impl ServiceScanRsltOnFractionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanRsltOnFractionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SpecScan> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SpecScan::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceScanRsltOnFractionArgs.spec", &f_1)?;
    let ret = ServiceScanRsltOnFractionArgs {
      spec: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("scan_rslt_on_fraction_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spec", TType::Struct, 1))?;
    self.spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceScanRsltOnFractionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanRsltOnFractionResult {
  result_value: Option<FCells>,
  e: Option<Exception>,
}

impl ServiceScanRsltOnFractionResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanRsltOnFractionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FCells> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FCells::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceScanRsltOnFractionResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceScanRsltOnFractionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<FCells> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceScanRsltOnFraction"
          )
        )
      )
    }
  }
}

//
// ServiceScanRsltOnArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanRsltOnArgs {
  /// The Scan Specifications for the scan
  spec: SpecScan,
  /// The Type of Cells Result for the response
  rslt: CellsResult,
}

impl ServiceScanRsltOnArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanRsltOnArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SpecScan> = None;
    let mut f_2: Option<CellsResult> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SpecScan::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = CellsResult::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceScanRsltOnArgs.spec", &f_1)?;
    verify_required_field_exists("ServiceScanRsltOnArgs.rslt", &f_2)?;
    let ret = ServiceScanRsltOnArgs {
      spec: f_1.expect("auto-generated code should have checked for presence of required fields"),
      rslt: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("scan_rslt_on_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spec", TType::Struct, 1))?;
    self.spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rslt", TType::I32, 2))?;
    self.rslt.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceScanRsltOnResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanRsltOnResult {
  result_value: Option<CellsGroup>,
  /// The Base Exception
  e: Option<Exception>,
}

impl ServiceScanRsltOnResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanRsltOnResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CellsGroup> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = CellsGroup::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceScanRsltOnResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceScanRsltOnResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<CellsGroup> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceScanRsltOn"
          )
        )
      )
    }
  }
}

