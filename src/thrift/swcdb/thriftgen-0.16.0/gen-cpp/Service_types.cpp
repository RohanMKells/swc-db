/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Service_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace SWC { namespace Thrift {

int _kKeySeqValues[] = {
  /**
   * Unknown/Unrecognized Type
   */
  KeySeq::UNKNOWN,
  /**
   * The Lexical Key Order Sequence
   */
  KeySeq::LEXIC,
  /**
   * The Volumetric Key Order Sequence
   */
  KeySeq::VOLUME,
  /**
   * The by Fractions Count on Lexical Key Order Sequence
   */
  KeySeq::FC_LEXIC,
  /**
   * The by Fractions Count on Volumetric Key Order Sequence
   */
  KeySeq::FC_VOLUME
};
const char* _kKeySeqNames[] = {
  /**
   * Unknown/Unrecognized Type
   */
  "UNKNOWN",
  /**
   * The Lexical Key Order Sequence
   */
  "LEXIC",
  /**
   * The Volumetric Key Order Sequence
   */
  "VOLUME",
  /**
   * The by Fractions Count on Lexical Key Order Sequence
   */
  "FC_LEXIC",
  /**
   * The by Fractions Count on Volumetric Key Order Sequence
   */
  "FC_VOLUME"
};
const std::map<int, const char*> _KeySeq_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kKeySeqValues, _kKeySeqNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const KeySeq::type& val) {
  std::map<int, const char*>::const_iterator it = _KeySeq_VALUES_TO_NAMES.find(val);
  if (it != _KeySeq_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const KeySeq::type& val) {
  std::map<int, const char*>::const_iterator it = _KeySeq_VALUES_TO_NAMES.find(val);
  if (it != _KeySeq_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kColumnTypeValues[] = {
  /**
   * Unknown/Unrecognized Type
   */
  ColumnType::UNKNOWN,
  /**
   * A Plain Column Value
   */
  ColumnType::PLAIN,
  /**
   * A Counter Column Value with integrity of signed-64bit
   */
  ColumnType::COUNTER_I64,
  /**
   * A Counter Column Value with integrity of signed-32bit
   */
  ColumnType::COUNTER_I32,
  /**
   * A Counter Column Value with integrity of signed-16bit
   */
  ColumnType::COUNTER_I16,
  /**
   * A Counter Column Value with integrity of signed-8bit
   */
  ColumnType::COUNTER_I8,
  /**
   * A Serial Column Value
   */
  ColumnType::SERIAL,
  /**
   * Not used - experimental
   */
  ColumnType::CELL_DEFINED
};
const char* _kColumnTypeNames[] = {
  /**
   * Unknown/Unrecognized Type
   */
  "UNKNOWN",
  /**
   * A Plain Column Value
   */
  "PLAIN",
  /**
   * A Counter Column Value with integrity of signed-64bit
   */
  "COUNTER_I64",
  /**
   * A Counter Column Value with integrity of signed-32bit
   */
  "COUNTER_I32",
  /**
   * A Counter Column Value with integrity of signed-16bit
   */
  "COUNTER_I16",
  /**
   * A Counter Column Value with integrity of signed-8bit
   */
  "COUNTER_I8",
  /**
   * A Serial Column Value
   */
  "SERIAL",
  /**
   * Not used - experimental
   */
  "CELL_DEFINED"
};
const std::map<int, const char*> _ColumnType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kColumnTypeValues, _kColumnTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ColumnType::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnType_VALUES_TO_NAMES.find(val);
  if (it != _ColumnType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ColumnType::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnType_VALUES_TO_NAMES.find(val);
  if (it != _ColumnType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kEncodingTypeValues[] = {
  /**
   * Encoding by Ranger DEFAULT configurations
   */
  EncodingType::DEFAULT,
  /**
   * No Encoding
   */
  EncodingType::PLAIN,
  /**
   * Encode with zlib
   */
  EncodingType::ZLIB,
  /**
   * Encode with snappy
   */
  EncodingType::SNAPPY,
  /**
   * Encode with zstandard
   */
  EncodingType::ZSTD,
  /**
   * Unrecognized Type
   */
  EncodingType::UNKNOWN
};
const char* _kEncodingTypeNames[] = {
  /**
   * Encoding by Ranger DEFAULT configurations
   */
  "DEFAULT",
  /**
   * No Encoding
   */
  "PLAIN",
  /**
   * Encode with zlib
   */
  "ZLIB",
  /**
   * Encode with snappy
   */
  "SNAPPY",
  /**
   * Encode with zstandard
   */
  "ZSTD",
  /**
   * Unrecognized Type
   */
  "UNKNOWN"
};
const std::map<int, const char*> _EncodingType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kEncodingTypeValues, _kEncodingTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const EncodingType::type& val) {
  std::map<int, const char*>::const_iterator it = _EncodingType_VALUES_TO_NAMES.find(val);
  if (it != _EncodingType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const EncodingType::type& val) {
  std::map<int, const char*>::const_iterator it = _EncodingType_VALUES_TO_NAMES.find(val);
  if (it != _EncodingType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSchemaFuncValues[] = {
  /**
   * Create Column Function
   */
  SchemaFunc::CREATE,
  /**
   * Delete Column Function
   */
  SchemaFunc::REMOVE,
  /**
   * Modify Column Function
   */
  SchemaFunc::MODIFY
};
const char* _kSchemaFuncNames[] = {
  /**
   * Create Column Function
   */
  "CREATE",
  /**
   * Delete Column Function
   */
  "REMOVE",
  /**
   * Modify Column Function
   */
  "MODIFY"
};
const std::map<int, const char*> _SchemaFunc_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kSchemaFuncValues, _kSchemaFuncNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SchemaFunc::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaFunc_VALUES_TO_NAMES.find(val);
  if (it != _SchemaFunc_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SchemaFunc::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaFunc_VALUES_TO_NAMES.find(val);
  if (it != _SchemaFunc_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCompValues[] = {
  /**
   * [         ]  :   none               (no comparison applied)
   */
  Comp::NONE,
  /**
   * [  =^     ]  :   -pf [prefix]       (starts-with)
   */
  Comp::PF,
  /**
   * [ &gt;    ]  :   -gt                (greater-than)
   */
  Comp::GT,
  /**
   * [ &gt;=   ]  :   -ge                (greater-equal)
   */
  Comp::GE,
  /**
   * [  =      ]  :   -eq                (equal)
   */
  Comp::EQ,
  /**
   * [ &lt;=   ]  :   -le                (lower-equal)
   */
  Comp::LE,
  /**
   * [ &lt;    ]  :   -lt                (lower-than)
   */
  Comp::LT,
  /**
   * [  !=     ]  :   -ne                (not-equal)
   */
  Comp::NE,
  /**
   * [  re     ]  :   -re [r,regexp]     (regular-expression)
   */
  Comp::RE,
  /**
   * [ v&gt;   ]  :   -vgt               (vol greater-than)
   */
  Comp::VGT,
  /**
   * [ v&gt;=  ]  :   -vge               (vol greater-equal)
   */
  Comp::VGE,
  /**
   * [ v&lt;=  ]  :   -vle               (vol lower-equal)
   */
  Comp::VLE,
  /**
   * [ v&lt;   ]  :   -vlt               (vol lower-than)
   */
  Comp::VLT,
  /**
   * [ %&gt;   ]  :   -subset [sbs]      (subset)
   */
  Comp::SBS,
  /**
   * [ &lt;%   ]  :   -supset [sps]      (superset)
   */
  Comp::SPS,
  /**
   * [ ~&gt;   ]  :   -posubset [posbs]  (eq/part ordered subset)
   */
  Comp::POSBS,
  /**
   * [ &lt;~   ]  :   -posupset [posps]  (eq/part ordered superset)
   */
  Comp::POSPS,
  /**
   * [ -&gt;   ]  :   -fosubset [fosbs]  (eq/full ordered subset)
   */
  Comp::FOSBS,
  /**
   * [ &lt;-   ]  :   -fosupset [fosps]  (eq/full ordered superset)
   */
  Comp::FOSPS,
  /**
   * [ :&lt;   ]  :   -fip  (fraction include prior)
   */
  Comp::FIP,
  /**
   * [ :       ]  :   -fi   (fraction include)
   */
  Comp::FI
};
const char* _kCompNames[] = {
  /**
   * [         ]  :   none               (no comparison applied)
   */
  "NONE",
  /**
   * [  =^     ]  :   -pf [prefix]       (starts-with)
   */
  "PF",
  /**
   * [ &gt;    ]  :   -gt                (greater-than)
   */
  "GT",
  /**
   * [ &gt;=   ]  :   -ge                (greater-equal)
   */
  "GE",
  /**
   * [  =      ]  :   -eq                (equal)
   */
  "EQ",
  /**
   * [ &lt;=   ]  :   -le                (lower-equal)
   */
  "LE",
  /**
   * [ &lt;    ]  :   -lt                (lower-than)
   */
  "LT",
  /**
   * [  !=     ]  :   -ne                (not-equal)
   */
  "NE",
  /**
   * [  re     ]  :   -re [r,regexp]     (regular-expression)
   */
  "RE",
  /**
   * [ v&gt;   ]  :   -vgt               (vol greater-than)
   */
  "VGT",
  /**
   * [ v&gt;=  ]  :   -vge               (vol greater-equal)
   */
  "VGE",
  /**
   * [ v&lt;=  ]  :   -vle               (vol lower-equal)
   */
  "VLE",
  /**
   * [ v&lt;   ]  :   -vlt               (vol lower-than)
   */
  "VLT",
  /**
   * [ %&gt;   ]  :   -subset [sbs]      (subset)
   */
  "SBS",
  /**
   * [ &lt;%   ]  :   -supset [sps]      (superset)
   */
  "SPS",
  /**
   * [ ~&gt;   ]  :   -posubset [posbs]  (eq/part ordered subset)
   */
  "POSBS",
  /**
   * [ &lt;~   ]  :   -posupset [posps]  (eq/part ordered superset)
   */
  "POSPS",
  /**
   * [ -&gt;   ]  :   -fosubset [fosbs]  (eq/full ordered subset)
   */
  "FOSBS",
  /**
   * [ &lt;-   ]  :   -fosupset [fosps]  (eq/full ordered superset)
   */
  "FOSPS",
  /**
   * [ :&lt;   ]  :   -fip  (fraction include prior)
   */
  "FIP",
  /**
   * [ :       ]  :   -fi   (fraction include)
   */
  "FI"
};
const std::map<int, const char*> _Comp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(21, _kCompValues, _kCompNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Comp::type& val) {
  std::map<int, const char*>::const_iterator it = _Comp_VALUES_TO_NAMES.find(val);
  if (it != _Comp_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Comp::type& val) {
  std::map<int, const char*>::const_iterator it = _Comp_VALUES_TO_NAMES.find(val);
  if (it != _Comp_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSpecFlagsOptValues[] = {
  /**
   * No Flag Applied
   */
  SpecFlagsOpt::NONE,
  /**
   * Cells Limit by Keys
   */
  SpecFlagsOpt::LIMIT_BY_KEYS,
  /**
   * Cells Offset by Keys
   */
  SpecFlagsOpt::OFFSET_BY_KEYS,
  /**
   * Select Cells Only Keys without Value data
   */
  SpecFlagsOpt::ONLY_KEYS,
  /**
   * Select Cells Only with DELETE(cell-flag)
   */
  SpecFlagsOpt::ONLY_DELETES
};
const char* _kSpecFlagsOptNames[] = {
  /**
   * No Flag Applied
   */
  "NONE",
  /**
   * Cells Limit by Keys
   */
  "LIMIT_BY_KEYS",
  /**
   * Cells Offset by Keys
   */
  "OFFSET_BY_KEYS",
  /**
   * Select Cells Only Keys without Value data
   */
  "ONLY_KEYS",
  /**
   * Select Cells Only with DELETE(cell-flag)
   */
  "ONLY_DELETES"
};
const std::map<int, const char*> _SpecFlagsOpt_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kSpecFlagsOptValues, _kSpecFlagsOptNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SpecFlagsOpt::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecFlagsOpt_VALUES_TO_NAMES.find(val);
  if (it != _SpecFlagsOpt_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SpecFlagsOpt::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecFlagsOpt_VALUES_TO_NAMES.find(val);
  if (it != _SpecFlagsOpt_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSpecIntervalOptionsValues[] = {
  /**
   * Update Bit Option
   */
  SpecIntervalOptions::UPDATING,
  /**
   * Delete Bit Option
   */
  SpecIntervalOptions::DELETING
};
const char* _kSpecIntervalOptionsNames[] = {
  /**
   * Update Bit Option
   */
  "UPDATING",
  /**
   * Delete Bit Option
   */
  "DELETING"
};
const std::map<int, const char*> _SpecIntervalOptions_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSpecIntervalOptionsValues, _kSpecIntervalOptionsNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SpecIntervalOptions::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecIntervalOptions_VALUES_TO_NAMES.find(val);
  if (it != _SpecIntervalOptions_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SpecIntervalOptions::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecIntervalOptions_VALUES_TO_NAMES.find(val);
  if (it != _SpecIntervalOptions_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kUpdateOPValues[] = {
  /**
   * The OP supported by column-types: PLAIN, SERIAL, COUNTER. Replaces with the update value (_default as well if other OP not supported by the col-type_)
   */
  UpdateOP::REPLACE,
  /**
   * The OP supported by column-types: PLAIN, SERIAL. Appends the update value to the cell's current
   */
  UpdateOP::APPEND,
  /**
   * The OP supported by column-types: PLAIN, SERIAL. Prepends the update value to the cell's current
   */
  UpdateOP::PREPEND,
  /**
   * The OP supported by column-type PLAIN. Inserts the update value at position in current value (appends if pos above value)
   */
  UpdateOP::INSERT,
  /**
   * The OP supported by column-type PLAIN. Overwrites the current value at position with new value (appends if pos above value)
   */
  UpdateOP::OVERWRITE,
  /**
   * The OP supported by column-type SERIAL. update is done by the inner serial-fields defintions
   */
  UpdateOP::SERIAL
};
const char* _kUpdateOPNames[] = {
  /**
   * The OP supported by column-types: PLAIN, SERIAL, COUNTER. Replaces with the update value (_default as well if other OP not supported by the col-type_)
   */
  "REPLACE",
  /**
   * The OP supported by column-types: PLAIN, SERIAL. Appends the update value to the cell's current
   */
  "APPEND",
  /**
   * The OP supported by column-types: PLAIN, SERIAL. Prepends the update value to the cell's current
   */
  "PREPEND",
  /**
   * The OP supported by column-type PLAIN. Inserts the update value at position in current value (appends if pos above value)
   */
  "INSERT",
  /**
   * The OP supported by column-type PLAIN. Overwrites the current value at position with new value (appends if pos above value)
   */
  "OVERWRITE",
  /**
   * The OP supported by column-type SERIAL. update is done by the inner serial-fields defintions
   */
  "SERIAL"
};
const std::map<int, const char*> _UpdateOP_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kUpdateOPValues, _kUpdateOPNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const UpdateOP::type& val) {
  std::map<int, const char*>::const_iterator it = _UpdateOP_VALUES_TO_NAMES.find(val);
  if (it != _UpdateOP_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const UpdateOP::type& val) {
  std::map<int, const char*>::const_iterator it = _UpdateOP_VALUES_TO_NAMES.find(val);
  if (it != _UpdateOP_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFlagValues[] = {
  /**
   * Unknown/Undefined
   */
  Flag::NONE,
  /**
   * The Cell is an insert
   */
  Flag::INSERT,
  /**
   * The Cell is a delete versions lower-equal
   */
  Flag::DELETE_LE,
  /**
   * The Cell is a  delete version equal
   */
  Flag::DELETE_EQ
};
const char* _kFlagNames[] = {
  /**
   * Unknown/Undefined
   */
  "NONE",
  /**
   * The Cell is an insert
   */
  "INSERT",
  /**
   * The Cell is a delete versions lower-equal
   */
  "DELETE_LE",
  /**
   * The Cell is a  delete version equal
   */
  "DELETE_EQ"
};
const std::map<int, const char*> _Flag_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kFlagValues, _kFlagNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Flag::type& val) {
  std::map<int, const char*>::const_iterator it = _Flag_VALUES_TO_NAMES.find(val);
  if (it != _Flag_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Flag::type& val) {
  std::map<int, const char*>::const_iterator it = _Flag_VALUES_TO_NAMES.find(val);
  if (it != _Flag_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFU_MATH_OPValues[] = {
  /**
   * set field value to the new value
   */
  FU_MATH_OP::EQUAL,
  /**
   * plus new value to field's value (negative number allowed)
   */
  FU_MATH_OP::PLUS,
  /**
   * multiply current value by update value
   */
  FU_MATH_OP::MULTIPLY,
  /**
   * divide current value by the new value (ignored at zero)
   */
  FU_MATH_OP::DIVIDE
};
const char* _kFU_MATH_OPNames[] = {
  /**
   * set field value to the new value
   */
  "EQUAL",
  /**
   * plus new value to field's value (negative number allowed)
   */
  "PLUS",
  /**
   * multiply current value by update value
   */
  "MULTIPLY",
  /**
   * divide current value by the new value (ignored at zero)
   */
  "DIVIDE"
};
const std::map<int, const char*> _FU_MATH_OP_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kFU_MATH_OPValues, _kFU_MATH_OPNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const FU_MATH_OP::type& val) {
  std::map<int, const char*>::const_iterator it = _FU_MATH_OP_VALUES_TO_NAMES.find(val);
  if (it != _FU_MATH_OP_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const FU_MATH_OP::type& val) {
  std::map<int, const char*>::const_iterator it = _FU_MATH_OP_VALUES_TO_NAMES.find(val);
  if (it != _FU_MATH_OP_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFU_LIST_OPValues[] = {
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Replaces with the update value
   */
  FU_LIST_OP::REPLACE,
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Appends the update value to a field value
   */
  FU_LIST_OP::APPEND,
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Prepends the update value to a field value
   */
  FU_LIST_OP::PREPEND,
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Insert the update value at position in a field value (appends if pos above value)
   */
  FU_LIST_OP::INSERT,
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Overwrites a field value at position with new value (appends if pos above value)
   */
  FU_LIST_OP::OVERWRITE,
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Erases the position in a field value
   */
  FU_LIST_OP::ERASE,
  /**
   * Supported by field-types: LIST_BYTES, LIST_INT64. The field value items have CTRL_VALUE_SET/DEL OP
   */
  FU_LIST_OP::BY_UNIQUE,
  /**
   * Supported by field-types: LIST_BYTES, LIST_INT64. The field value items have CTRL_VALUE_SET/DEL OP and Comparator
   */
  FU_LIST_OP::BY_COND,
  /**
   * Supported by field-types: LIST_BYTES, LIST_INT64. The field value is with Postion and OP in items
   */
  FU_LIST_OP::BY_INDEX
};
const char* _kFU_LIST_OPNames[] = {
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Replaces with the update value
   */
  "REPLACE",
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Appends the update value to a field value
   */
  "APPEND",
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Prepends the update value to a field value
   */
  "PREPEND",
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Insert the update value at position in a field value (appends if pos above value)
   */
  "INSERT",
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Overwrites a field value at position with new value (appends if pos above value)
   */
  "OVERWRITE",
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Erases the position in a field value
   */
  "ERASE",
  /**
   * Supported by field-types: LIST_BYTES, LIST_INT64. The field value items have CTRL_VALUE_SET/DEL OP
   */
  "BY_UNIQUE",
  /**
   * Supported by field-types: LIST_BYTES, LIST_INT64. The field value items have CTRL_VALUE_SET/DEL OP and Comparator
   */
  "BY_COND",
  /**
   * Supported by field-types: LIST_BYTES, LIST_INT64. The field value is with Postion and OP in items
   */
  "BY_INDEX"
};
const std::map<int, const char*> _FU_LIST_OP_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kFU_LIST_OPValues, _kFU_LIST_OPNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const FU_LIST_OP::type& val) {
  std::map<int, const char*>::const_iterator it = _FU_LIST_OP_VALUES_TO_NAMES.find(val);
  if (it != _FU_LIST_OP_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const FU_LIST_OP::type& val) {
  std::map<int, const char*>::const_iterator it = _FU_LIST_OP_VALUES_TO_NAMES.find(val);
  if (it != _FU_LIST_OP_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCellsResultValues[] = {
  /**
   * Correspond to result on Cells (Cells in list)
   */
  CellsResult::IN_LIST,
  /**
   * Correspond to result on CCells (Columns Cells)
   */
  CellsResult::ON_COLUMN,
  /**
   * Correspond to result on KCells (Keys Cells)
   */
  CellsResult::ON_KEY,
  /**
   * Correspond to result on FCells (Fraction Cells)
   */
  CellsResult::ON_FRACTION
};
const char* _kCellsResultNames[] = {
  /**
   * Correspond to result on Cells (Cells in list)
   */
  "IN_LIST",
  /**
   * Correspond to result on CCells (Columns Cells)
   */
  "ON_COLUMN",
  /**
   * Correspond to result on KCells (Keys Cells)
   */
  "ON_KEY",
  /**
   * Correspond to result on FCells (Fraction Cells)
   */
  "ON_FRACTION"
};
const std::map<int, const char*> _CellsResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kCellsResultValues, _kCellsResultNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const CellsResult::type& val) {
  std::map<int, const char*>::const_iterator it = _CellsResult_VALUES_TO_NAMES.find(val);
  if (it != _CellsResult_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CellsResult::type& val) {
  std::map<int, const char*>::const_iterator it = _CellsResult_VALUES_TO_NAMES.find(val);
  if (it != _CellsResult_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Exception::~Exception() noexcept {
}


void Exception::__set_code(const int32_t val) {
  this->code = val;
}

void Exception::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const Exception& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Exception::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Exception::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Exception");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Exception &a, Exception &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

Exception::Exception(const Exception& other0) : TException() {
  code = other0.code;
  message = other0.message;
  __isset = other0.__isset;
}
Exception::Exception(Exception&& other1) noexcept : TException() {
  code = other1.code;
  message = std::move(other1.message);
  __isset = other1.__isset;
}
Exception& Exception::operator=(const Exception& other2) {
  code = other2.code;
  message = other2.message;
  __isset = other2.__isset;
  return *this;
}
Exception& Exception::operator=(Exception&& other3) noexcept {
  code = other3.code;
  message = std::move(other3.message);
  __isset = other3.__isset;
  return *this;
}
void Exception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Exception(";
  out << "code=" << to_string(code);
  out << ", " << "message=" << to_string(message);
  out << ")";
}

const char* Exception::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: Exception";
  }
}


Schema::~Schema() noexcept {
}


void Schema::__set_cid(const int64_t val) {
  this->cid = val;
__isset.cid = true;
}

void Schema::__set_col_name(const std::string& val) {
  this->col_name = val;
__isset.col_name = true;
}

void Schema::__set_col_tags(const std::vector<std::string> & val) {
  this->col_tags = val;
}

void Schema::__set_col_seq(const KeySeq::type val) {
  this->col_seq = val;
__isset.col_seq = true;
}

void Schema::__set_col_type(const ColumnType::type val) {
  this->col_type = val;
__isset.col_type = true;
}

void Schema::__set_cell_versions(const int32_t val) {
  this->cell_versions = val;
__isset.cell_versions = true;
}

void Schema::__set_cell_ttl(const int32_t val) {
  this->cell_ttl = val;
__isset.cell_ttl = true;
}

void Schema::__set_blk_encoding(const EncodingType::type val) {
  this->blk_encoding = val;
__isset.blk_encoding = true;
}

void Schema::__set_blk_size(const int32_t val) {
  this->blk_size = val;
__isset.blk_size = true;
}

void Schema::__set_blk_cells(const int32_t val) {
  this->blk_cells = val;
__isset.blk_cells = true;
}

void Schema::__set_cs_replication(const int8_t val) {
  this->cs_replication = val;
__isset.cs_replication = true;
}

void Schema::__set_cs_size(const int32_t val) {
  this->cs_size = val;
__isset.cs_size = true;
}

void Schema::__set_cs_max(const int8_t val) {
  this->cs_max = val;
__isset.cs_max = true;
}

void Schema::__set_log_rollout_ratio(const int8_t val) {
  this->log_rollout_ratio = val;
__isset.log_rollout_ratio = true;
}

void Schema::__set_log_compact_cointervaling(const int8_t val) {
  this->log_compact_cointervaling = val;
__isset.log_compact_cointervaling = true;
}

void Schema::__set_log_fragment_preload(const int8_t val) {
  this->log_fragment_preload = val;
__isset.log_fragment_preload = true;
}

void Schema::__set_compact_percent(const int8_t val) {
  this->compact_percent = val;
__isset.compact_percent = true;
}

void Schema::__set_revision(const int64_t val) {
  this->revision = val;
__isset.revision = true;
}
std::ostream& operator<<(std::ostream& out, const Schema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Schema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col_name);
          this->__isset.col_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->col_tags.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->col_tags.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += iprot->readString(this->col_tags[_i8]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.col_tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->col_seq = static_cast<KeySeq::type>(ecast9);
          this->__isset.col_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->col_type = static_cast<ColumnType::type>(ecast10);
          this->__isset.col_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_versions);
          this->__isset.cell_versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_ttl);
          this->__isset.cell_ttl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast11;
          xfer += iprot->readI32(ecast11);
          this->blk_encoding = static_cast<EncodingType::type>(ecast11);
          this->__isset.blk_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blk_size);
          this->__isset.blk_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blk_cells);
          this->__isset.blk_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->cs_replication);
          this->__isset.cs_replication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cs_size);
          this->__isset.cs_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->cs_max);
          this->__isset.cs_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->log_rollout_ratio);
          this->__isset.log_rollout_ratio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->log_compact_cointervaling);
          this->__isset.log_compact_cointervaling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->log_fragment_preload);
          this->__isset.log_fragment_preload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->compact_percent);
          this->__isset.compact_percent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Schema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Schema");

  if (this->__isset.cid) {
    xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->cid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_name) {
    xfer += oprot->writeFieldBegin("col_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->col_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("col_tags", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->col_tags.size()));
    std::vector<std::string> ::const_iterator _iter12;
    for (_iter12 = this->col_tags.begin(); _iter12 != this->col_tags.end(); ++_iter12)
    {
      xfer += oprot->writeString((*_iter12));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.col_seq) {
    xfer += oprot->writeFieldBegin("col_seq", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->col_seq));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_type) {
    xfer += oprot->writeFieldBegin("col_type", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(static_cast<int32_t>(this->col_type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_versions) {
    xfer += oprot->writeFieldBegin("cell_versions", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->cell_versions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_ttl) {
    xfer += oprot->writeFieldBegin("cell_ttl", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->cell_ttl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_encoding) {
    xfer += oprot->writeFieldBegin("blk_encoding", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(static_cast<int32_t>(this->blk_encoding));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_size) {
    xfer += oprot->writeFieldBegin("blk_size", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->blk_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_cells) {
    xfer += oprot->writeFieldBegin("blk_cells", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->blk_cells);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_replication) {
    xfer += oprot->writeFieldBegin("cs_replication", ::apache::thrift::protocol::T_BYTE, 11);
    xfer += oprot->writeByte(this->cs_replication);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_size) {
    xfer += oprot->writeFieldBegin("cs_size", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->cs_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_max) {
    xfer += oprot->writeFieldBegin("cs_max", ::apache::thrift::protocol::T_BYTE, 13);
    xfer += oprot->writeByte(this->cs_max);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.log_rollout_ratio) {
    xfer += oprot->writeFieldBegin("log_rollout_ratio", ::apache::thrift::protocol::T_BYTE, 14);
    xfer += oprot->writeByte(this->log_rollout_ratio);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.log_compact_cointervaling) {
    xfer += oprot->writeFieldBegin("log_compact_cointervaling", ::apache::thrift::protocol::T_BYTE, 15);
    xfer += oprot->writeByte(this->log_compact_cointervaling);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.log_fragment_preload) {
    xfer += oprot->writeFieldBegin("log_fragment_preload", ::apache::thrift::protocol::T_BYTE, 16);
    xfer += oprot->writeByte(this->log_fragment_preload);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compact_percent) {
    xfer += oprot->writeFieldBegin("compact_percent", ::apache::thrift::protocol::T_BYTE, 17);
    xfer += oprot->writeByte(this->compact_percent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.revision) {
    xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 18);
    xfer += oprot->writeI64(this->revision);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Schema &a, Schema &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.col_name, b.col_name);
  swap(a.col_tags, b.col_tags);
  swap(a.col_seq, b.col_seq);
  swap(a.col_type, b.col_type);
  swap(a.cell_versions, b.cell_versions);
  swap(a.cell_ttl, b.cell_ttl);
  swap(a.blk_encoding, b.blk_encoding);
  swap(a.blk_size, b.blk_size);
  swap(a.blk_cells, b.blk_cells);
  swap(a.cs_replication, b.cs_replication);
  swap(a.cs_size, b.cs_size);
  swap(a.cs_max, b.cs_max);
  swap(a.log_rollout_ratio, b.log_rollout_ratio);
  swap(a.log_compact_cointervaling, b.log_compact_cointervaling);
  swap(a.log_fragment_preload, b.log_fragment_preload);
  swap(a.compact_percent, b.compact_percent);
  swap(a.revision, b.revision);
  swap(a.__isset, b.__isset);
}

Schema::Schema(const Schema& other13) {
  cid = other13.cid;
  col_name = other13.col_name;
  col_tags = other13.col_tags;
  col_seq = other13.col_seq;
  col_type = other13.col_type;
  cell_versions = other13.cell_versions;
  cell_ttl = other13.cell_ttl;
  blk_encoding = other13.blk_encoding;
  blk_size = other13.blk_size;
  blk_cells = other13.blk_cells;
  cs_replication = other13.cs_replication;
  cs_size = other13.cs_size;
  cs_max = other13.cs_max;
  log_rollout_ratio = other13.log_rollout_ratio;
  log_compact_cointervaling = other13.log_compact_cointervaling;
  log_fragment_preload = other13.log_fragment_preload;
  compact_percent = other13.compact_percent;
  revision = other13.revision;
  __isset = other13.__isset;
}
Schema::Schema(Schema&& other14) noexcept {
  cid = other14.cid;
  col_name = std::move(other14.col_name);
  col_tags = std::move(other14.col_tags);
  col_seq = other14.col_seq;
  col_type = other14.col_type;
  cell_versions = other14.cell_versions;
  cell_ttl = other14.cell_ttl;
  blk_encoding = other14.blk_encoding;
  blk_size = other14.blk_size;
  blk_cells = other14.blk_cells;
  cs_replication = other14.cs_replication;
  cs_size = other14.cs_size;
  cs_max = other14.cs_max;
  log_rollout_ratio = other14.log_rollout_ratio;
  log_compact_cointervaling = other14.log_compact_cointervaling;
  log_fragment_preload = other14.log_fragment_preload;
  compact_percent = other14.compact_percent;
  revision = other14.revision;
  __isset = other14.__isset;
}
Schema& Schema::operator=(const Schema& other15) {
  cid = other15.cid;
  col_name = other15.col_name;
  col_tags = other15.col_tags;
  col_seq = other15.col_seq;
  col_type = other15.col_type;
  cell_versions = other15.cell_versions;
  cell_ttl = other15.cell_ttl;
  blk_encoding = other15.blk_encoding;
  blk_size = other15.blk_size;
  blk_cells = other15.blk_cells;
  cs_replication = other15.cs_replication;
  cs_size = other15.cs_size;
  cs_max = other15.cs_max;
  log_rollout_ratio = other15.log_rollout_ratio;
  log_compact_cointervaling = other15.log_compact_cointervaling;
  log_fragment_preload = other15.log_fragment_preload;
  compact_percent = other15.compact_percent;
  revision = other15.revision;
  __isset = other15.__isset;
  return *this;
}
Schema& Schema::operator=(Schema&& other16) noexcept {
  cid = other16.cid;
  col_name = std::move(other16.col_name);
  col_tags = std::move(other16.col_tags);
  col_seq = other16.col_seq;
  col_type = other16.col_type;
  cell_versions = other16.cell_versions;
  cell_ttl = other16.cell_ttl;
  blk_encoding = other16.blk_encoding;
  blk_size = other16.blk_size;
  blk_cells = other16.blk_cells;
  cs_replication = other16.cs_replication;
  cs_size = other16.cs_size;
  cs_max = other16.cs_max;
  log_rollout_ratio = other16.log_rollout_ratio;
  log_compact_cointervaling = other16.log_compact_cointervaling;
  log_fragment_preload = other16.log_fragment_preload;
  compact_percent = other16.compact_percent;
  revision = other16.revision;
  __isset = other16.__isset;
  return *this;
}
void Schema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Schema(";
  out << "cid="; (__isset.cid ? (out << to_string(cid)) : (out << "<null>"));
  out << ", " << "col_name="; (__isset.col_name ? (out << to_string(col_name)) : (out << "<null>"));
  out << ", " << "col_tags=" << to_string(col_tags);
  out << ", " << "col_seq="; (__isset.col_seq ? (out << to_string(col_seq)) : (out << "<null>"));
  out << ", " << "col_type="; (__isset.col_type ? (out << to_string(col_type)) : (out << "<null>"));
  out << ", " << "cell_versions="; (__isset.cell_versions ? (out << to_string(cell_versions)) : (out << "<null>"));
  out << ", " << "cell_ttl="; (__isset.cell_ttl ? (out << to_string(cell_ttl)) : (out << "<null>"));
  out << ", " << "blk_encoding="; (__isset.blk_encoding ? (out << to_string(blk_encoding)) : (out << "<null>"));
  out << ", " << "blk_size="; (__isset.blk_size ? (out << to_string(blk_size)) : (out << "<null>"));
  out << ", " << "blk_cells="; (__isset.blk_cells ? (out << to_string(blk_cells)) : (out << "<null>"));
  out << ", " << "cs_replication="; (__isset.cs_replication ? (out << to_string(cs_replication)) : (out << "<null>"));
  out << ", " << "cs_size="; (__isset.cs_size ? (out << to_string(cs_size)) : (out << "<null>"));
  out << ", " << "cs_max="; (__isset.cs_max ? (out << to_string(cs_max)) : (out << "<null>"));
  out << ", " << "log_rollout_ratio="; (__isset.log_rollout_ratio ? (out << to_string(log_rollout_ratio)) : (out << "<null>"));
  out << ", " << "log_compact_cointervaling="; (__isset.log_compact_cointervaling ? (out << to_string(log_compact_cointervaling)) : (out << "<null>"));
  out << ", " << "log_fragment_preload="; (__isset.log_fragment_preload ? (out << to_string(log_fragment_preload)) : (out << "<null>"));
  out << ", " << "compact_percent="; (__isset.compact_percent ? (out << to_string(compact_percent)) : (out << "<null>"));
  out << ", " << "revision="; (__isset.revision ? (out << to_string(revision)) : (out << "<null>"));
  out << ")";
}


SchemaPattern::~SchemaPattern() noexcept {
}


void SchemaPattern::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SchemaPattern::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const SchemaPattern& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaPattern::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast17;
          xfer += iprot->readI32(ecast17);
          this->comp = static_cast<Comp::type>(ecast17);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaPattern::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaPattern");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaPattern &a, SchemaPattern &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

SchemaPattern::SchemaPattern(const SchemaPattern& other18) {
  comp = other18.comp;
  value = other18.value;
  __isset = other18.__isset;
}
SchemaPattern::SchemaPattern(SchemaPattern&& other19) noexcept {
  comp = other19.comp;
  value = std::move(other19.value);
  __isset = other19.__isset;
}
SchemaPattern& SchemaPattern::operator=(const SchemaPattern& other20) {
  comp = other20.comp;
  value = other20.value;
  __isset = other20.__isset;
  return *this;
}
SchemaPattern& SchemaPattern::operator=(SchemaPattern&& other21) noexcept {
  comp = other21.comp;
  value = std::move(other21.value);
  __isset = other21.__isset;
  return *this;
}
void SchemaPattern::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaPattern(";
  out << "comp=" << to_string(comp);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


SchemaTagsPatterns::~SchemaTagsPatterns() noexcept {
}


void SchemaTagsPatterns::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SchemaTagsPatterns::__set_values(const std::vector<SchemaPattern> & val) {
  this->values = val;
}
std::ostream& operator<<(std::ostream& out, const SchemaTagsPatterns& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaTagsPatterns::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->comp = static_cast<Comp::type>(ecast22);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->values.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += this->values[_i27].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaTagsPatterns::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaTagsPatterns");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector<SchemaPattern> ::const_iterator _iter28;
    for (_iter28 = this->values.begin(); _iter28 != this->values.end(); ++_iter28)
    {
      xfer += (*_iter28).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaTagsPatterns &a, SchemaTagsPatterns &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.values, b.values);
  swap(a.__isset, b.__isset);
}

SchemaTagsPatterns::SchemaTagsPatterns(const SchemaTagsPatterns& other29) {
  comp = other29.comp;
  values = other29.values;
  __isset = other29.__isset;
}
SchemaTagsPatterns::SchemaTagsPatterns(SchemaTagsPatterns&& other30) noexcept {
  comp = other30.comp;
  values = std::move(other30.values);
  __isset = other30.__isset;
}
SchemaTagsPatterns& SchemaTagsPatterns::operator=(const SchemaTagsPatterns& other31) {
  comp = other31.comp;
  values = other31.values;
  __isset = other31.__isset;
  return *this;
}
SchemaTagsPatterns& SchemaTagsPatterns::operator=(SchemaTagsPatterns&& other32) noexcept {
  comp = other32.comp;
  values = std::move(other32.values);
  __isset = other32.__isset;
  return *this;
}
void SchemaTagsPatterns::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaTagsPatterns(";
  out << "comp=" << to_string(comp);
  out << ", " << "values=" << to_string(values);
  out << ")";
}


SchemaPatterns::~SchemaPatterns() noexcept {
}


void SchemaPatterns::__set_names(const std::vector<SchemaPattern> & val) {
  this->names = val;
}

void SchemaPatterns::__set_tags(const SchemaTagsPatterns& val) {
  this->tags = val;
}
std::ostream& operator<<(std::ostream& out, const SchemaPatterns& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaPatterns::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->names.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += this->names[_i37].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tags.read(iprot);
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaPatterns::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaPatterns");

  xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->names.size()));
    std::vector<SchemaPattern> ::const_iterator _iter38;
    for (_iter38 = this->names.begin(); _iter38 != this->names.end(); ++_iter38)
    {
      xfer += (*_iter38).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tags.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaPatterns &a, SchemaPatterns &b) {
  using ::std::swap;
  swap(a.names, b.names);
  swap(a.tags, b.tags);
  swap(a.__isset, b.__isset);
}

SchemaPatterns::SchemaPatterns(const SchemaPatterns& other39) {
  names = other39.names;
  tags = other39.tags;
  __isset = other39.__isset;
}
SchemaPatterns::SchemaPatterns(SchemaPatterns&& other40) noexcept {
  names = std::move(other40.names);
  tags = std::move(other40.tags);
  __isset = other40.__isset;
}
SchemaPatterns& SchemaPatterns::operator=(const SchemaPatterns& other41) {
  names = other41.names;
  tags = other41.tags;
  __isset = other41.__isset;
  return *this;
}
SchemaPatterns& SchemaPatterns::operator=(SchemaPatterns&& other42) noexcept {
  names = std::move(other42.names);
  tags = std::move(other42.tags);
  __isset = other42.__isset;
  return *this;
}
void SchemaPatterns::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaPatterns(";
  out << "names=" << to_string(names);
  out << ", " << "tags=" << to_string(tags);
  out << ")";
}


SpecSchemas::~SpecSchemas() noexcept {
}


void SpecSchemas::__set_cids(const std::vector<int64_t> & val) {
  this->cids = val;
}

void SpecSchemas::__set_names(const std::vector<std::string> & val) {
  this->names = val;
}

void SpecSchemas::__set_patterns(const SchemaPatterns& val) {
  this->patterns = val;
}
std::ostream& operator<<(std::ostream& out, const SpecSchemas& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecSchemas::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cids.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->cids.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += iprot->readI64(this->cids[_i47]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->names.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += iprot->readString(this->names[_i52]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->patterns.read(iprot);
          this->__isset.patterns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecSchemas::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecSchemas");

  xfer += oprot->writeFieldBegin("cids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->cids.size()));
    std::vector<int64_t> ::const_iterator _iter53;
    for (_iter53 = this->cids.begin(); _iter53 != this->cids.end(); ++_iter53)
    {
      xfer += oprot->writeI64((*_iter53));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
    std::vector<std::string> ::const_iterator _iter54;
    for (_iter54 = this->names.begin(); _iter54 != this->names.end(); ++_iter54)
    {
      xfer += oprot->writeString((*_iter54));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("patterns", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->patterns.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecSchemas &a, SpecSchemas &b) {
  using ::std::swap;
  swap(a.cids, b.cids);
  swap(a.names, b.names);
  swap(a.patterns, b.patterns);
  swap(a.__isset, b.__isset);
}

SpecSchemas::SpecSchemas(const SpecSchemas& other55) {
  cids = other55.cids;
  names = other55.names;
  patterns = other55.patterns;
  __isset = other55.__isset;
}
SpecSchemas::SpecSchemas(SpecSchemas&& other56) noexcept {
  cids = std::move(other56.cids);
  names = std::move(other56.names);
  patterns = std::move(other56.patterns);
  __isset = other56.__isset;
}
SpecSchemas& SpecSchemas::operator=(const SpecSchemas& other57) {
  cids = other57.cids;
  names = other57.names;
  patterns = other57.patterns;
  __isset = other57.__isset;
  return *this;
}
SpecSchemas& SpecSchemas::operator=(SpecSchemas&& other58) noexcept {
  cids = std::move(other58.cids);
  names = std::move(other58.names);
  patterns = std::move(other58.patterns);
  __isset = other58.__isset;
  return *this;
}
void SpecSchemas::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecSchemas(";
  out << "cids=" << to_string(cids);
  out << ", " << "names=" << to_string(names);
  out << ", " << "patterns=" << to_string(patterns);
  out << ")";
}


SpecFlags::~SpecFlags() noexcept {
}


void SpecFlags::__set_limit(const int64_t val) {
  this->limit = val;
__isset.limit = true;
}

void SpecFlags::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}

void SpecFlags::__set_max_versions(const int32_t val) {
  this->max_versions = val;
__isset.max_versions = true;
}

void SpecFlags::__set_max_buffer(const int32_t val) {
  this->max_buffer = val;
__isset.max_buffer = true;
}

void SpecFlags::__set_options(const int8_t val) {
  this->options = val;
__isset.options = true;
}
std::ostream& operator<<(std::ostream& out, const SpecFlags& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecFlags::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_versions);
          this->__isset.max_versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_buffer);
          this->__isset.max_buffer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->options);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecFlags::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecFlags");

  if (this->__isset.limit) {
    xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_versions) {
    xfer += oprot->writeFieldBegin("max_versions", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->max_versions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_buffer) {
    xfer += oprot->writeFieldBegin("max_buffer", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->max_buffer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_BYTE, 5);
    xfer += oprot->writeByte(this->options);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecFlags &a, SpecFlags &b) {
  using ::std::swap;
  swap(a.limit, b.limit);
  swap(a.offset, b.offset);
  swap(a.max_versions, b.max_versions);
  swap(a.max_buffer, b.max_buffer);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

SpecFlags::SpecFlags(const SpecFlags& other59) noexcept {
  limit = other59.limit;
  offset = other59.offset;
  max_versions = other59.max_versions;
  max_buffer = other59.max_buffer;
  options = other59.options;
  __isset = other59.__isset;
}
SpecFlags::SpecFlags(SpecFlags&& other60) noexcept {
  limit = other60.limit;
  offset = other60.offset;
  max_versions = other60.max_versions;
  max_buffer = other60.max_buffer;
  options = other60.options;
  __isset = other60.__isset;
}
SpecFlags& SpecFlags::operator=(const SpecFlags& other61) noexcept {
  limit = other61.limit;
  offset = other61.offset;
  max_versions = other61.max_versions;
  max_buffer = other61.max_buffer;
  options = other61.options;
  __isset = other61.__isset;
  return *this;
}
SpecFlags& SpecFlags::operator=(SpecFlags&& other62) noexcept {
  limit = other62.limit;
  offset = other62.offset;
  max_versions = other62.max_versions;
  max_buffer = other62.max_buffer;
  options = other62.options;
  __isset = other62.__isset;
  return *this;
}
void SpecFlags::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecFlags(";
  out << "limit="; (__isset.limit ? (out << to_string(limit)) : (out << "<null>"));
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ", " << "max_versions="; (__isset.max_versions ? (out << to_string(max_versions)) : (out << "<null>"));
  out << ", " << "max_buffer="; (__isset.max_buffer ? (out << to_string(max_buffer)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ")";
}


SpecFraction::~SpecFraction() noexcept {
}


void SpecFraction::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecFraction::__set_f(const std::string& val) {
  this->f = val;
}
std::ostream& operator<<(std::ostream& out, const SpecFraction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecFraction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast63;
          xfer += iprot->readI32(ecast63);
          this->comp = static_cast<Comp::type>(ecast63);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->f);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecFraction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecFraction");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->f);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecFraction &a, SpecFraction &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.f, b.f);
  swap(a.__isset, b.__isset);
}

SpecFraction::SpecFraction(const SpecFraction& other64) {
  comp = other64.comp;
  f = other64.f;
  __isset = other64.__isset;
}
SpecFraction::SpecFraction(SpecFraction&& other65) noexcept {
  comp = other65.comp;
  f = std::move(other65.f);
  __isset = other65.__isset;
}
SpecFraction& SpecFraction::operator=(const SpecFraction& other66) {
  comp = other66.comp;
  f = other66.f;
  __isset = other66.__isset;
  return *this;
}
SpecFraction& SpecFraction::operator=(SpecFraction&& other67) noexcept {
  comp = other67.comp;
  f = std::move(other67.f);
  __isset = other67.__isset;
  return *this;
}
void SpecFraction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecFraction(";
  out << "comp=" << to_string(comp);
  out << ", " << "f=" << to_string(f);
  out << ")";
}


SpecTimestamp::~SpecTimestamp() noexcept {
}


void SpecTimestamp::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecTimestamp::__set_ts(const int64_t val) {
  this->ts = val;
}
std::ostream& operator<<(std::ostream& out, const SpecTimestamp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecTimestamp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast68;
          xfer += iprot->readI32(ecast68);
          this->comp = static_cast<Comp::type>(ecast68);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecTimestamp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecTimestamp");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecTimestamp &a, SpecTimestamp &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.ts, b.ts);
  swap(a.__isset, b.__isset);
}

SpecTimestamp::SpecTimestamp(const SpecTimestamp& other69) noexcept {
  comp = other69.comp;
  ts = other69.ts;
  __isset = other69.__isset;
}
SpecTimestamp::SpecTimestamp(SpecTimestamp&& other70) noexcept {
  comp = other70.comp;
  ts = other70.ts;
  __isset = other70.__isset;
}
SpecTimestamp& SpecTimestamp::operator=(const SpecTimestamp& other71) noexcept {
  comp = other71.comp;
  ts = other71.ts;
  __isset = other71.__isset;
  return *this;
}
SpecTimestamp& SpecTimestamp::operator=(SpecTimestamp&& other72) noexcept {
  comp = other72.comp;
  ts = other72.ts;
  __isset = other72.__isset;
  return *this;
}
void SpecTimestamp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecTimestamp(";
  out << "comp=" << to_string(comp);
  out << ", " << "ts=" << to_string(ts);
  out << ")";
}


SpecKeyInterval::~SpecKeyInterval() noexcept {
}


void SpecKeyInterval::__set_start(const SpecKey& val) {
  this->start = val;
}

void SpecKeyInterval::__set_finish(const SpecKey& val) {
  this->finish = val;
}
std::ostream& operator<<(std::ostream& out, const SpecKeyInterval& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecKeyInterval::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->start.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _etype76;
            xfer += iprot->readListBegin(_etype76, _size73);
            this->start.resize(_size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              xfer += this->start[_i77].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->finish.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->finish.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->finish[_i82].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecKeyInterval::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecKeyInterval");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->start.size()));
    std::vector<SpecFraction> ::const_iterator _iter83;
    for (_iter83 = this->start.begin(); _iter83 != this->start.end(); ++_iter83)
    {
      xfer += (*_iter83).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("finish", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->finish.size()));
    std::vector<SpecFraction> ::const_iterator _iter84;
    for (_iter84 = this->finish.begin(); _iter84 != this->finish.end(); ++_iter84)
    {
      xfer += (*_iter84).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecKeyInterval &a, SpecKeyInterval &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.finish, b.finish);
  swap(a.__isset, b.__isset);
}

SpecKeyInterval::SpecKeyInterval(const SpecKeyInterval& other85) {
  start = other85.start;
  finish = other85.finish;
  __isset = other85.__isset;
}
SpecKeyInterval::SpecKeyInterval(SpecKeyInterval&& other86) noexcept {
  start = std::move(other86.start);
  finish = std::move(other86.finish);
  __isset = other86.__isset;
}
SpecKeyInterval& SpecKeyInterval::operator=(const SpecKeyInterval& other87) {
  start = other87.start;
  finish = other87.finish;
  __isset = other87.__isset;
  return *this;
}
SpecKeyInterval& SpecKeyInterval::operator=(SpecKeyInterval&& other88) noexcept {
  start = std::move(other88.start);
  finish = std::move(other88.finish);
  __isset = other88.__isset;
  return *this;
}
void SpecKeyInterval::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecKeyInterval(";
  out << "start=" << to_string(start);
  out << ", " << "finish=" << to_string(finish);
  out << ")";
}


SpecValue::~SpecValue() noexcept {
}


void SpecValue::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValue::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast89;
          xfer += iprot->readI32(ecast89);
          this->comp = static_cast<Comp::type>(ecast89);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValue");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValue &a, SpecValue &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValue::SpecValue(const SpecValue& other90) {
  comp = other90.comp;
  v = other90.v;
  __isset = other90.__isset;
}
SpecValue::SpecValue(SpecValue&& other91) noexcept {
  comp = other91.comp;
  v = std::move(other91.v);
  __isset = other91.__isset;
}
SpecValue& SpecValue::operator=(const SpecValue& other92) {
  comp = other92.comp;
  v = other92.v;
  __isset = other92.__isset;
  return *this;
}
SpecValue& SpecValue::operator=(SpecValue&& other93) noexcept {
  comp = other93.comp;
  v = std::move(other93.v);
  __isset = other93.__isset;
  return *this;
}
void SpecValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValue(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecUpdateOP::~SpecUpdateOP() noexcept {
}


void SpecUpdateOP::__set_op(const UpdateOP::type val) {
  this->op = val;
}

void SpecUpdateOP::__set_pos(const int32_t val) {
  this->pos = val;
__isset.pos = true;
}
std::ostream& operator<<(std::ostream& out, const SpecUpdateOP& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecUpdateOP::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast94;
          xfer += iprot->readI32(ecast94);
          this->op = static_cast<UpdateOP::type>(ecast94);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecUpdateOP::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecUpdateOP");

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->op));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecUpdateOP &a, SpecUpdateOP &b) {
  using ::std::swap;
  swap(a.op, b.op);
  swap(a.pos, b.pos);
  swap(a.__isset, b.__isset);
}

SpecUpdateOP::SpecUpdateOP(const SpecUpdateOP& other95) noexcept {
  op = other95.op;
  pos = other95.pos;
  __isset = other95.__isset;
}
SpecUpdateOP::SpecUpdateOP(SpecUpdateOP&& other96) noexcept {
  op = other96.op;
  pos = other96.pos;
  __isset = other96.__isset;
}
SpecUpdateOP& SpecUpdateOP::operator=(const SpecUpdateOP& other97) noexcept {
  op = other97.op;
  pos = other97.pos;
  __isset = other97.__isset;
  return *this;
}
SpecUpdateOP& SpecUpdateOP::operator=(SpecUpdateOP&& other98) noexcept {
  op = other98.op;
  pos = other98.pos;
  __isset = other98.__isset;
  return *this;
}
void SpecUpdateOP::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecUpdateOP(";
  out << "op=" << to_string(op);
  out << ", " << "pos="; (__isset.pos ? (out << to_string(pos)) : (out << "<null>"));
  out << ")";
}


SpecIntervalUpdate::~SpecIntervalUpdate() noexcept {
}


void SpecIntervalUpdate::__set_v(const std::string& val) {
  this->v = val;
}

void SpecIntervalUpdate::__set_ts(const int64_t val) {
  this->ts = val;
__isset.ts = true;
}

void SpecIntervalUpdate::__set_encoder(const EncodingType::type val) {
  this->encoder = val;
__isset.encoder = true;
}

void SpecIntervalUpdate::__set_update_op(const SpecUpdateOP& val) {
  this->update_op = val;
__isset.update_op = true;
}
std::ostream& operator<<(std::ostream& out, const SpecIntervalUpdate& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecIntervalUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast99;
          xfer += iprot->readI32(ecast99);
          this->encoder = static_cast<EncodingType::type>(ecast99);
          this->__isset.encoder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->update_op.read(iprot);
          this->__isset.update_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecIntervalUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecIntervalUpdate");

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts) {
    xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.encoder) {
    xfer += oprot->writeFieldBegin("encoder", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(static_cast<int32_t>(this->encoder));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.update_op) {
    xfer += oprot->writeFieldBegin("update_op", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->update_op.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecIntervalUpdate &a, SpecIntervalUpdate &b) {
  using ::std::swap;
  swap(a.v, b.v);
  swap(a.ts, b.ts);
  swap(a.encoder, b.encoder);
  swap(a.update_op, b.update_op);
  swap(a.__isset, b.__isset);
}

SpecIntervalUpdate::SpecIntervalUpdate(const SpecIntervalUpdate& other100) {
  v = other100.v;
  ts = other100.ts;
  encoder = other100.encoder;
  update_op = other100.update_op;
  __isset = other100.__isset;
}
SpecIntervalUpdate::SpecIntervalUpdate(SpecIntervalUpdate&& other101) noexcept {
  v = std::move(other101.v);
  ts = other101.ts;
  encoder = other101.encoder;
  update_op = std::move(other101.update_op);
  __isset = other101.__isset;
}
SpecIntervalUpdate& SpecIntervalUpdate::operator=(const SpecIntervalUpdate& other102) {
  v = other102.v;
  ts = other102.ts;
  encoder = other102.encoder;
  update_op = other102.update_op;
  __isset = other102.__isset;
  return *this;
}
SpecIntervalUpdate& SpecIntervalUpdate::operator=(SpecIntervalUpdate&& other103) noexcept {
  v = std::move(other103.v);
  ts = other103.ts;
  encoder = other103.encoder;
  update_op = std::move(other103.update_op);
  __isset = other103.__isset;
  return *this;
}
void SpecIntervalUpdate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecIntervalUpdate(";
  out << "v=" << to_string(v);
  out << ", " << "ts="; (__isset.ts ? (out << to_string(ts)) : (out << "<null>"));
  out << ", " << "encoder="; (__isset.encoder ? (out << to_string(encoder)) : (out << "<null>"));
  out << ", " << "update_op="; (__isset.update_op ? (out << to_string(update_op)) : (out << "<null>"));
  out << ")";
}


SpecIntervalUpdateSerial::~SpecIntervalUpdateSerial() noexcept {
}


void SpecIntervalUpdateSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void SpecIntervalUpdateSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}

void SpecIntervalUpdateSerial::__set_v_op(const CellValuesSerialOp& val) {
  this->v_op = val;
}

void SpecIntervalUpdateSerial::__set_encoder(const EncodingType::type val) {
  this->encoder = val;
__isset.encoder = true;
}

void SpecIntervalUpdateSerial::__set_update_op(const SpecUpdateOP& val) {
  this->update_op = val;
__isset.update_op = true;
}
std::ostream& operator<<(std::ostream& out, const SpecIntervalUpdateSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecIntervalUpdateSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size104;
            ::apache::thrift::protocol::TType _etype107;
            xfer += iprot->readListBegin(_etype107, _size104);
            this->v.resize(_size104);
            uint32_t _i108;
            for (_i108 = 0; _i108 < _size104; ++_i108)
            {
              xfer += this->v[_i108].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_op.clear();
            uint32_t _size109;
            ::apache::thrift::protocol::TType _etype112;
            xfer += iprot->readListBegin(_etype112, _size109);
            this->v_op.resize(_size109);
            uint32_t _i113;
            for (_i113 = 0; _i113 < _size109; ++_i113)
            {
              xfer += this->v_op[_i113].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast114;
          xfer += iprot->readI32(ecast114);
          this->encoder = static_cast<EncodingType::type>(ecast114);
          this->__isset.encoder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->update_op.read(iprot);
          this->__isset.update_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecIntervalUpdateSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecIntervalUpdateSerial");

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter115;
    for (_iter115 = this->v.begin(); _iter115 != this->v.end(); ++_iter115)
    {
      xfer += (*_iter115).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_op", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v_op.size()));
    std::vector<CellValueSerialOp> ::const_iterator _iter116;
    for (_iter116 = this->v_op.begin(); _iter116 != this->v_op.end(); ++_iter116)
    {
      xfer += (*_iter116).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.encoder) {
    xfer += oprot->writeFieldBegin("encoder", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->encoder));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.update_op) {
    xfer += oprot->writeFieldBegin("update_op", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->update_op.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecIntervalUpdateSerial &a, SpecIntervalUpdateSerial &b) {
  using ::std::swap;
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.v_op, b.v_op);
  swap(a.encoder, b.encoder);
  swap(a.update_op, b.update_op);
  swap(a.__isset, b.__isset);
}

SpecIntervalUpdateSerial::SpecIntervalUpdateSerial(const SpecIntervalUpdateSerial& other117) {
  ts = other117.ts;
  v = other117.v;
  v_op = other117.v_op;
  encoder = other117.encoder;
  update_op = other117.update_op;
  __isset = other117.__isset;
}
SpecIntervalUpdateSerial::SpecIntervalUpdateSerial(SpecIntervalUpdateSerial&& other118) noexcept {
  ts = other118.ts;
  v = std::move(other118.v);
  v_op = std::move(other118.v_op);
  encoder = other118.encoder;
  update_op = std::move(other118.update_op);
  __isset = other118.__isset;
}
SpecIntervalUpdateSerial& SpecIntervalUpdateSerial::operator=(const SpecIntervalUpdateSerial& other119) {
  ts = other119.ts;
  v = other119.v;
  v_op = other119.v_op;
  encoder = other119.encoder;
  update_op = other119.update_op;
  __isset = other119.__isset;
  return *this;
}
SpecIntervalUpdateSerial& SpecIntervalUpdateSerial::operator=(SpecIntervalUpdateSerial&& other120) noexcept {
  ts = other120.ts;
  v = std::move(other120.v);
  v_op = std::move(other120.v_op);
  encoder = other120.encoder;
  update_op = std::move(other120.update_op);
  __isset = other120.__isset;
  return *this;
}
void SpecIntervalUpdateSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecIntervalUpdateSerial(";
  out << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ", " << "v_op=" << to_string(v_op);
  out << ", " << "encoder="; (__isset.encoder ? (out << to_string(encoder)) : (out << "<null>"));
  out << ", " << "update_op="; (__isset.update_op ? (out << to_string(update_op)) : (out << "<null>"));
  out << ")";
}


SpecInterval::~SpecInterval() noexcept {
}


void SpecInterval::__set_range_begin(const Key& val) {
  this->range_begin = val;
}

void SpecInterval::__set_range_end(const Key& val) {
  this->range_end = val;
}

void SpecInterval::__set_offset_key(const Key& val) {
  this->offset_key = val;
}

void SpecInterval::__set_offset_rev(const int64_t val) {
  this->offset_rev = val;
__isset.offset_rev = true;
}

void SpecInterval::__set_key_intervals(const SpecKeyIntervals& val) {
  this->key_intervals = val;
}

void SpecInterval::__set_values(const SpecValues& val) {
  this->values = val;
}

void SpecInterval::__set_ts_start(const SpecTimestamp& val) {
  this->ts_start = val;
__isset.ts_start = true;
}

void SpecInterval::__set_ts_finish(const SpecTimestamp& val) {
  this->ts_finish = val;
__isset.ts_finish = true;
}

void SpecInterval::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}

void SpecInterval::__set_options(const SpecIntervalOptions::type val) {
  this->options = val;
__isset.options = true;
}

void SpecInterval::__set_updating(const SpecIntervalUpdate& val) {
  this->updating = val;
__isset.updating = true;
}
std::ostream& operator<<(std::ostream& out, const SpecInterval& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecInterval::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_begin.clear();
            uint32_t _size121;
            ::apache::thrift::protocol::TType _etype124;
            xfer += iprot->readListBegin(_etype124, _size121);
            this->range_begin.resize(_size121);
            uint32_t _i125;
            for (_i125 = 0; _i125 < _size121; ++_i125)
            {
              xfer += iprot->readBinary(this->range_begin[_i125]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_end.clear();
            uint32_t _size126;
            ::apache::thrift::protocol::TType _etype129;
            xfer += iprot->readListBegin(_etype129, _size126);
            this->range_end.resize(_size126);
            uint32_t _i130;
            for (_i130 = 0; _i130 < _size126; ++_i130)
            {
              xfer += iprot->readBinary(this->range_end[_i130]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->offset_key.clear();
            uint32_t _size131;
            ::apache::thrift::protocol::TType _etype134;
            xfer += iprot->readListBegin(_etype134, _size131);
            this->offset_key.resize(_size131);
            uint32_t _i135;
            for (_i135 = 0; _i135 < _size131; ++_i135)
            {
              xfer += iprot->readBinary(this->offset_key[_i135]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.offset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset_rev);
          this->__isset.offset_rev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_intervals.clear();
            uint32_t _size136;
            ::apache::thrift::protocol::TType _etype139;
            xfer += iprot->readListBegin(_etype139, _size136);
            this->key_intervals.resize(_size136);
            uint32_t _i140;
            for (_i140 = 0; _i140 < _size136; ++_i140)
            {
              xfer += this->key_intervals[_i140].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size141;
            ::apache::thrift::protocol::TType _etype144;
            xfer += iprot->readListBegin(_etype144, _size141);
            this->values.resize(_size141);
            uint32_t _i145;
            for (_i145 = 0; _i145 < _size141; ++_i145)
            {
              xfer += this->values[_i145].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_start.read(iprot);
          this->__isset.ts_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_finish.read(iprot);
          this->__isset.ts_finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast146;
          xfer += iprot->readI32(ecast146);
          this->options = static_cast<SpecIntervalOptions::type>(ecast146);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->updating.read(iprot);
          this->__isset.updating = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecInterval::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecInterval");

  xfer += oprot->writeFieldBegin("range_begin", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_begin.size()));
    std::vector<std::string> ::const_iterator _iter147;
    for (_iter147 = this->range_begin.begin(); _iter147 != this->range_begin.end(); ++_iter147)
    {
      xfer += oprot->writeBinary((*_iter147));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range_end", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_end.size()));
    std::vector<std::string> ::const_iterator _iter148;
    for (_iter148 = this->range_end.begin(); _iter148 != this->range_end.end(); ++_iter148)
    {
      xfer += oprot->writeBinary((*_iter148));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset_key", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->offset_key.size()));
    std::vector<std::string> ::const_iterator _iter149;
    for (_iter149 = this->offset_key.begin(); _iter149 != this->offset_key.end(); ++_iter149)
    {
      xfer += oprot->writeBinary((*_iter149));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offset_rev) {
    xfer += oprot->writeFieldBegin("offset_rev", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->offset_rev);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("key_intervals", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->key_intervals.size()));
    std::vector<SpecKeyInterval> ::const_iterator _iter150;
    for (_iter150 = this->key_intervals.begin(); _iter150 != this->key_intervals.end(); ++_iter150)
    {
      xfer += (*_iter150).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector<SpecValue> ::const_iterator _iter151;
    for (_iter151 = this->values.begin(); _iter151 != this->values.end(); ++_iter151)
    {
      xfer += (*_iter151).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts_start) {
    xfer += oprot->writeFieldBegin("ts_start", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->ts_start.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_finish) {
    xfer += oprot->writeFieldBegin("ts_finish", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->ts_finish.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(static_cast<int32_t>(this->options));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updating) {
    xfer += oprot->writeFieldBegin("updating", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->updating.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecInterval &a, SpecInterval &b) {
  using ::std::swap;
  swap(a.range_begin, b.range_begin);
  swap(a.range_end, b.range_end);
  swap(a.offset_key, b.offset_key);
  swap(a.offset_rev, b.offset_rev);
  swap(a.key_intervals, b.key_intervals);
  swap(a.values, b.values);
  swap(a.ts_start, b.ts_start);
  swap(a.ts_finish, b.ts_finish);
  swap(a.flags, b.flags);
  swap(a.options, b.options);
  swap(a.updating, b.updating);
  swap(a.__isset, b.__isset);
}

SpecInterval::SpecInterval(const SpecInterval& other152) {
  range_begin = other152.range_begin;
  range_end = other152.range_end;
  offset_key = other152.offset_key;
  offset_rev = other152.offset_rev;
  key_intervals = other152.key_intervals;
  values = other152.values;
  ts_start = other152.ts_start;
  ts_finish = other152.ts_finish;
  flags = other152.flags;
  options = other152.options;
  updating = other152.updating;
  __isset = other152.__isset;
}
SpecInterval::SpecInterval(SpecInterval&& other153) noexcept {
  range_begin = std::move(other153.range_begin);
  range_end = std::move(other153.range_end);
  offset_key = std::move(other153.offset_key);
  offset_rev = other153.offset_rev;
  key_intervals = std::move(other153.key_intervals);
  values = std::move(other153.values);
  ts_start = std::move(other153.ts_start);
  ts_finish = std::move(other153.ts_finish);
  flags = std::move(other153.flags);
  options = other153.options;
  updating = std::move(other153.updating);
  __isset = other153.__isset;
}
SpecInterval& SpecInterval::operator=(const SpecInterval& other154) {
  range_begin = other154.range_begin;
  range_end = other154.range_end;
  offset_key = other154.offset_key;
  offset_rev = other154.offset_rev;
  key_intervals = other154.key_intervals;
  values = other154.values;
  ts_start = other154.ts_start;
  ts_finish = other154.ts_finish;
  flags = other154.flags;
  options = other154.options;
  updating = other154.updating;
  __isset = other154.__isset;
  return *this;
}
SpecInterval& SpecInterval::operator=(SpecInterval&& other155) noexcept {
  range_begin = std::move(other155.range_begin);
  range_end = std::move(other155.range_end);
  offset_key = std::move(other155.offset_key);
  offset_rev = other155.offset_rev;
  key_intervals = std::move(other155.key_intervals);
  values = std::move(other155.values);
  ts_start = std::move(other155.ts_start);
  ts_finish = std::move(other155.ts_finish);
  flags = std::move(other155.flags);
  options = other155.options;
  updating = std::move(other155.updating);
  __isset = other155.__isset;
  return *this;
}
void SpecInterval::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecInterval(";
  out << "range_begin=" << to_string(range_begin);
  out << ", " << "range_end=" << to_string(range_end);
  out << ", " << "offset_key=" << to_string(offset_key);
  out << ", " << "offset_rev="; (__isset.offset_rev ? (out << to_string(offset_rev)) : (out << "<null>"));
  out << ", " << "key_intervals=" << to_string(key_intervals);
  out << ", " << "values=" << to_string(values);
  out << ", " << "ts_start="; (__isset.ts_start ? (out << to_string(ts_start)) : (out << "<null>"));
  out << ", " << "ts_finish="; (__isset.ts_finish ? (out << to_string(ts_finish)) : (out << "<null>"));
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ", " << "updating="; (__isset.updating ? (out << to_string(updating)) : (out << "<null>"));
  out << ")";
}


SpecColumn::~SpecColumn() noexcept {
}


void SpecColumn::__set_cid(const int64_t val) {
  this->cid = val;
}

void SpecColumn::__set_intervals(const std::vector<SpecInterval> & val) {
  this->intervals = val;
}
std::ostream& operator<<(std::ostream& out, const SpecColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->intervals.clear();
            uint32_t _size156;
            ::apache::thrift::protocol::TType _etype159;
            xfer += iprot->readListBegin(_etype159, _size156);
            this->intervals.resize(_size156);
            uint32_t _i160;
            for (_i160 = 0; _i160 < _size156; ++_i160)
            {
              xfer += this->intervals[_i160].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecColumn");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intervals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->intervals.size()));
    std::vector<SpecInterval> ::const_iterator _iter161;
    for (_iter161 = this->intervals.begin(); _iter161 != this->intervals.end(); ++_iter161)
    {
      xfer += (*_iter161).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecColumn &a, SpecColumn &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.intervals, b.intervals);
  swap(a.__isset, b.__isset);
}

SpecColumn::SpecColumn(const SpecColumn& other162) {
  cid = other162.cid;
  intervals = other162.intervals;
  __isset = other162.__isset;
}
SpecColumn::SpecColumn(SpecColumn&& other163) noexcept {
  cid = other163.cid;
  intervals = std::move(other163.intervals);
  __isset = other163.__isset;
}
SpecColumn& SpecColumn::operator=(const SpecColumn& other164) {
  cid = other164.cid;
  intervals = other164.intervals;
  __isset = other164.__isset;
  return *this;
}
SpecColumn& SpecColumn::operator=(SpecColumn&& other165) noexcept {
  cid = other165.cid;
  intervals = std::move(other165.intervals);
  __isset = other165.__isset;
  return *this;
}
void SpecColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecColumn(";
  out << "cid=" << to_string(cid);
  out << ", " << "intervals=" << to_string(intervals);
  out << ")";
}


SpecValueSerial_INT64::~SpecValueSerial_INT64() noexcept {
}


void SpecValueSerial_INT64::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_INT64::__set_v(const int64_t val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_INT64& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_INT64::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast166;
          xfer += iprot->readI32(ecast166);
          this->comp = static_cast<Comp::type>(ecast166);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_INT64::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_INT64");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_INT64 &a, SpecValueSerial_INT64 &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_INT64::SpecValueSerial_INT64(const SpecValueSerial_INT64& other167) noexcept {
  comp = other167.comp;
  v = other167.v;
  __isset = other167.__isset;
}
SpecValueSerial_INT64::SpecValueSerial_INT64(SpecValueSerial_INT64&& other168) noexcept {
  comp = other168.comp;
  v = other168.v;
  __isset = other168.__isset;
}
SpecValueSerial_INT64& SpecValueSerial_INT64::operator=(const SpecValueSerial_INT64& other169) noexcept {
  comp = other169.comp;
  v = other169.v;
  __isset = other169.__isset;
  return *this;
}
SpecValueSerial_INT64& SpecValueSerial_INT64::operator=(SpecValueSerial_INT64&& other170) noexcept {
  comp = other170.comp;
  v = other170.v;
  __isset = other170.__isset;
  return *this;
}
void SpecValueSerial_INT64::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_INT64(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_DOUBLE::~SpecValueSerial_DOUBLE() noexcept {
}


void SpecValueSerial_DOUBLE::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_DOUBLE::__set_v(const double val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_DOUBLE& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_DOUBLE::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast171;
          xfer += iprot->readI32(ecast171);
          this->comp = static_cast<Comp::type>(ecast171);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_DOUBLE::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_DOUBLE");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_DOUBLE &a, SpecValueSerial_DOUBLE &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_DOUBLE::SpecValueSerial_DOUBLE(const SpecValueSerial_DOUBLE& other172) noexcept {
  comp = other172.comp;
  v = other172.v;
  __isset = other172.__isset;
}
SpecValueSerial_DOUBLE::SpecValueSerial_DOUBLE(SpecValueSerial_DOUBLE&& other173) noexcept {
  comp = other173.comp;
  v = other173.v;
  __isset = other173.__isset;
}
SpecValueSerial_DOUBLE& SpecValueSerial_DOUBLE::operator=(const SpecValueSerial_DOUBLE& other174) noexcept {
  comp = other174.comp;
  v = other174.v;
  __isset = other174.__isset;
  return *this;
}
SpecValueSerial_DOUBLE& SpecValueSerial_DOUBLE::operator=(SpecValueSerial_DOUBLE&& other175) noexcept {
  comp = other175.comp;
  v = other175.v;
  __isset = other175.__isset;
  return *this;
}
void SpecValueSerial_DOUBLE::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_DOUBLE(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_BYTES::~SpecValueSerial_BYTES() noexcept {
}


void SpecValueSerial_BYTES::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_BYTES::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_BYTES& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_BYTES::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast176;
          xfer += iprot->readI32(ecast176);
          this->comp = static_cast<Comp::type>(ecast176);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_BYTES::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_BYTES");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_BYTES &a, SpecValueSerial_BYTES &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_BYTES::SpecValueSerial_BYTES(const SpecValueSerial_BYTES& other177) {
  comp = other177.comp;
  v = other177.v;
  __isset = other177.__isset;
}
SpecValueSerial_BYTES::SpecValueSerial_BYTES(SpecValueSerial_BYTES&& other178) noexcept {
  comp = other178.comp;
  v = std::move(other178.v);
  __isset = other178.__isset;
}
SpecValueSerial_BYTES& SpecValueSerial_BYTES::operator=(const SpecValueSerial_BYTES& other179) {
  comp = other179.comp;
  v = other179.v;
  __isset = other179.__isset;
  return *this;
}
SpecValueSerial_BYTES& SpecValueSerial_BYTES::operator=(SpecValueSerial_BYTES&& other180) noexcept {
  comp = other180.comp;
  v = std::move(other180.v);
  __isset = other180.__isset;
  return *this;
}
void SpecValueSerial_BYTES::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_BYTES(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_KEY::~SpecValueSerial_KEY() noexcept {
}


void SpecValueSerial_KEY::__set_seq(const KeySeq::type val) {
  this->seq = val;
}

void SpecValueSerial_KEY::__set_v(const SpecKey& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_KEY& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_KEY::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast181;
          xfer += iprot->readI32(ecast181);
          this->seq = static_cast<KeySeq::type>(ecast181);
          this->__isset.seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size182;
            ::apache::thrift::protocol::TType _etype185;
            xfer += iprot->readListBegin(_etype185, _size182);
            this->v.resize(_size182);
            uint32_t _i186;
            for (_i186 = 0; _i186 < _size182; ++_i186)
            {
              xfer += this->v[_i186].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_KEY::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_KEY");

  xfer += oprot->writeFieldBegin("seq", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->seq));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<SpecFraction> ::const_iterator _iter187;
    for (_iter187 = this->v.begin(); _iter187 != this->v.end(); ++_iter187)
    {
      xfer += (*_iter187).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_KEY &a, SpecValueSerial_KEY &b) {
  using ::std::swap;
  swap(a.seq, b.seq);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_KEY::SpecValueSerial_KEY(const SpecValueSerial_KEY& other188) {
  seq = other188.seq;
  v = other188.v;
  __isset = other188.__isset;
}
SpecValueSerial_KEY::SpecValueSerial_KEY(SpecValueSerial_KEY&& other189) noexcept {
  seq = other189.seq;
  v = std::move(other189.v);
  __isset = other189.__isset;
}
SpecValueSerial_KEY& SpecValueSerial_KEY::operator=(const SpecValueSerial_KEY& other190) {
  seq = other190.seq;
  v = other190.v;
  __isset = other190.__isset;
  return *this;
}
SpecValueSerial_KEY& SpecValueSerial_KEY::operator=(SpecValueSerial_KEY&& other191) noexcept {
  seq = other191.seq;
  v = std::move(other191.v);
  __isset = other191.__isset;
  return *this;
}
void SpecValueSerial_KEY::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_KEY(";
  out << "seq=" << to_string(seq);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_LI::~SpecValueSerial_LI() noexcept {
}


void SpecValueSerial_LI::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_LI::__set_v(const std::vector<SpecValueSerial_INT64> & val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_LI& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_LI::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast192;
          xfer += iprot->readI32(ecast192);
          this->comp = static_cast<Comp::type>(ecast192);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size193;
            ::apache::thrift::protocol::TType _etype196;
            xfer += iprot->readListBegin(_etype196, _size193);
            this->v.resize(_size193);
            uint32_t _i197;
            for (_i197 = 0; _i197 < _size193; ++_i197)
            {
              xfer += this->v[_i197].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_LI::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_LI");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<SpecValueSerial_INT64> ::const_iterator _iter198;
    for (_iter198 = this->v.begin(); _iter198 != this->v.end(); ++_iter198)
    {
      xfer += (*_iter198).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_LI &a, SpecValueSerial_LI &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_LI::SpecValueSerial_LI(const SpecValueSerial_LI& other199) {
  comp = other199.comp;
  v = other199.v;
  __isset = other199.__isset;
}
SpecValueSerial_LI::SpecValueSerial_LI(SpecValueSerial_LI&& other200) noexcept {
  comp = other200.comp;
  v = std::move(other200.v);
  __isset = other200.__isset;
}
SpecValueSerial_LI& SpecValueSerial_LI::operator=(const SpecValueSerial_LI& other201) {
  comp = other201.comp;
  v = other201.v;
  __isset = other201.__isset;
  return *this;
}
SpecValueSerial_LI& SpecValueSerial_LI::operator=(SpecValueSerial_LI&& other202) noexcept {
  comp = other202.comp;
  v = std::move(other202.v);
  __isset = other202.__isset;
  return *this;
}
void SpecValueSerial_LI::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_LI(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_LB::~SpecValueSerial_LB() noexcept {
}


void SpecValueSerial_LB::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_LB::__set_v(const std::vector<SpecValueSerial_BYTES> & val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_LB& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_LB::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast203;
          xfer += iprot->readI32(ecast203);
          this->comp = static_cast<Comp::type>(ecast203);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size204;
            ::apache::thrift::protocol::TType _etype207;
            xfer += iprot->readListBegin(_etype207, _size204);
            this->v.resize(_size204);
            uint32_t _i208;
            for (_i208 = 0; _i208 < _size204; ++_i208)
            {
              xfer += this->v[_i208].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_LB::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_LB");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<SpecValueSerial_BYTES> ::const_iterator _iter209;
    for (_iter209 = this->v.begin(); _iter209 != this->v.end(); ++_iter209)
    {
      xfer += (*_iter209).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_LB &a, SpecValueSerial_LB &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_LB::SpecValueSerial_LB(const SpecValueSerial_LB& other210) {
  comp = other210.comp;
  v = other210.v;
  __isset = other210.__isset;
}
SpecValueSerial_LB::SpecValueSerial_LB(SpecValueSerial_LB&& other211) noexcept {
  comp = other211.comp;
  v = std::move(other211.v);
  __isset = other211.__isset;
}
SpecValueSerial_LB& SpecValueSerial_LB::operator=(const SpecValueSerial_LB& other212) {
  comp = other212.comp;
  v = other212.v;
  __isset = other212.__isset;
  return *this;
}
SpecValueSerial_LB& SpecValueSerial_LB::operator=(SpecValueSerial_LB&& other213) noexcept {
  comp = other213.comp;
  v = std::move(other213.v);
  __isset = other213.__isset;
  return *this;
}
void SpecValueSerial_LB::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_LB(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerialField::~SpecValueSerialField() noexcept {
}


void SpecValueSerialField::__set_field_id(const int32_t val) {
  this->field_id = val;
}

void SpecValueSerialField::__set_spec_int64(const SpecValueSerial_INT64& val) {
  this->spec_int64 = val;
__isset.spec_int64 = true;
}

void SpecValueSerialField::__set_spec_double(const SpecValueSerial_DOUBLE& val) {
  this->spec_double = val;
__isset.spec_double = true;
}

void SpecValueSerialField::__set_spec_bytes(const SpecValueSerial_BYTES& val) {
  this->spec_bytes = val;
}

void SpecValueSerialField::__set_spec_key(const SpecValueSerial_KEY& val) {
  this->spec_key = val;
}

void SpecValueSerialField::__set_spec_li(const SpecValueSerial_LI& val) {
  this->spec_li = val;
}

void SpecValueSerialField::__set_spec_lb(const SpecValueSerial_LB& val) {
  this->spec_lb = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerialField& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerialField::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field_id);
          this->__isset.field_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_int64.read(iprot);
          this->__isset.spec_int64 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_double.read(iprot);
          this->__isset.spec_double = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_bytes.read(iprot);
          this->__isset.spec_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_key.read(iprot);
          this->__isset.spec_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_li.read(iprot);
          this->__isset.spec_li = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_lb.read(iprot);
          this->__isset.spec_lb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerialField::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerialField");

  xfer += oprot->writeFieldBegin("field_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.spec_int64) {
    xfer += oprot->writeFieldBegin("spec_int64", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->spec_int64.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.spec_double) {
    xfer += oprot->writeFieldBegin("spec_double", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->spec_double.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("spec_bytes", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->spec_bytes.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spec_key", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->spec_key.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spec_li", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->spec_li.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spec_lb", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->spec_lb.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerialField &a, SpecValueSerialField &b) {
  using ::std::swap;
  swap(a.field_id, b.field_id);
  swap(a.spec_int64, b.spec_int64);
  swap(a.spec_double, b.spec_double);
  swap(a.spec_bytes, b.spec_bytes);
  swap(a.spec_key, b.spec_key);
  swap(a.spec_li, b.spec_li);
  swap(a.spec_lb, b.spec_lb);
  swap(a.__isset, b.__isset);
}

SpecValueSerialField::SpecValueSerialField(const SpecValueSerialField& other214) {
  field_id = other214.field_id;
  spec_int64 = other214.spec_int64;
  spec_double = other214.spec_double;
  spec_bytes = other214.spec_bytes;
  spec_key = other214.spec_key;
  spec_li = other214.spec_li;
  spec_lb = other214.spec_lb;
  __isset = other214.__isset;
}
SpecValueSerialField::SpecValueSerialField(SpecValueSerialField&& other215) noexcept {
  field_id = other215.field_id;
  spec_int64 = std::move(other215.spec_int64);
  spec_double = std::move(other215.spec_double);
  spec_bytes = std::move(other215.spec_bytes);
  spec_key = std::move(other215.spec_key);
  spec_li = std::move(other215.spec_li);
  spec_lb = std::move(other215.spec_lb);
  __isset = other215.__isset;
}
SpecValueSerialField& SpecValueSerialField::operator=(const SpecValueSerialField& other216) {
  field_id = other216.field_id;
  spec_int64 = other216.spec_int64;
  spec_double = other216.spec_double;
  spec_bytes = other216.spec_bytes;
  spec_key = other216.spec_key;
  spec_li = other216.spec_li;
  spec_lb = other216.spec_lb;
  __isset = other216.__isset;
  return *this;
}
SpecValueSerialField& SpecValueSerialField::operator=(SpecValueSerialField&& other217) noexcept {
  field_id = other217.field_id;
  spec_int64 = std::move(other217.spec_int64);
  spec_double = std::move(other217.spec_double);
  spec_bytes = std::move(other217.spec_bytes);
  spec_key = std::move(other217.spec_key);
  spec_li = std::move(other217.spec_li);
  spec_lb = std::move(other217.spec_lb);
  __isset = other217.__isset;
  return *this;
}
void SpecValueSerialField::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerialField(";
  out << "field_id=" << to_string(field_id);
  out << ", " << "spec_int64="; (__isset.spec_int64 ? (out << to_string(spec_int64)) : (out << "<null>"));
  out << ", " << "spec_double="; (__isset.spec_double ? (out << to_string(spec_double)) : (out << "<null>"));
  out << ", " << "spec_bytes=" << to_string(spec_bytes);
  out << ", " << "spec_key=" << to_string(spec_key);
  out << ", " << "spec_li=" << to_string(spec_li);
  out << ", " << "spec_lb=" << to_string(spec_lb);
  out << ")";
}


SpecValueSerial::~SpecValueSerial() noexcept {
}


void SpecValueSerial::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial::__set_fields(const SpecValueSerialFields& val) {
  this->fields = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast218;
          xfer += iprot->readI32(ecast218);
          this->comp = static_cast<Comp::type>(ecast218);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size219;
            ::apache::thrift::protocol::TType _etype222;
            xfer += iprot->readListBegin(_etype222, _size219);
            this->fields.resize(_size219);
            uint32_t _i223;
            for (_i223 = 0; _i223 < _size219; ++_i223)
            {
              xfer += this->fields[_i223].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fields.size()));
    std::vector<SpecValueSerialField> ::const_iterator _iter224;
    for (_iter224 = this->fields.begin(); _iter224 != this->fields.end(); ++_iter224)
    {
      xfer += (*_iter224).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial &a, SpecValueSerial &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.fields, b.fields);
  swap(a.__isset, b.__isset);
}

SpecValueSerial::SpecValueSerial(const SpecValueSerial& other225) {
  comp = other225.comp;
  fields = other225.fields;
  __isset = other225.__isset;
}
SpecValueSerial::SpecValueSerial(SpecValueSerial&& other226) noexcept {
  comp = other226.comp;
  fields = std::move(other226.fields);
  __isset = other226.__isset;
}
SpecValueSerial& SpecValueSerial::operator=(const SpecValueSerial& other227) {
  comp = other227.comp;
  fields = other227.fields;
  __isset = other227.__isset;
  return *this;
}
SpecValueSerial& SpecValueSerial::operator=(SpecValueSerial&& other228) noexcept {
  comp = other228.comp;
  fields = std::move(other228.fields);
  __isset = other228.__isset;
  return *this;
}
void SpecValueSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial(";
  out << "comp=" << to_string(comp);
  out << ", " << "fields=" << to_string(fields);
  out << ")";
}


SpecIntervalSerial::~SpecIntervalSerial() noexcept {
}


void SpecIntervalSerial::__set_range_begin(const Key& val) {
  this->range_begin = val;
}

void SpecIntervalSerial::__set_range_end(const Key& val) {
  this->range_end = val;
}

void SpecIntervalSerial::__set_offset_key(const Key& val) {
  this->offset_key = val;
}

void SpecIntervalSerial::__set_offset_rev(const int64_t val) {
  this->offset_rev = val;
__isset.offset_rev = true;
}

void SpecIntervalSerial::__set_key_intervals(const SpecKeyIntervals& val) {
  this->key_intervals = val;
}

void SpecIntervalSerial::__set_values(const SpecValuesSerial& val) {
  this->values = val;
}

void SpecIntervalSerial::__set_ts_start(const SpecTimestamp& val) {
  this->ts_start = val;
__isset.ts_start = true;
}

void SpecIntervalSerial::__set_ts_finish(const SpecTimestamp& val) {
  this->ts_finish = val;
__isset.ts_finish = true;
}

void SpecIntervalSerial::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}

void SpecIntervalSerial::__set_options(const SpecIntervalOptions::type val) {
  this->options = val;
__isset.options = true;
}

void SpecIntervalSerial::__set_updating(const SpecIntervalUpdateSerial& val) {
  this->updating = val;
__isset.updating = true;
}
std::ostream& operator<<(std::ostream& out, const SpecIntervalSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecIntervalSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_begin.clear();
            uint32_t _size229;
            ::apache::thrift::protocol::TType _etype232;
            xfer += iprot->readListBegin(_etype232, _size229);
            this->range_begin.resize(_size229);
            uint32_t _i233;
            for (_i233 = 0; _i233 < _size229; ++_i233)
            {
              xfer += iprot->readBinary(this->range_begin[_i233]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_end.clear();
            uint32_t _size234;
            ::apache::thrift::protocol::TType _etype237;
            xfer += iprot->readListBegin(_etype237, _size234);
            this->range_end.resize(_size234);
            uint32_t _i238;
            for (_i238 = 0; _i238 < _size234; ++_i238)
            {
              xfer += iprot->readBinary(this->range_end[_i238]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->offset_key.clear();
            uint32_t _size239;
            ::apache::thrift::protocol::TType _etype242;
            xfer += iprot->readListBegin(_etype242, _size239);
            this->offset_key.resize(_size239);
            uint32_t _i243;
            for (_i243 = 0; _i243 < _size239; ++_i243)
            {
              xfer += iprot->readBinary(this->offset_key[_i243]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.offset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset_rev);
          this->__isset.offset_rev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_intervals.clear();
            uint32_t _size244;
            ::apache::thrift::protocol::TType _etype247;
            xfer += iprot->readListBegin(_etype247, _size244);
            this->key_intervals.resize(_size244);
            uint32_t _i248;
            for (_i248 = 0; _i248 < _size244; ++_i248)
            {
              xfer += this->key_intervals[_i248].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size249;
            ::apache::thrift::protocol::TType _etype252;
            xfer += iprot->readListBegin(_etype252, _size249);
            this->values.resize(_size249);
            uint32_t _i253;
            for (_i253 = 0; _i253 < _size249; ++_i253)
            {
              xfer += this->values[_i253].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_start.read(iprot);
          this->__isset.ts_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_finish.read(iprot);
          this->__isset.ts_finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast254;
          xfer += iprot->readI32(ecast254);
          this->options = static_cast<SpecIntervalOptions::type>(ecast254);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->updating.read(iprot);
          this->__isset.updating = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecIntervalSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecIntervalSerial");

  xfer += oprot->writeFieldBegin("range_begin", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_begin.size()));
    std::vector<std::string> ::const_iterator _iter255;
    for (_iter255 = this->range_begin.begin(); _iter255 != this->range_begin.end(); ++_iter255)
    {
      xfer += oprot->writeBinary((*_iter255));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range_end", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_end.size()));
    std::vector<std::string> ::const_iterator _iter256;
    for (_iter256 = this->range_end.begin(); _iter256 != this->range_end.end(); ++_iter256)
    {
      xfer += oprot->writeBinary((*_iter256));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset_key", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->offset_key.size()));
    std::vector<std::string> ::const_iterator _iter257;
    for (_iter257 = this->offset_key.begin(); _iter257 != this->offset_key.end(); ++_iter257)
    {
      xfer += oprot->writeBinary((*_iter257));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offset_rev) {
    xfer += oprot->writeFieldBegin("offset_rev", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->offset_rev);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("key_intervals", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->key_intervals.size()));
    std::vector<SpecKeyInterval> ::const_iterator _iter258;
    for (_iter258 = this->key_intervals.begin(); _iter258 != this->key_intervals.end(); ++_iter258)
    {
      xfer += (*_iter258).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector<SpecValueSerial> ::const_iterator _iter259;
    for (_iter259 = this->values.begin(); _iter259 != this->values.end(); ++_iter259)
    {
      xfer += (*_iter259).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts_start) {
    xfer += oprot->writeFieldBegin("ts_start", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->ts_start.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_finish) {
    xfer += oprot->writeFieldBegin("ts_finish", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->ts_finish.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(static_cast<int32_t>(this->options));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updating) {
    xfer += oprot->writeFieldBegin("updating", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->updating.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecIntervalSerial &a, SpecIntervalSerial &b) {
  using ::std::swap;
  swap(a.range_begin, b.range_begin);
  swap(a.range_end, b.range_end);
  swap(a.offset_key, b.offset_key);
  swap(a.offset_rev, b.offset_rev);
  swap(a.key_intervals, b.key_intervals);
  swap(a.values, b.values);
  swap(a.ts_start, b.ts_start);
  swap(a.ts_finish, b.ts_finish);
  swap(a.flags, b.flags);
  swap(a.options, b.options);
  swap(a.updating, b.updating);
  swap(a.__isset, b.__isset);
}

SpecIntervalSerial::SpecIntervalSerial(const SpecIntervalSerial& other260) {
  range_begin = other260.range_begin;
  range_end = other260.range_end;
  offset_key = other260.offset_key;
  offset_rev = other260.offset_rev;
  key_intervals = other260.key_intervals;
  values = other260.values;
  ts_start = other260.ts_start;
  ts_finish = other260.ts_finish;
  flags = other260.flags;
  options = other260.options;
  updating = other260.updating;
  __isset = other260.__isset;
}
SpecIntervalSerial::SpecIntervalSerial(SpecIntervalSerial&& other261) noexcept {
  range_begin = std::move(other261.range_begin);
  range_end = std::move(other261.range_end);
  offset_key = std::move(other261.offset_key);
  offset_rev = other261.offset_rev;
  key_intervals = std::move(other261.key_intervals);
  values = std::move(other261.values);
  ts_start = std::move(other261.ts_start);
  ts_finish = std::move(other261.ts_finish);
  flags = std::move(other261.flags);
  options = other261.options;
  updating = std::move(other261.updating);
  __isset = other261.__isset;
}
SpecIntervalSerial& SpecIntervalSerial::operator=(const SpecIntervalSerial& other262) {
  range_begin = other262.range_begin;
  range_end = other262.range_end;
  offset_key = other262.offset_key;
  offset_rev = other262.offset_rev;
  key_intervals = other262.key_intervals;
  values = other262.values;
  ts_start = other262.ts_start;
  ts_finish = other262.ts_finish;
  flags = other262.flags;
  options = other262.options;
  updating = other262.updating;
  __isset = other262.__isset;
  return *this;
}
SpecIntervalSerial& SpecIntervalSerial::operator=(SpecIntervalSerial&& other263) noexcept {
  range_begin = std::move(other263.range_begin);
  range_end = std::move(other263.range_end);
  offset_key = std::move(other263.offset_key);
  offset_rev = other263.offset_rev;
  key_intervals = std::move(other263.key_intervals);
  values = std::move(other263.values);
  ts_start = std::move(other263.ts_start);
  ts_finish = std::move(other263.ts_finish);
  flags = std::move(other263.flags);
  options = other263.options;
  updating = std::move(other263.updating);
  __isset = other263.__isset;
  return *this;
}
void SpecIntervalSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecIntervalSerial(";
  out << "range_begin=" << to_string(range_begin);
  out << ", " << "range_end=" << to_string(range_end);
  out << ", " << "offset_key=" << to_string(offset_key);
  out << ", " << "offset_rev="; (__isset.offset_rev ? (out << to_string(offset_rev)) : (out << "<null>"));
  out << ", " << "key_intervals=" << to_string(key_intervals);
  out << ", " << "values=" << to_string(values);
  out << ", " << "ts_start="; (__isset.ts_start ? (out << to_string(ts_start)) : (out << "<null>"));
  out << ", " << "ts_finish="; (__isset.ts_finish ? (out << to_string(ts_finish)) : (out << "<null>"));
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ", " << "updating="; (__isset.updating ? (out << to_string(updating)) : (out << "<null>"));
  out << ")";
}


SpecColumnSerial::~SpecColumnSerial() noexcept {
}


void SpecColumnSerial::__set_cid(const int64_t val) {
  this->cid = val;
}

void SpecColumnSerial::__set_intervals(const std::vector<SpecIntervalSerial> & val) {
  this->intervals = val;
}
std::ostream& operator<<(std::ostream& out, const SpecColumnSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecColumnSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->intervals.clear();
            uint32_t _size264;
            ::apache::thrift::protocol::TType _etype267;
            xfer += iprot->readListBegin(_etype267, _size264);
            this->intervals.resize(_size264);
            uint32_t _i268;
            for (_i268 = 0; _i268 < _size264; ++_i268)
            {
              xfer += this->intervals[_i268].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecColumnSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecColumnSerial");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intervals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->intervals.size()));
    std::vector<SpecIntervalSerial> ::const_iterator _iter269;
    for (_iter269 = this->intervals.begin(); _iter269 != this->intervals.end(); ++_iter269)
    {
      xfer += (*_iter269).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecColumnSerial &a, SpecColumnSerial &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.intervals, b.intervals);
  swap(a.__isset, b.__isset);
}

SpecColumnSerial::SpecColumnSerial(const SpecColumnSerial& other270) {
  cid = other270.cid;
  intervals = other270.intervals;
  __isset = other270.__isset;
}
SpecColumnSerial::SpecColumnSerial(SpecColumnSerial&& other271) noexcept {
  cid = other271.cid;
  intervals = std::move(other271.intervals);
  __isset = other271.__isset;
}
SpecColumnSerial& SpecColumnSerial::operator=(const SpecColumnSerial& other272) {
  cid = other272.cid;
  intervals = other272.intervals;
  __isset = other272.__isset;
  return *this;
}
SpecColumnSerial& SpecColumnSerial::operator=(SpecColumnSerial&& other273) noexcept {
  cid = other273.cid;
  intervals = std::move(other273.intervals);
  __isset = other273.__isset;
  return *this;
}
void SpecColumnSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecColumnSerial(";
  out << "cid=" << to_string(cid);
  out << ", " << "intervals=" << to_string(intervals);
  out << ")";
}


SpecScan::~SpecScan() noexcept {
}


void SpecScan::__set_columns(const std::vector<SpecColumn> & val) {
  this->columns = val;
}

void SpecScan::__set_columns_serial(const std::vector<SpecColumnSerial> & val) {
  this->columns_serial = val;
}

void SpecScan::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}
std::ostream& operator<<(std::ostream& out, const SpecScan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecScan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size274;
            ::apache::thrift::protocol::TType _etype277;
            xfer += iprot->readListBegin(_etype277, _size274);
            this->columns.resize(_size274);
            uint32_t _i278;
            for (_i278 = 0; _i278 < _size274; ++_i278)
            {
              xfer += this->columns[_i278].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns_serial.clear();
            uint32_t _size279;
            ::apache::thrift::protocol::TType _etype282;
            xfer += iprot->readListBegin(_etype282, _size279);
            this->columns_serial.resize(_size279);
            uint32_t _i283;
            for (_i283 = 0; _i283 < _size279; ++_i283)
            {
              xfer += this->columns_serial[_i283].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns_serial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecScan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecScan");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<SpecColumn> ::const_iterator _iter284;
    for (_iter284 = this->columns.begin(); _iter284 != this->columns.end(); ++_iter284)
    {
      xfer += (*_iter284).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns_serial", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns_serial.size()));
    std::vector<SpecColumnSerial> ::const_iterator _iter285;
    for (_iter285 = this->columns_serial.begin(); _iter285 != this->columns_serial.end(); ++_iter285)
    {
      xfer += (*_iter285).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecScan &a, SpecScan &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.columns_serial, b.columns_serial);
  swap(a.flags, b.flags);
  swap(a.__isset, b.__isset);
}

SpecScan::SpecScan(const SpecScan& other286) {
  columns = other286.columns;
  columns_serial = other286.columns_serial;
  flags = other286.flags;
  __isset = other286.__isset;
}
SpecScan::SpecScan(SpecScan&& other287) noexcept {
  columns = std::move(other287.columns);
  columns_serial = std::move(other287.columns_serial);
  flags = std::move(other287.flags);
  __isset = other287.__isset;
}
SpecScan& SpecScan::operator=(const SpecScan& other288) {
  columns = other288.columns;
  columns_serial = other288.columns_serial;
  flags = other288.flags;
  __isset = other288.__isset;
  return *this;
}
SpecScan& SpecScan::operator=(SpecScan&& other289) noexcept {
  columns = std::move(other289.columns);
  columns_serial = std::move(other289.columns_serial);
  flags = std::move(other289.flags);
  __isset = other289.__isset;
  return *this;
}
void SpecScan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecScan(";
  out << "columns=" << to_string(columns);
  out << ", " << "columns_serial=" << to_string(columns_serial);
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ")";
}


UCell::~UCell() noexcept {
}


void UCell::__set_f(const Flag::type val) {
  this->f = val;
}

void UCell::__set_k(const Key& val) {
  this->k = val;
}

void UCell::__set_ts(const int64_t val) {
  this->ts = val;
__isset.ts = true;
}

void UCell::__set_ts_desc(const bool val) {
  this->ts_desc = val;
__isset.ts_desc = true;
}

void UCell::__set_v(const std::string& val) {
  this->v = val;
}

void UCell::__set_encoder(const EncodingType::type val) {
  this->encoder = val;
__isset.encoder = true;
}
std::ostream& operator<<(std::ostream& out, const UCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast290;
          xfer += iprot->readI32(ecast290);
          this->f = static_cast<Flag::type>(ecast290);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size291;
            ::apache::thrift::protocol::TType _etype294;
            xfer += iprot->readListBegin(_etype294, _size291);
            this->k.resize(_size291);
            uint32_t _i295;
            for (_i295 = 0; _i295 < _size291; ++_i295)
            {
              xfer += iprot->readBinary(this->k[_i295]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ts_desc);
          this->__isset.ts_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast296;
          xfer += iprot->readI32(ecast296);
          this->encoder = static_cast<EncodingType::type>(ecast296);
          this->__isset.encoder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UCell");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->f));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter297;
    for (_iter297 = this->k.begin(); _iter297 != this->k.end(); ++_iter297)
    {
      xfer += oprot->writeBinary((*_iter297));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts) {
    xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_desc) {
    xfer += oprot->writeFieldBegin("ts_desc", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->ts_desc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.encoder) {
    xfer += oprot->writeFieldBegin("encoder", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->encoder));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UCell &a, UCell &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.ts_desc, b.ts_desc);
  swap(a.v, b.v);
  swap(a.encoder, b.encoder);
  swap(a.__isset, b.__isset);
}

UCell::UCell(const UCell& other298) {
  f = other298.f;
  k = other298.k;
  ts = other298.ts;
  ts_desc = other298.ts_desc;
  v = other298.v;
  encoder = other298.encoder;
  __isset = other298.__isset;
}
UCell::UCell(UCell&& other299) noexcept {
  f = other299.f;
  k = std::move(other299.k);
  ts = other299.ts;
  ts_desc = other299.ts_desc;
  v = std::move(other299.v);
  encoder = other299.encoder;
  __isset = other299.__isset;
}
UCell& UCell::operator=(const UCell& other300) {
  f = other300.f;
  k = other300.k;
  ts = other300.ts;
  ts_desc = other300.ts_desc;
  v = other300.v;
  encoder = other300.encoder;
  __isset = other300.__isset;
  return *this;
}
UCell& UCell::operator=(UCell&& other301) noexcept {
  f = other301.f;
  k = std::move(other301.k);
  ts = other301.ts;
  ts_desc = other301.ts_desc;
  v = std::move(other301.v);
  encoder = other301.encoder;
  __isset = other301.__isset;
  return *this;
}
void UCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UCell(";
  out << "f=" << to_string(f);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts="; (__isset.ts ? (out << to_string(ts)) : (out << "<null>"));
  out << ", " << "ts_desc="; (__isset.ts_desc ? (out << to_string(ts_desc)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ", " << "encoder="; (__isset.encoder ? (out << to_string(encoder)) : (out << "<null>"));
  out << ")";
}


CellValueSerial::~CellValueSerial() noexcept {
}


void CellValueSerial::__set_field_id(const int32_t val) {
  this->field_id = val;
}

void CellValueSerial::__set_v_int64(const int64_t val) {
  this->v_int64 = val;
__isset.v_int64 = true;
}

void CellValueSerial::__set_v_double(const double val) {
  this->v_double = val;
__isset.v_double = true;
}

void CellValueSerial::__set_v_bytes(const std::string& val) {
  this->v_bytes = val;
}

void CellValueSerial::__set_v_key(const Key& val) {
  this->v_key = val;
}

void CellValueSerial::__set_v_li(const std::vector<int64_t> & val) {
  this->v_li = val;
}

void CellValueSerial::__set_v_lb(const std::vector<std::string> & val) {
  this->v_lb = val;
}
std::ostream& operator<<(std::ostream& out, const CellValueSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellValueSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field_id);
          this->__isset.field_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v_int64);
          this->__isset.v_int64 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v_double);
          this->__isset.v_double = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v_bytes);
          this->__isset.v_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_key.clear();
            uint32_t _size302;
            ::apache::thrift::protocol::TType _etype305;
            xfer += iprot->readListBegin(_etype305, _size302);
            this->v_key.resize(_size302);
            uint32_t _i306;
            for (_i306 = 0; _i306 < _size302; ++_i306)
            {
              xfer += iprot->readBinary(this->v_key[_i306]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_li.clear();
            uint32_t _size307;
            ::apache::thrift::protocol::TType _etype310;
            xfer += iprot->readListBegin(_etype310, _size307);
            this->v_li.resize(_size307);
            uint32_t _i311;
            for (_i311 = 0; _i311 < _size307; ++_i311)
            {
              xfer += iprot->readI64(this->v_li[_i311]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_li = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_lb.clear();
            uint32_t _size312;
            ::apache::thrift::protocol::TType _etype315;
            xfer += iprot->readListBegin(_etype315, _size312);
            this->v_lb.resize(_size312);
            uint32_t _i316;
            for (_i316 = 0; _i316 < _size312; ++_i316)
            {
              xfer += iprot->readBinary(this->v_lb[_i316]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_lb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellValueSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellValueSerial");

  xfer += oprot->writeFieldBegin("field_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.v_int64) {
    xfer += oprot->writeFieldBegin("v_int64", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->v_int64);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_double) {
    xfer += oprot->writeFieldBegin("v_double", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->v_double);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v_bytes", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->v_bytes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_key", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->v_key.size()));
    std::vector<std::string> ::const_iterator _iter317;
    for (_iter317 = this->v_key.begin(); _iter317 != this->v_key.end(); ++_iter317)
    {
      xfer += oprot->writeBinary((*_iter317));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_li", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->v_li.size()));
    std::vector<int64_t> ::const_iterator _iter318;
    for (_iter318 = this->v_li.begin(); _iter318 != this->v_li.end(); ++_iter318)
    {
      xfer += oprot->writeI64((*_iter318));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_lb", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->v_lb.size()));
    std::vector<std::string> ::const_iterator _iter319;
    for (_iter319 = this->v_lb.begin(); _iter319 != this->v_lb.end(); ++_iter319)
    {
      xfer += oprot->writeBinary((*_iter319));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellValueSerial &a, CellValueSerial &b) {
  using ::std::swap;
  swap(a.field_id, b.field_id);
  swap(a.v_int64, b.v_int64);
  swap(a.v_double, b.v_double);
  swap(a.v_bytes, b.v_bytes);
  swap(a.v_key, b.v_key);
  swap(a.v_li, b.v_li);
  swap(a.v_lb, b.v_lb);
  swap(a.__isset, b.__isset);
}

CellValueSerial::CellValueSerial(const CellValueSerial& other320) {
  field_id = other320.field_id;
  v_int64 = other320.v_int64;
  v_double = other320.v_double;
  v_bytes = other320.v_bytes;
  v_key = other320.v_key;
  v_li = other320.v_li;
  v_lb = other320.v_lb;
  __isset = other320.__isset;
}
CellValueSerial::CellValueSerial(CellValueSerial&& other321) noexcept {
  field_id = other321.field_id;
  v_int64 = other321.v_int64;
  v_double = other321.v_double;
  v_bytes = std::move(other321.v_bytes);
  v_key = std::move(other321.v_key);
  v_li = std::move(other321.v_li);
  v_lb = std::move(other321.v_lb);
  __isset = other321.__isset;
}
CellValueSerial& CellValueSerial::operator=(const CellValueSerial& other322) {
  field_id = other322.field_id;
  v_int64 = other322.v_int64;
  v_double = other322.v_double;
  v_bytes = other322.v_bytes;
  v_key = other322.v_key;
  v_li = other322.v_li;
  v_lb = other322.v_lb;
  __isset = other322.__isset;
  return *this;
}
CellValueSerial& CellValueSerial::operator=(CellValueSerial&& other323) noexcept {
  field_id = other323.field_id;
  v_int64 = other323.v_int64;
  v_double = other323.v_double;
  v_bytes = std::move(other323.v_bytes);
  v_key = std::move(other323.v_key);
  v_li = std::move(other323.v_li);
  v_lb = std::move(other323.v_lb);
  __isset = other323.__isset;
  return *this;
}
void CellValueSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellValueSerial(";
  out << "field_id=" << to_string(field_id);
  out << ", " << "v_int64="; (__isset.v_int64 ? (out << to_string(v_int64)) : (out << "<null>"));
  out << ", " << "v_double="; (__isset.v_double ? (out << to_string(v_double)) : (out << "<null>"));
  out << ", " << "v_bytes=" << to_string(v_bytes);
  out << ", " << "v_key=" << to_string(v_key);
  out << ", " << "v_li=" << to_string(v_li);
  out << ", " << "v_lb=" << to_string(v_lb);
  out << ")";
}


FU_INT64::~FU_INT64() noexcept {
}


void FU_INT64::__set_ctrl(const int8_t val) {
  this->ctrl = val;
}

void FU_INT64::__set_op(const FU_MATH_OP::type val) {
  this->op = val;
}

void FU_INT64::__set_pos(const int32_t val) {
  this->pos = val;
__isset.pos = true;
}

void FU_INT64::__set_comp(const Comp::type val) {
  this->comp = val;
__isset.comp = true;
}

void FU_INT64::__set_v(const int64_t val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FU_INT64& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FU_INT64::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ctrl);
          this->__isset.ctrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast324;
          xfer += iprot->readI32(ecast324);
          this->op = static_cast<FU_MATH_OP::type>(ecast324);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast325;
          xfer += iprot->readI32(ecast325);
          this->comp = static_cast<Comp::type>(ecast325);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FU_INT64::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FU_INT64");

  xfer += oprot->writeFieldBegin("ctrl", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ctrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->op));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comp) {
    xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FU_INT64 &a, FU_INT64 &b) {
  using ::std::swap;
  swap(a.ctrl, b.ctrl);
  swap(a.op, b.op);
  swap(a.pos, b.pos);
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FU_INT64::FU_INT64(const FU_INT64& other326) noexcept {
  ctrl = other326.ctrl;
  op = other326.op;
  pos = other326.pos;
  comp = other326.comp;
  v = other326.v;
  __isset = other326.__isset;
}
FU_INT64::FU_INT64(FU_INT64&& other327) noexcept {
  ctrl = other327.ctrl;
  op = other327.op;
  pos = other327.pos;
  comp = other327.comp;
  v = other327.v;
  __isset = other327.__isset;
}
FU_INT64& FU_INT64::operator=(const FU_INT64& other328) noexcept {
  ctrl = other328.ctrl;
  op = other328.op;
  pos = other328.pos;
  comp = other328.comp;
  v = other328.v;
  __isset = other328.__isset;
  return *this;
}
FU_INT64& FU_INT64::operator=(FU_INT64&& other329) noexcept {
  ctrl = other329.ctrl;
  op = other329.op;
  pos = other329.pos;
  comp = other329.comp;
  v = other329.v;
  __isset = other329.__isset;
  return *this;
}
void FU_INT64::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FU_INT64(";
  out << "ctrl=" << to_string(ctrl);
  out << ", " << "op=" << to_string(op);
  out << ", " << "pos="; (__isset.pos ? (out << to_string(pos)) : (out << "<null>"));
  out << ", " << "comp="; (__isset.comp ? (out << to_string(comp)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FU_DOUBLE::~FU_DOUBLE() noexcept {
}


void FU_DOUBLE::__set_ctrl(const int8_t val) {
  this->ctrl = val;
}

void FU_DOUBLE::__set_op(const FU_MATH_OP::type val) {
  this->op = val;
}

void FU_DOUBLE::__set_pos(const int32_t val) {
  this->pos = val;
__isset.pos = true;
}

void FU_DOUBLE::__set_comp(const Comp::type val) {
  this->comp = val;
__isset.comp = true;
}

void FU_DOUBLE::__set_v(const double val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FU_DOUBLE& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FU_DOUBLE::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ctrl);
          this->__isset.ctrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast330;
          xfer += iprot->readI32(ecast330);
          this->op = static_cast<FU_MATH_OP::type>(ecast330);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast331;
          xfer += iprot->readI32(ecast331);
          this->comp = static_cast<Comp::type>(ecast331);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FU_DOUBLE::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FU_DOUBLE");

  xfer += oprot->writeFieldBegin("ctrl", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ctrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->op));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comp) {
    xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FU_DOUBLE &a, FU_DOUBLE &b) {
  using ::std::swap;
  swap(a.ctrl, b.ctrl);
  swap(a.op, b.op);
  swap(a.pos, b.pos);
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FU_DOUBLE::FU_DOUBLE(const FU_DOUBLE& other332) noexcept {
  ctrl = other332.ctrl;
  op = other332.op;
  pos = other332.pos;
  comp = other332.comp;
  v = other332.v;
  __isset = other332.__isset;
}
FU_DOUBLE::FU_DOUBLE(FU_DOUBLE&& other333) noexcept {
  ctrl = other333.ctrl;
  op = other333.op;
  pos = other333.pos;
  comp = other333.comp;
  v = other333.v;
  __isset = other333.__isset;
}
FU_DOUBLE& FU_DOUBLE::operator=(const FU_DOUBLE& other334) noexcept {
  ctrl = other334.ctrl;
  op = other334.op;
  pos = other334.pos;
  comp = other334.comp;
  v = other334.v;
  __isset = other334.__isset;
  return *this;
}
FU_DOUBLE& FU_DOUBLE::operator=(FU_DOUBLE&& other335) noexcept {
  ctrl = other335.ctrl;
  op = other335.op;
  pos = other335.pos;
  comp = other335.comp;
  v = other335.v;
  __isset = other335.__isset;
  return *this;
}
void FU_DOUBLE::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FU_DOUBLE(";
  out << "ctrl=" << to_string(ctrl);
  out << ", " << "op=" << to_string(op);
  out << ", " << "pos="; (__isset.pos ? (out << to_string(pos)) : (out << "<null>"));
  out << ", " << "comp="; (__isset.comp ? (out << to_string(comp)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FU_BYTES::~FU_BYTES() noexcept {
}


void FU_BYTES::__set_ctrl(const int8_t val) {
  this->ctrl = val;
}

void FU_BYTES::__set_op(const FU_LIST_OP::type val) {
  this->op = val;
}

void FU_BYTES::__set_pos(const int32_t val) {
  this->pos = val;
__isset.pos = true;
}

void FU_BYTES::__set_comp(const Comp::type val) {
  this->comp = val;
__isset.comp = true;
}

void FU_BYTES::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FU_BYTES& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FU_BYTES::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ctrl);
          this->__isset.ctrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast336;
          xfer += iprot->readI32(ecast336);
          this->op = static_cast<FU_LIST_OP::type>(ecast336);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast337;
          xfer += iprot->readI32(ecast337);
          this->comp = static_cast<Comp::type>(ecast337);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FU_BYTES::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FU_BYTES");

  xfer += oprot->writeFieldBegin("ctrl", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ctrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->op));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comp) {
    xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FU_BYTES &a, FU_BYTES &b) {
  using ::std::swap;
  swap(a.ctrl, b.ctrl);
  swap(a.op, b.op);
  swap(a.pos, b.pos);
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FU_BYTES::FU_BYTES(const FU_BYTES& other338) {
  ctrl = other338.ctrl;
  op = other338.op;
  pos = other338.pos;
  comp = other338.comp;
  v = other338.v;
  __isset = other338.__isset;
}
FU_BYTES::FU_BYTES(FU_BYTES&& other339) noexcept {
  ctrl = other339.ctrl;
  op = other339.op;
  pos = other339.pos;
  comp = other339.comp;
  v = std::move(other339.v);
  __isset = other339.__isset;
}
FU_BYTES& FU_BYTES::operator=(const FU_BYTES& other340) {
  ctrl = other340.ctrl;
  op = other340.op;
  pos = other340.pos;
  comp = other340.comp;
  v = other340.v;
  __isset = other340.__isset;
  return *this;
}
FU_BYTES& FU_BYTES::operator=(FU_BYTES&& other341) noexcept {
  ctrl = other341.ctrl;
  op = other341.op;
  pos = other341.pos;
  comp = other341.comp;
  v = std::move(other341.v);
  __isset = other341.__isset;
  return *this;
}
void FU_BYTES::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FU_BYTES(";
  out << "ctrl=" << to_string(ctrl);
  out << ", " << "op=" << to_string(op);
  out << ", " << "pos="; (__isset.pos ? (out << to_string(pos)) : (out << "<null>"));
  out << ", " << "comp="; (__isset.comp ? (out << to_string(comp)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FU_LI::~FU_LI() noexcept {
}


void FU_LI::__set_ctrl(const int8_t val) {
  this->ctrl = val;
}

void FU_LI::__set_op(const FU_LIST_OP::type val) {
  this->op = val;
}

void FU_LI::__set_pos(const int32_t val) {
  this->pos = val;
__isset.pos = true;
}

void FU_LI::__set_v(const std::vector<FU_INT64> & val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FU_LI& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FU_LI::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ctrl);
          this->__isset.ctrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast342;
          xfer += iprot->readI32(ecast342);
          this->op = static_cast<FU_LIST_OP::type>(ecast342);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size343;
            ::apache::thrift::protocol::TType _etype346;
            xfer += iprot->readListBegin(_etype346, _size343);
            this->v.resize(_size343);
            uint32_t _i347;
            for (_i347 = 0; _i347 < _size343; ++_i347)
            {
              xfer += this->v[_i347].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FU_LI::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FU_LI");

  xfer += oprot->writeFieldBegin("ctrl", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ctrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->op));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<FU_INT64> ::const_iterator _iter348;
    for (_iter348 = this->v.begin(); _iter348 != this->v.end(); ++_iter348)
    {
      xfer += (*_iter348).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FU_LI &a, FU_LI &b) {
  using ::std::swap;
  swap(a.ctrl, b.ctrl);
  swap(a.op, b.op);
  swap(a.pos, b.pos);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FU_LI::FU_LI(const FU_LI& other349) {
  ctrl = other349.ctrl;
  op = other349.op;
  pos = other349.pos;
  v = other349.v;
  __isset = other349.__isset;
}
FU_LI::FU_LI(FU_LI&& other350) noexcept {
  ctrl = other350.ctrl;
  op = other350.op;
  pos = other350.pos;
  v = std::move(other350.v);
  __isset = other350.__isset;
}
FU_LI& FU_LI::operator=(const FU_LI& other351) {
  ctrl = other351.ctrl;
  op = other351.op;
  pos = other351.pos;
  v = other351.v;
  __isset = other351.__isset;
  return *this;
}
FU_LI& FU_LI::operator=(FU_LI&& other352) noexcept {
  ctrl = other352.ctrl;
  op = other352.op;
  pos = other352.pos;
  v = std::move(other352.v);
  __isset = other352.__isset;
  return *this;
}
void FU_LI::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FU_LI(";
  out << "ctrl=" << to_string(ctrl);
  out << ", " << "op=" << to_string(op);
  out << ", " << "pos="; (__isset.pos ? (out << to_string(pos)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FU_LB::~FU_LB() noexcept {
}


void FU_LB::__set_ctrl(const int8_t val) {
  this->ctrl = val;
}

void FU_LB::__set_op(const FU_LIST_OP::type val) {
  this->op = val;
}

void FU_LB::__set_pos(const int32_t val) {
  this->pos = val;
__isset.pos = true;
}

void FU_LB::__set_v(const std::vector<FU_BYTES> & val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FU_LB& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FU_LB::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ctrl);
          this->__isset.ctrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast353;
          xfer += iprot->readI32(ecast353);
          this->op = static_cast<FU_LIST_OP::type>(ecast353);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size354;
            ::apache::thrift::protocol::TType _etype357;
            xfer += iprot->readListBegin(_etype357, _size354);
            this->v.resize(_size354);
            uint32_t _i358;
            for (_i358 = 0; _i358 < _size354; ++_i358)
            {
              xfer += this->v[_i358].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FU_LB::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FU_LB");

  xfer += oprot->writeFieldBegin("ctrl", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ctrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->op));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<FU_BYTES> ::const_iterator _iter359;
    for (_iter359 = this->v.begin(); _iter359 != this->v.end(); ++_iter359)
    {
      xfer += (*_iter359).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FU_LB &a, FU_LB &b) {
  using ::std::swap;
  swap(a.ctrl, b.ctrl);
  swap(a.op, b.op);
  swap(a.pos, b.pos);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FU_LB::FU_LB(const FU_LB& other360) {
  ctrl = other360.ctrl;
  op = other360.op;
  pos = other360.pos;
  v = other360.v;
  __isset = other360.__isset;
}
FU_LB::FU_LB(FU_LB&& other361) noexcept {
  ctrl = other361.ctrl;
  op = other361.op;
  pos = other361.pos;
  v = std::move(other361.v);
  __isset = other361.__isset;
}
FU_LB& FU_LB::operator=(const FU_LB& other362) {
  ctrl = other362.ctrl;
  op = other362.op;
  pos = other362.pos;
  v = other362.v;
  __isset = other362.__isset;
  return *this;
}
FU_LB& FU_LB::operator=(FU_LB&& other363) noexcept {
  ctrl = other363.ctrl;
  op = other363.op;
  pos = other363.pos;
  v = std::move(other363.v);
  __isset = other363.__isset;
  return *this;
}
void FU_LB::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FU_LB(";
  out << "ctrl=" << to_string(ctrl);
  out << ", " << "op=" << to_string(op);
  out << ", " << "pos="; (__isset.pos ? (out << to_string(pos)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ")";
}


CellValueSerialOp::~CellValueSerialOp() noexcept {
}


void CellValueSerialOp::__set_field_id(const int32_t val) {
  this->field_id = val;
}

void CellValueSerialOp::__set_v_int64(const FU_INT64& val) {
  this->v_int64 = val;
__isset.v_int64 = true;
}

void CellValueSerialOp::__set_v_double(const FU_DOUBLE& val) {
  this->v_double = val;
__isset.v_double = true;
}

void CellValueSerialOp::__set_v_bytes(const FU_BYTES& val) {
  this->v_bytes = val;
__isset.v_bytes = true;
}

void CellValueSerialOp::__set_v_key(const Key& val) {
  this->v_key = val;
}

void CellValueSerialOp::__set_v_li(const FU_LI& val) {
  this->v_li = val;
__isset.v_li = true;
}

void CellValueSerialOp::__set_v_lb(const FU_LB& val) {
  this->v_lb = val;
__isset.v_lb = true;
}
std::ostream& operator<<(std::ostream& out, const CellValueSerialOp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellValueSerialOp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field_id);
          this->__isset.field_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v_int64.read(iprot);
          this->__isset.v_int64 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v_double.read(iprot);
          this->__isset.v_double = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v_bytes.read(iprot);
          this->__isset.v_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_key.clear();
            uint32_t _size364;
            ::apache::thrift::protocol::TType _etype367;
            xfer += iprot->readListBegin(_etype367, _size364);
            this->v_key.resize(_size364);
            uint32_t _i368;
            for (_i368 = 0; _i368 < _size364; ++_i368)
            {
              xfer += iprot->readBinary(this->v_key[_i368]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v_li.read(iprot);
          this->__isset.v_li = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v_lb.read(iprot);
          this->__isset.v_lb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellValueSerialOp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellValueSerialOp");

  xfer += oprot->writeFieldBegin("field_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.v_int64) {
    xfer += oprot->writeFieldBegin("v_int64", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->v_int64.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_double) {
    xfer += oprot->writeFieldBegin("v_double", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->v_double.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_bytes) {
    xfer += oprot->writeFieldBegin("v_bytes", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->v_bytes.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v_key", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->v_key.size()));
    std::vector<std::string> ::const_iterator _iter369;
    for (_iter369 = this->v_key.begin(); _iter369 != this->v_key.end(); ++_iter369)
    {
      xfer += oprot->writeBinary((*_iter369));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.v_li) {
    xfer += oprot->writeFieldBegin("v_li", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->v_li.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_lb) {
    xfer += oprot->writeFieldBegin("v_lb", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->v_lb.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellValueSerialOp &a, CellValueSerialOp &b) {
  using ::std::swap;
  swap(a.field_id, b.field_id);
  swap(a.v_int64, b.v_int64);
  swap(a.v_double, b.v_double);
  swap(a.v_bytes, b.v_bytes);
  swap(a.v_key, b.v_key);
  swap(a.v_li, b.v_li);
  swap(a.v_lb, b.v_lb);
  swap(a.__isset, b.__isset);
}

CellValueSerialOp::CellValueSerialOp(const CellValueSerialOp& other370) {
  field_id = other370.field_id;
  v_int64 = other370.v_int64;
  v_double = other370.v_double;
  v_bytes = other370.v_bytes;
  v_key = other370.v_key;
  v_li = other370.v_li;
  v_lb = other370.v_lb;
  __isset = other370.__isset;
}
CellValueSerialOp::CellValueSerialOp(CellValueSerialOp&& other371) noexcept {
  field_id = other371.field_id;
  v_int64 = std::move(other371.v_int64);
  v_double = std::move(other371.v_double);
  v_bytes = std::move(other371.v_bytes);
  v_key = std::move(other371.v_key);
  v_li = std::move(other371.v_li);
  v_lb = std::move(other371.v_lb);
  __isset = other371.__isset;
}
CellValueSerialOp& CellValueSerialOp::operator=(const CellValueSerialOp& other372) {
  field_id = other372.field_id;
  v_int64 = other372.v_int64;
  v_double = other372.v_double;
  v_bytes = other372.v_bytes;
  v_key = other372.v_key;
  v_li = other372.v_li;
  v_lb = other372.v_lb;
  __isset = other372.__isset;
  return *this;
}
CellValueSerialOp& CellValueSerialOp::operator=(CellValueSerialOp&& other373) noexcept {
  field_id = other373.field_id;
  v_int64 = std::move(other373.v_int64);
  v_double = std::move(other373.v_double);
  v_bytes = std::move(other373.v_bytes);
  v_key = std::move(other373.v_key);
  v_li = std::move(other373.v_li);
  v_lb = std::move(other373.v_lb);
  __isset = other373.__isset;
  return *this;
}
void CellValueSerialOp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellValueSerialOp(";
  out << "field_id=" << to_string(field_id);
  out << ", " << "v_int64="; (__isset.v_int64 ? (out << to_string(v_int64)) : (out << "<null>"));
  out << ", " << "v_double="; (__isset.v_double ? (out << to_string(v_double)) : (out << "<null>"));
  out << ", " << "v_bytes="; (__isset.v_bytes ? (out << to_string(v_bytes)) : (out << "<null>"));
  out << ", " << "v_key=" << to_string(v_key);
  out << ", " << "v_li="; (__isset.v_li ? (out << to_string(v_li)) : (out << "<null>"));
  out << ", " << "v_lb="; (__isset.v_lb ? (out << to_string(v_lb)) : (out << "<null>"));
  out << ")";
}


UCellSerial::~UCellSerial() noexcept {
}


void UCellSerial::__set_f(const Flag::type val) {
  this->f = val;
}

void UCellSerial::__set_k(const Key& val) {
  this->k = val;
}

void UCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
__isset.ts = true;
}

void UCellSerial::__set_ts_desc(const bool val) {
  this->ts_desc = val;
__isset.ts_desc = true;
}

void UCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}

void UCellSerial::__set_encoder(const EncodingType::type val) {
  this->encoder = val;
__isset.encoder = true;
}
std::ostream& operator<<(std::ostream& out, const UCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast374;
          xfer += iprot->readI32(ecast374);
          this->f = static_cast<Flag::type>(ecast374);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size375;
            ::apache::thrift::protocol::TType _etype378;
            xfer += iprot->readListBegin(_etype378, _size375);
            this->k.resize(_size375);
            uint32_t _i379;
            for (_i379 = 0; _i379 < _size375; ++_i379)
            {
              xfer += iprot->readBinary(this->k[_i379]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ts_desc);
          this->__isset.ts_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size380;
            ::apache::thrift::protocol::TType _etype383;
            xfer += iprot->readListBegin(_etype383, _size380);
            this->v.resize(_size380);
            uint32_t _i384;
            for (_i384 = 0; _i384 < _size380; ++_i384)
            {
              xfer += this->v[_i384].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast385;
          xfer += iprot->readI32(ecast385);
          this->encoder = static_cast<EncodingType::type>(ecast385);
          this->__isset.encoder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UCellSerial");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->f));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter386;
    for (_iter386 = this->k.begin(); _iter386 != this->k.end(); ++_iter386)
    {
      xfer += oprot->writeBinary((*_iter386));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts) {
    xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_desc) {
    xfer += oprot->writeFieldBegin("ts_desc", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->ts_desc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter387;
    for (_iter387 = this->v.begin(); _iter387 != this->v.end(); ++_iter387)
    {
      xfer += (*_iter387).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.encoder) {
    xfer += oprot->writeFieldBegin("encoder", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->encoder));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UCellSerial &a, UCellSerial &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.ts_desc, b.ts_desc);
  swap(a.v, b.v);
  swap(a.encoder, b.encoder);
  swap(a.__isset, b.__isset);
}

UCellSerial::UCellSerial(const UCellSerial& other388) {
  f = other388.f;
  k = other388.k;
  ts = other388.ts;
  ts_desc = other388.ts_desc;
  v = other388.v;
  encoder = other388.encoder;
  __isset = other388.__isset;
}
UCellSerial::UCellSerial(UCellSerial&& other389) noexcept {
  f = other389.f;
  k = std::move(other389.k);
  ts = other389.ts;
  ts_desc = other389.ts_desc;
  v = std::move(other389.v);
  encoder = other389.encoder;
  __isset = other389.__isset;
}
UCellSerial& UCellSerial::operator=(const UCellSerial& other390) {
  f = other390.f;
  k = other390.k;
  ts = other390.ts;
  ts_desc = other390.ts_desc;
  v = other390.v;
  encoder = other390.encoder;
  __isset = other390.__isset;
  return *this;
}
UCellSerial& UCellSerial::operator=(UCellSerial&& other391) noexcept {
  f = other391.f;
  k = std::move(other391.k);
  ts = other391.ts;
  ts_desc = other391.ts_desc;
  v = std::move(other391.v);
  encoder = other391.encoder;
  __isset = other391.__isset;
  return *this;
}
void UCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UCellSerial(";
  out << "f=" << to_string(f);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts="; (__isset.ts ? (out << to_string(ts)) : (out << "<null>"));
  out << ", " << "ts_desc="; (__isset.ts_desc ? (out << to_string(ts_desc)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ", " << "encoder="; (__isset.encoder ? (out << to_string(encoder)) : (out << "<null>"));
  out << ")";
}


Cell::~Cell() noexcept {
}


void Cell::__set_c(const std::string& val) {
  this->c = val;
}

void Cell::__set_k(const Key& val) {
  this->k = val;
}

void Cell::__set_ts(const int64_t val) {
  this->ts = val;
}

void Cell::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const Cell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size392;
            ::apache::thrift::protocol::TType _etype395;
            xfer += iprot->readListBegin(_etype395, _size392);
            this->k.resize(_size392);
            uint32_t _i396;
            for (_i396 = 0; _i396 < _size392; ++_i396)
            {
              xfer += iprot->readBinary(this->k[_i396]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cell");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter397;
    for (_iter397 = this->k.begin(); _iter397 != this->k.end(); ++_iter397)
    {
      xfer += oprot->writeBinary((*_iter397));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cell &a, Cell &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

Cell::Cell(const Cell& other398) {
  c = other398.c;
  k = other398.k;
  ts = other398.ts;
  v = other398.v;
  __isset = other398.__isset;
}
Cell::Cell(Cell&& other399) noexcept {
  c = std::move(other399.c);
  k = std::move(other399.k);
  ts = other399.ts;
  v = std::move(other399.v);
  __isset = other399.__isset;
}
Cell& Cell::operator=(const Cell& other400) {
  c = other400.c;
  k = other400.k;
  ts = other400.ts;
  v = other400.v;
  __isset = other400.__isset;
  return *this;
}
Cell& Cell::operator=(Cell&& other401) noexcept {
  c = std::move(other401.c);
  k = std::move(other401.k);
  ts = other401.ts;
  v = std::move(other401.v);
  __isset = other401.__isset;
  return *this;
}
void Cell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cell(";
  out << "c=" << to_string(c);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


CellSerial::~CellSerial() noexcept {
}


void CellSerial::__set_c(const std::string& val) {
  this->c = val;
}

void CellSerial::__set_k(const Key& val) {
  this->k = val;
}

void CellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void CellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const CellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size402;
            ::apache::thrift::protocol::TType _etype405;
            xfer += iprot->readListBegin(_etype405, _size402);
            this->k.resize(_size402);
            uint32_t _i406;
            for (_i406 = 0; _i406 < _size402; ++_i406)
            {
              xfer += iprot->readBinary(this->k[_i406]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size407;
            ::apache::thrift::protocol::TType _etype410;
            xfer += iprot->readListBegin(_etype410, _size407);
            this->v.resize(_size407);
            uint32_t _i411;
            for (_i411 = 0; _i411 < _size407; ++_i411)
            {
              xfer += this->v[_i411].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellSerial");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter412;
    for (_iter412 = this->k.begin(); _iter412 != this->k.end(); ++_iter412)
    {
      xfer += oprot->writeBinary((*_iter412));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter413;
    for (_iter413 = this->v.begin(); _iter413 != this->v.end(); ++_iter413)
    {
      xfer += (*_iter413).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellSerial &a, CellSerial &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CellSerial::CellSerial(const CellSerial& other414) {
  c = other414.c;
  k = other414.k;
  ts = other414.ts;
  v = other414.v;
  __isset = other414.__isset;
}
CellSerial::CellSerial(CellSerial&& other415) noexcept {
  c = std::move(other415.c);
  k = std::move(other415.k);
  ts = other415.ts;
  v = std::move(other415.v);
  __isset = other415.__isset;
}
CellSerial& CellSerial::operator=(const CellSerial& other416) {
  c = other416.c;
  k = other416.k;
  ts = other416.ts;
  v = other416.v;
  __isset = other416.__isset;
  return *this;
}
CellSerial& CellSerial::operator=(CellSerial&& other417) noexcept {
  c = std::move(other417.c);
  k = std::move(other417.k);
  ts = other417.ts;
  v = std::move(other417.v);
  __isset = other417.__isset;
  return *this;
}
void CellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellSerial(";
  out << "c=" << to_string(c);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


Cells::~Cells() noexcept {
}


void Cells::__set_cells(const std::vector<Cell> & val) {
  this->cells = val;
}

void Cells::__set_serial_cells(const std::vector<CellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const Cells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size418;
            ::apache::thrift::protocol::TType _etype421;
            xfer += iprot->readListBegin(_etype421, _size418);
            this->cells.resize(_size418);
            uint32_t _i422;
            for (_i422 = 0; _i422 < _size418; ++_i422)
            {
              xfer += this->cells[_i422].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size423;
            ::apache::thrift::protocol::TType _etype426;
            xfer += iprot->readListBegin(_etype426, _size423);
            this->serial_cells.resize(_size423);
            uint32_t _i427;
            for (_i427 = 0; _i427 < _size423; ++_i427)
            {
              xfer += this->serial_cells[_i427].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cells");

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<Cell> ::const_iterator _iter428;
    for (_iter428 = this->cells.begin(); _iter428 != this->cells.end(); ++_iter428)
    {
      xfer += (*_iter428).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<CellSerial> ::const_iterator _iter429;
    for (_iter429 = this->serial_cells.begin(); _iter429 != this->serial_cells.end(); ++_iter429)
    {
      xfer += (*_iter429).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cells &a, Cells &b) {
  using ::std::swap;
  swap(a.cells, b.cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

Cells::Cells(const Cells& other430) {
  cells = other430.cells;
  serial_cells = other430.serial_cells;
  __isset = other430.__isset;
}
Cells::Cells(Cells&& other431) noexcept {
  cells = std::move(other431.cells);
  serial_cells = std::move(other431.serial_cells);
  __isset = other431.__isset;
}
Cells& Cells::operator=(const Cells& other432) {
  cells = other432.cells;
  serial_cells = other432.serial_cells;
  __isset = other432.__isset;
  return *this;
}
Cells& Cells::operator=(Cells&& other433) noexcept {
  cells = std::move(other433.cells);
  serial_cells = std::move(other433.serial_cells);
  __isset = other433.__isset;
  return *this;
}
void Cells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cells(";
  out << "cells=" << to_string(cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


CCell::~CCell() noexcept {
}


void CCell::__set_k(const Key& val) {
  this->k = val;
}

void CCell::__set_ts(const int64_t val) {
  this->ts = val;
}

void CCell::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const CCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size434;
            ::apache::thrift::protocol::TType _etype437;
            xfer += iprot->readListBegin(_etype437, _size434);
            this->k.resize(_size434);
            uint32_t _i438;
            for (_i438 = 0; _i438 < _size434; ++_i438)
            {
              xfer += iprot->readBinary(this->k[_i438]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCell");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter439;
    for (_iter439 = this->k.begin(); _iter439 != this->k.end(); ++_iter439)
    {
      xfer += oprot->writeBinary((*_iter439));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCell &a, CCell &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CCell::CCell(const CCell& other440) {
  k = other440.k;
  ts = other440.ts;
  v = other440.v;
  __isset = other440.__isset;
}
CCell::CCell(CCell&& other441) noexcept {
  k = std::move(other441.k);
  ts = other441.ts;
  v = std::move(other441.v);
  __isset = other441.__isset;
}
CCell& CCell::operator=(const CCell& other442) {
  k = other442.k;
  ts = other442.ts;
  v = other442.v;
  __isset = other442.__isset;
  return *this;
}
CCell& CCell::operator=(CCell&& other443) noexcept {
  k = std::move(other443.k);
  ts = other443.ts;
  v = std::move(other443.v);
  __isset = other443.__isset;
  return *this;
}
void CCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCell(";
  out << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


CCellSerial::~CCellSerial() noexcept {
}


void CCellSerial::__set_k(const Key& val) {
  this->k = val;
}

void CCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void CCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const CCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size444;
            ::apache::thrift::protocol::TType _etype447;
            xfer += iprot->readListBegin(_etype447, _size444);
            this->k.resize(_size444);
            uint32_t _i448;
            for (_i448 = 0; _i448 < _size444; ++_i448)
            {
              xfer += iprot->readBinary(this->k[_i448]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size449;
            ::apache::thrift::protocol::TType _etype452;
            xfer += iprot->readListBegin(_etype452, _size449);
            this->v.resize(_size449);
            uint32_t _i453;
            for (_i453 = 0; _i453 < _size449; ++_i453)
            {
              xfer += this->v[_i453].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCellSerial");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter454;
    for (_iter454 = this->k.begin(); _iter454 != this->k.end(); ++_iter454)
    {
      xfer += oprot->writeBinary((*_iter454));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter455;
    for (_iter455 = this->v.begin(); _iter455 != this->v.end(); ++_iter455)
    {
      xfer += (*_iter455).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCellSerial &a, CCellSerial &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CCellSerial::CCellSerial(const CCellSerial& other456) {
  k = other456.k;
  ts = other456.ts;
  v = other456.v;
  __isset = other456.__isset;
}
CCellSerial::CCellSerial(CCellSerial&& other457) noexcept {
  k = std::move(other457.k);
  ts = other457.ts;
  v = std::move(other457.v);
  __isset = other457.__isset;
}
CCellSerial& CCellSerial::operator=(const CCellSerial& other458) {
  k = other458.k;
  ts = other458.ts;
  v = other458.v;
  __isset = other458.__isset;
  return *this;
}
CCellSerial& CCellSerial::operator=(CCellSerial&& other459) noexcept {
  k = std::move(other459.k);
  ts = other459.ts;
  v = std::move(other459.v);
  __isset = other459.__isset;
  return *this;
}
void CCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCellSerial(";
  out << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


ColCells::~ColCells() noexcept {
}


void ColCells::__set_cells(const std::vector<CCell> & val) {
  this->cells = val;
}

void ColCells::__set_serial_cells(const std::vector<CCellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const ColCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size460;
            ::apache::thrift::protocol::TType _etype463;
            xfer += iprot->readListBegin(_etype463, _size460);
            this->cells.resize(_size460);
            uint32_t _i464;
            for (_i464 = 0; _i464 < _size460; ++_i464)
            {
              xfer += this->cells[_i464].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size465;
            ::apache::thrift::protocol::TType _etype468;
            xfer += iprot->readListBegin(_etype468, _size465);
            this->serial_cells.resize(_size465);
            uint32_t _i469;
            for (_i469 = 0; _i469 < _size465; ++_i469)
            {
              xfer += this->serial_cells[_i469].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColCells");

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<CCell> ::const_iterator _iter470;
    for (_iter470 = this->cells.begin(); _iter470 != this->cells.end(); ++_iter470)
    {
      xfer += (*_iter470).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<CCellSerial> ::const_iterator _iter471;
    for (_iter471 = this->serial_cells.begin(); _iter471 != this->serial_cells.end(); ++_iter471)
    {
      xfer += (*_iter471).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColCells &a, ColCells &b) {
  using ::std::swap;
  swap(a.cells, b.cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

ColCells::ColCells(const ColCells& other472) {
  cells = other472.cells;
  serial_cells = other472.serial_cells;
  __isset = other472.__isset;
}
ColCells::ColCells(ColCells&& other473) noexcept {
  cells = std::move(other473.cells);
  serial_cells = std::move(other473.serial_cells);
  __isset = other473.__isset;
}
ColCells& ColCells::operator=(const ColCells& other474) {
  cells = other474.cells;
  serial_cells = other474.serial_cells;
  __isset = other474.__isset;
  return *this;
}
ColCells& ColCells::operator=(ColCells&& other475) noexcept {
  cells = std::move(other475.cells);
  serial_cells = std::move(other475.serial_cells);
  __isset = other475.__isset;
  return *this;
}
void ColCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColCells(";
  out << "cells=" << to_string(cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


KCell::~KCell() noexcept {
}


void KCell::__set_c(const std::string& val) {
  this->c = val;
}

void KCell::__set_ts(const int64_t val) {
  this->ts = val;
}

void KCell::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const KCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KCell");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KCell &a, KCell &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

KCell::KCell(const KCell& other476) {
  c = other476.c;
  ts = other476.ts;
  v = other476.v;
  __isset = other476.__isset;
}
KCell::KCell(KCell&& other477) noexcept {
  c = std::move(other477.c);
  ts = other477.ts;
  v = std::move(other477.v);
  __isset = other477.__isset;
}
KCell& KCell::operator=(const KCell& other478) {
  c = other478.c;
  ts = other478.ts;
  v = other478.v;
  __isset = other478.__isset;
  return *this;
}
KCell& KCell::operator=(KCell&& other479) noexcept {
  c = std::move(other479.c);
  ts = other479.ts;
  v = std::move(other479.v);
  __isset = other479.__isset;
  return *this;
}
void KCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KCell(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


KCellSerial::~KCellSerial() noexcept {
}


void KCellSerial::__set_c(const std::string& val) {
  this->c = val;
}

void KCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void KCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const KCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size480;
            ::apache::thrift::protocol::TType _etype483;
            xfer += iprot->readListBegin(_etype483, _size480);
            this->v.resize(_size480);
            uint32_t _i484;
            for (_i484 = 0; _i484 < _size480; ++_i484)
            {
              xfer += this->v[_i484].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KCellSerial");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter485;
    for (_iter485 = this->v.begin(); _iter485 != this->v.end(); ++_iter485)
    {
      xfer += (*_iter485).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KCellSerial &a, KCellSerial &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

KCellSerial::KCellSerial(const KCellSerial& other486) {
  c = other486.c;
  ts = other486.ts;
  v = other486.v;
  __isset = other486.__isset;
}
KCellSerial::KCellSerial(KCellSerial&& other487) noexcept {
  c = std::move(other487.c);
  ts = other487.ts;
  v = std::move(other487.v);
  __isset = other487.__isset;
}
KCellSerial& KCellSerial::operator=(const KCellSerial& other488) {
  c = other488.c;
  ts = other488.ts;
  v = other488.v;
  __isset = other488.__isset;
  return *this;
}
KCellSerial& KCellSerial::operator=(KCellSerial&& other489) noexcept {
  c = std::move(other489.c);
  ts = other489.ts;
  v = std::move(other489.v);
  __isset = other489.__isset;
  return *this;
}
void KCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KCellSerial(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


kCells::~kCells() noexcept {
}


void kCells::__set_k(const Key& val) {
  this->k = val;
}

void kCells::__set_cells(const std::vector<KCell> & val) {
  this->cells = val;
}

void kCells::__set_serial_cells(const std::vector<KCellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const kCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t kCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size490;
            ::apache::thrift::protocol::TType _etype493;
            xfer += iprot->readListBegin(_etype493, _size490);
            this->k.resize(_size490);
            uint32_t _i494;
            for (_i494 = 0; _i494 < _size490; ++_i494)
            {
              xfer += iprot->readBinary(this->k[_i494]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size495;
            ::apache::thrift::protocol::TType _etype498;
            xfer += iprot->readListBegin(_etype498, _size495);
            this->cells.resize(_size495);
            uint32_t _i499;
            for (_i499 = 0; _i499 < _size495; ++_i499)
            {
              xfer += this->cells[_i499].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size500;
            ::apache::thrift::protocol::TType _etype503;
            xfer += iprot->readListBegin(_etype503, _size500);
            this->serial_cells.resize(_size500);
            uint32_t _i504;
            for (_i504 = 0; _i504 < _size500; ++_i504)
            {
              xfer += this->serial_cells[_i504].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kCells");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter505;
    for (_iter505 = this->k.begin(); _iter505 != this->k.end(); ++_iter505)
    {
      xfer += oprot->writeBinary((*_iter505));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<KCell> ::const_iterator _iter506;
    for (_iter506 = this->cells.begin(); _iter506 != this->cells.end(); ++_iter506)
    {
      xfer += (*_iter506).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<KCellSerial> ::const_iterator _iter507;
    for (_iter507 = this->serial_cells.begin(); _iter507 != this->serial_cells.end(); ++_iter507)
    {
      xfer += (*_iter507).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(kCells &a, kCells &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.cells, b.cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

kCells::kCells(const kCells& other508) {
  k = other508.k;
  cells = other508.cells;
  serial_cells = other508.serial_cells;
  __isset = other508.__isset;
}
kCells::kCells(kCells&& other509) noexcept {
  k = std::move(other509.k);
  cells = std::move(other509.cells);
  serial_cells = std::move(other509.serial_cells);
  __isset = other509.__isset;
}
kCells& kCells::operator=(const kCells& other510) {
  k = other510.k;
  cells = other510.cells;
  serial_cells = other510.serial_cells;
  __isset = other510.__isset;
  return *this;
}
kCells& kCells::operator=(kCells&& other511) noexcept {
  k = std::move(other511.k);
  cells = std::move(other511.cells);
  serial_cells = std::move(other511.serial_cells);
  __isset = other511.__isset;
  return *this;
}
void kCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "kCells(";
  out << "k=" << to_string(k);
  out << ", " << "cells=" << to_string(cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


FCell::~FCell() noexcept {
}


void FCell::__set_c(const std::string& val) {
  this->c = val;
}

void FCell::__set_ts(const int64_t val) {
  this->ts = val;
}

void FCell::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCell");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCell &a, FCell &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FCell::FCell(const FCell& other512) {
  c = other512.c;
  ts = other512.ts;
  v = other512.v;
  __isset = other512.__isset;
}
FCell::FCell(FCell&& other513) noexcept {
  c = std::move(other513.c);
  ts = other513.ts;
  v = std::move(other513.v);
  __isset = other513.__isset;
}
FCell& FCell::operator=(const FCell& other514) {
  c = other514.c;
  ts = other514.ts;
  v = other514.v;
  __isset = other514.__isset;
  return *this;
}
FCell& FCell::operator=(FCell&& other515) noexcept {
  c = std::move(other515.c);
  ts = other515.ts;
  v = std::move(other515.v);
  __isset = other515.__isset;
  return *this;
}
void FCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCell(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FCellSerial::~FCellSerial() noexcept {
}


void FCellSerial::__set_c(const std::string& val) {
  this->c = val;
}

void FCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void FCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size516;
            ::apache::thrift::protocol::TType _etype519;
            xfer += iprot->readListBegin(_etype519, _size516);
            this->v.resize(_size516);
            uint32_t _i520;
            for (_i520 = 0; _i520 < _size516; ++_i520)
            {
              xfer += this->v[_i520].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCellSerial");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter521;
    for (_iter521 = this->v.begin(); _iter521 != this->v.end(); ++_iter521)
    {
      xfer += (*_iter521).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCellSerial &a, FCellSerial &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FCellSerial::FCellSerial(const FCellSerial& other522) {
  c = other522.c;
  ts = other522.ts;
  v = other522.v;
  __isset = other522.__isset;
}
FCellSerial::FCellSerial(FCellSerial&& other523) noexcept {
  c = std::move(other523.c);
  ts = other523.ts;
  v = std::move(other523.v);
  __isset = other523.__isset;
}
FCellSerial& FCellSerial::operator=(const FCellSerial& other524) {
  c = other524.c;
  ts = other524.ts;
  v = other524.v;
  __isset = other524.__isset;
  return *this;
}
FCellSerial& FCellSerial::operator=(FCellSerial&& other525) noexcept {
  c = std::move(other525.c);
  ts = other525.ts;
  v = std::move(other525.v);
  __isset = other525.__isset;
  return *this;
}
void FCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCellSerial(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FCells::~FCells() noexcept {
}


void FCells::__set_f(const std::map<std::string, FCells> & val) {
  this->f = val;
}

void FCells::__set_cells(const std::vector<FCell> & val) {
  this->cells = val;
}

void FCells::__set_serial_cells(const std::vector<FCellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const FCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->f.clear();
            uint32_t _size526;
            ::apache::thrift::protocol::TType _ktype527;
            ::apache::thrift::protocol::TType _vtype528;
            xfer += iprot->readMapBegin(_ktype527, _vtype528, _size526);
            uint32_t _i530;
            for (_i530 = 0; _i530 < _size526; ++_i530)
            {
              std::string _key531;
              xfer += iprot->readBinary(_key531);
              FCells& _val532 = this->f[_key531];
              xfer += _val532.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size533;
            ::apache::thrift::protocol::TType _etype536;
            xfer += iprot->readListBegin(_etype536, _size533);
            this->cells.resize(_size533);
            uint32_t _i537;
            for (_i537 = 0; _i537 < _size533; ++_i537)
            {
              xfer += this->cells[_i537].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size538;
            ::apache::thrift::protocol::TType _etype541;
            xfer += iprot->readListBegin(_etype541, _size538);
            this->serial_cells.resize(_size538);
            uint32_t _i542;
            for (_i542 = 0; _i542 < _size538; ++_i542)
            {
              xfer += this->serial_cells[_i542].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCells");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->f.size()));
    std::map<std::string, FCells> ::const_iterator _iter543;
    for (_iter543 = this->f.begin(); _iter543 != this->f.end(); ++_iter543)
    {
      xfer += oprot->writeBinary(_iter543->first);
      xfer += _iter543->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<FCell> ::const_iterator _iter544;
    for (_iter544 = this->cells.begin(); _iter544 != this->cells.end(); ++_iter544)
    {
      xfer += (*_iter544).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<FCellSerial> ::const_iterator _iter545;
    for (_iter545 = this->serial_cells.begin(); _iter545 != this->serial_cells.end(); ++_iter545)
    {
      xfer += (*_iter545).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCells &a, FCells &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.cells, b.cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

FCells::FCells(const FCells& other546) {
  f = other546.f;
  cells = other546.cells;
  serial_cells = other546.serial_cells;
  __isset = other546.__isset;
}
FCells::FCells(FCells&& other547) noexcept {
  f = std::move(other547.f);
  cells = std::move(other547.cells);
  serial_cells = std::move(other547.serial_cells);
  __isset = other547.__isset;
}
FCells& FCells::operator=(const FCells& other548) {
  f = other548.f;
  cells = other548.cells;
  serial_cells = other548.serial_cells;
  __isset = other548.__isset;
  return *this;
}
FCells& FCells::operator=(FCells&& other549) noexcept {
  f = std::move(other549.f);
  cells = std::move(other549.cells);
  serial_cells = std::move(other549.serial_cells);
  __isset = other549.__isset;
  return *this;
}
void FCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCells(";
  out << "f=" << to_string(f);
  out << ", " << "cells=" << to_string(cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


CellsGroup::~CellsGroup() noexcept {
}


void CellsGroup::__set_cells(const Cells& val) {
  this->cells = val;
}

void CellsGroup::__set_ccells(const CCells& val) {
  this->ccells = val;
}

void CellsGroup::__set_kcells(const KCells& val) {
  this->kcells = val;
}

void CellsGroup::__set_fcells(const FCells& val) {
  this->fcells = val;
}
std::ostream& operator<<(std::ostream& out, const CellsGroup& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellsGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cells.read(iprot);
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ccells.clear();
            uint32_t _size550;
            ::apache::thrift::protocol::TType _ktype551;
            ::apache::thrift::protocol::TType _vtype552;
            xfer += iprot->readMapBegin(_ktype551, _vtype552, _size550);
            uint32_t _i554;
            for (_i554 = 0; _i554 < _size550; ++_i554)
            {
              std::string _key555;
              xfer += iprot->readString(_key555);
              ColCells& _val556 = this->ccells[_key555];
              xfer += _val556.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ccells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->kcells.clear();
            uint32_t _size557;
            ::apache::thrift::protocol::TType _etype560;
            xfer += iprot->readListBegin(_etype560, _size557);
            this->kcells.resize(_size557);
            uint32_t _i561;
            for (_i561 = 0; _i561 < _size557; ++_i561)
            {
              xfer += this->kcells[_i561].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.kcells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fcells.read(iprot);
          this->__isset.fcells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellsGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellsGroup");

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cells.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ccells", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ccells.size()));
    std::map<std::string, ColCells> ::const_iterator _iter562;
    for (_iter562 = this->ccells.begin(); _iter562 != this->ccells.end(); ++_iter562)
    {
      xfer += oprot->writeString(_iter562->first);
      xfer += _iter562->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("kcells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->kcells.size()));
    std::vector<kCells> ::const_iterator _iter563;
    for (_iter563 = this->kcells.begin(); _iter563 != this->kcells.end(); ++_iter563)
    {
      xfer += (*_iter563).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fcells", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->fcells.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellsGroup &a, CellsGroup &b) {
  using ::std::swap;
  swap(a.cells, b.cells);
  swap(a.ccells, b.ccells);
  swap(a.kcells, b.kcells);
  swap(a.fcells, b.fcells);
  swap(a.__isset, b.__isset);
}

CellsGroup::CellsGroup(const CellsGroup& other564) {
  cells = other564.cells;
  ccells = other564.ccells;
  kcells = other564.kcells;
  fcells = other564.fcells;
  __isset = other564.__isset;
}
CellsGroup::CellsGroup(CellsGroup&& other565) noexcept {
  cells = std::move(other565.cells);
  ccells = std::move(other565.ccells);
  kcells = std::move(other565.kcells);
  fcells = std::move(other565.fcells);
  __isset = other565.__isset;
}
CellsGroup& CellsGroup::operator=(const CellsGroup& other566) {
  cells = other566.cells;
  ccells = other566.ccells;
  kcells = other566.kcells;
  fcells = other566.fcells;
  __isset = other566.__isset;
  return *this;
}
CellsGroup& CellsGroup::operator=(CellsGroup&& other567) noexcept {
  cells = std::move(other567.cells);
  ccells = std::move(other567.ccells);
  kcells = std::move(other567.kcells);
  fcells = std::move(other567.fcells);
  __isset = other567.__isset;
  return *this;
}
void CellsGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellsGroup(";
  out << "cells=" << to_string(cells);
  out << ", " << "ccells=" << to_string(ccells);
  out << ", " << "kcells=" << to_string(kcells);
  out << ", " << "fcells=" << to_string(fcells);
  out << ")";
}


CompactResult::~CompactResult() noexcept {
}


void CompactResult::__set_cid(const int64_t val) {
  this->cid = val;
}

void CompactResult::__set_err(const int32_t val) {
  this->err = val;
}
std::ostream& operator<<(std::ostream& out, const CompactResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->err);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CompactResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactResult");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->err);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactResult &a, CompactResult &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

CompactResult::CompactResult(const CompactResult& other568) noexcept {
  cid = other568.cid;
  err = other568.err;
  __isset = other568.__isset;
}
CompactResult::CompactResult(CompactResult&& other569) noexcept {
  cid = other569.cid;
  err = other569.err;
  __isset = other569.__isset;
}
CompactResult& CompactResult::operator=(const CompactResult& other570) noexcept {
  cid = other570.cid;
  err = other570.err;
  __isset = other570.__isset;
  return *this;
}
CompactResult& CompactResult::operator=(CompactResult&& other571) noexcept {
  cid = other571.cid;
  err = other571.err;
  __isset = other571.__isset;
  return *this;
}
void CompactResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactResult(";
  out << "cid=" << to_string(cid);
  out << ", " << "err=" << to_string(err);
  out << ")";
}


Result::~Result() noexcept {
}


void Result::__set_schemas(const Schemas& val) {
  this->schemas = val;
}

void Result::__set_cells(const Cells& val) {
  this->cells = val;
}

void Result::__set_compact(const CompactResults& val) {
  this->compact = val;
}
std::ostream& operator<<(std::ostream& out, const Result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->schemas.clear();
            uint32_t _size572;
            ::apache::thrift::protocol::TType _etype575;
            xfer += iprot->readListBegin(_etype575, _size572);
            this->schemas.resize(_size572);
            uint32_t _i576;
            for (_i576 = 0; _i576 < _size572; ++_i576)
            {
              xfer += this->schemas[_i576].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.schemas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cells.read(iprot);
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compact.clear();
            uint32_t _size577;
            ::apache::thrift::protocol::TType _etype580;
            xfer += iprot->readListBegin(_etype580, _size577);
            this->compact.resize(_size577);
            uint32_t _i581;
            for (_i581 = 0; _i581 < _size577; ++_i581)
            {
              xfer += this->compact[_i581].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.compact = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Result");

  xfer += oprot->writeFieldBegin("schemas", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->schemas.size()));
    std::vector<Schema> ::const_iterator _iter582;
    for (_iter582 = this->schemas.begin(); _iter582 != this->schemas.end(); ++_iter582)
    {
      xfer += (*_iter582).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->cells.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compact", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->compact.size()));
    std::vector<CompactResult> ::const_iterator _iter583;
    for (_iter583 = this->compact.begin(); _iter583 != this->compact.end(); ++_iter583)
    {
      xfer += (*_iter583).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Result &a, Result &b) {
  using ::std::swap;
  swap(a.schemas, b.schemas);
  swap(a.cells, b.cells);
  swap(a.compact, b.compact);
  swap(a.__isset, b.__isset);
}

Result::Result(const Result& other584) {
  schemas = other584.schemas;
  cells = other584.cells;
  compact = other584.compact;
  __isset = other584.__isset;
}
Result::Result(Result&& other585) noexcept {
  schemas = std::move(other585.schemas);
  cells = std::move(other585.cells);
  compact = std::move(other585.compact);
  __isset = other585.__isset;
}
Result& Result::operator=(const Result& other586) {
  schemas = other586.schemas;
  cells = other586.cells;
  compact = other586.compact;
  __isset = other586.__isset;
  return *this;
}
Result& Result::operator=(Result&& other587) noexcept {
  schemas = std::move(other587.schemas);
  cells = std::move(other587.cells);
  compact = std::move(other587.compact);
  __isset = other587.__isset;
  return *this;
}
void Result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Result(";
  out << "schemas=" << to_string(schemas);
  out << ", " << "cells=" << to_string(cells);
  out << ", " << "compact=" << to_string(compact);
  out << ")";
}

}} // namespace
