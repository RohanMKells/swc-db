/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Service_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace SWC { namespace Thrift {

int _kKeySeqValues[] = {
  /**
   * Unknown/Unrecognized Type
   */
  KeySeq::UNKNOWN,
  /**
   * The Lexical Key Order Sequence
   */
  KeySeq::LEXIC,
  /**
   * The Volumetric Key Order Sequence
   */
  KeySeq::VOLUME,
  /**
   * The by Fractions Count on Lexical Key Order Sequence
   */
  KeySeq::FC_LEXIC,
  /**
   * The by Fractions Count on Volumetric Key Order Sequence
   */
  KeySeq::FC_VOLUME
};
const char* _kKeySeqNames[] = {
  /**
   * Unknown/Unrecognized Type
   */
  "UNKNOWN",
  /**
   * The Lexical Key Order Sequence
   */
  "LEXIC",
  /**
   * The Volumetric Key Order Sequence
   */
  "VOLUME",
  /**
   * The by Fractions Count on Lexical Key Order Sequence
   */
  "FC_LEXIC",
  /**
   * The by Fractions Count on Volumetric Key Order Sequence
   */
  "FC_VOLUME"
};
const std::map<int, const char*> _KeySeq_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kKeySeqValues, _kKeySeqNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const KeySeq::type& val) {
  std::map<int, const char*>::const_iterator it = _KeySeq_VALUES_TO_NAMES.find(val);
  if (it != _KeySeq_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const KeySeq::type& val) {
  std::map<int, const char*>::const_iterator it = _KeySeq_VALUES_TO_NAMES.find(val);
  if (it != _KeySeq_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kColumnTypeValues[] = {
  /**
   * Unknown/Unrecognized Type
   */
  ColumnType::UNKNOWN,
  /**
   * A Plain Column Value
   */
  ColumnType::PLAIN,
  /**
   * A Counter Column Value with integrity of signed-64bit
   */
  ColumnType::COUNTER_I64,
  /**
   * A Counter Column Value with integrity of signed-32bit
   */
  ColumnType::COUNTER_I32,
  /**
   * A Counter Column Value with integrity of signed-16bit
   */
  ColumnType::COUNTER_I16,
  /**
   * A Counter Column Value with integrity of signed-8bit
   */
  ColumnType::COUNTER_I8,
  /**
   * A Serial Column Value
   */
  ColumnType::SERIAL,
  /**
   * Not used - experimental
   */
  ColumnType::CELL_DEFINED
};
const char* _kColumnTypeNames[] = {
  /**
   * Unknown/Unrecognized Type
   */
  "UNKNOWN",
  /**
   * A Plain Column Value
   */
  "PLAIN",
  /**
   * A Counter Column Value with integrity of signed-64bit
   */
  "COUNTER_I64",
  /**
   * A Counter Column Value with integrity of signed-32bit
   */
  "COUNTER_I32",
  /**
   * A Counter Column Value with integrity of signed-16bit
   */
  "COUNTER_I16",
  /**
   * A Counter Column Value with integrity of signed-8bit
   */
  "COUNTER_I8",
  /**
   * A Serial Column Value
   */
  "SERIAL",
  /**
   * Not used - experimental
   */
  "CELL_DEFINED"
};
const std::map<int, const char*> _ColumnType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kColumnTypeValues, _kColumnTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ColumnType::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnType_VALUES_TO_NAMES.find(val);
  if (it != _ColumnType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ColumnType::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnType_VALUES_TO_NAMES.find(val);
  if (it != _ColumnType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kEncodingTypeValues[] = {
  /**
   * Encoding by Ranger DEFAULT configurations
   */
  EncodingType::DEFAULT,
  /**
   * No Encoding
   */
  EncodingType::PLAIN,
  /**
   * Encode with zlib
   */
  EncodingType::ZLIB,
  /**
   * Encode with snappy
   */
  EncodingType::SNAPPY,
  /**
   * Encode with zstandard
   */
  EncodingType::ZSTD,
  /**
   * Unrecognized Type
   */
  EncodingType::UNKNOWN
};
const char* _kEncodingTypeNames[] = {
  /**
   * Encoding by Ranger DEFAULT configurations
   */
  "DEFAULT",
  /**
   * No Encoding
   */
  "PLAIN",
  /**
   * Encode with zlib
   */
  "ZLIB",
  /**
   * Encode with snappy
   */
  "SNAPPY",
  /**
   * Encode with zstandard
   */
  "ZSTD",
  /**
   * Unrecognized Type
   */
  "UNKNOWN"
};
const std::map<int, const char*> _EncodingType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kEncodingTypeValues, _kEncodingTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const EncodingType::type& val) {
  std::map<int, const char*>::const_iterator it = _EncodingType_VALUES_TO_NAMES.find(val);
  if (it != _EncodingType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const EncodingType::type& val) {
  std::map<int, const char*>::const_iterator it = _EncodingType_VALUES_TO_NAMES.find(val);
  if (it != _EncodingType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSchemaFuncValues[] = {
  /**
   * Create Column Function
   */
  SchemaFunc::CREATE,
  /**
   * Delete Column Function
   */
  SchemaFunc::REMOVE,
  /**
   * Modify Column Function
   */
  SchemaFunc::MODIFY
};
const char* _kSchemaFuncNames[] = {
  /**
   * Create Column Function
   */
  "CREATE",
  /**
   * Delete Column Function
   */
  "REMOVE",
  /**
   * Modify Column Function
   */
  "MODIFY"
};
const std::map<int, const char*> _SchemaFunc_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kSchemaFuncValues, _kSchemaFuncNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SchemaFunc::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaFunc_VALUES_TO_NAMES.find(val);
  if (it != _SchemaFunc_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SchemaFunc::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaFunc_VALUES_TO_NAMES.find(val);
  if (it != _SchemaFunc_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCompValues[] = {
  /**
   * [         ]  :   none               (no comparison applied)
   */
  Comp::NONE,
  /**
   * [  =^     ]  :   -pf [prefix]       (starts-with)
   */
  Comp::PF,
  /**
   * [ &gt;    ]  :   -gt                (greater-than)
   */
  Comp::GT,
  /**
   * [ &gt;=   ]  :   -ge                (greater-equal)
   */
  Comp::GE,
  /**
   * [  =      ]  :   -eq                (equal)
   */
  Comp::EQ,
  /**
   * [ &lt;=   ]  :   -le                (lower-equal)
   */
  Comp::LE,
  /**
   * [ &lt;    ]  :   -lt                (lower-than)
   */
  Comp::LT,
  /**
   * [  !=     ]  :   -ne                (not-equal)
   */
  Comp::NE,
  /**
   * [  re     ]  :   -re [r,regexp]     (regular-expression)
   */
  Comp::RE,
  /**
   * [ v&gt;   ]  :   -vgt               (vol greater-than)
   */
  Comp::VGT,
  /**
   * [ v&gt;=  ]  :   -vge               (vol greater-equal)
   */
  Comp::VGE,
  /**
   * [ v&lt;=  ]  :   -vle               (vol lower-equal)
   */
  Comp::VLE,
  /**
   * [ v&lt;   ]  :   -vlt               (vol lower-than)
   */
  Comp::VLT,
  /**
   * [ %&gt;   ]  :   -subset [sbs]      (subset)
   */
  Comp::SBS,
  /**
   * [ &lt;%   ]  :   -supset [sps]      (superset)
   */
  Comp::SPS,
  /**
   * [ ~&gt;   ]  :   -posubset [posbs]  (eq/part ordered subset)
   */
  Comp::POSBS,
  /**
   * [ &lt;~   ]  :   -posupset [posps]  (eq/part ordered superset)
   */
  Comp::POSPS,
  /**
   * [ -&gt;   ]  :   -fosubset [fosbs]  (eq/full ordered subset)
   */
  Comp::FOSBS,
  /**
   * [ &lt;-   ]  :   -fosupset [fosps]  (eq/full ordered superset)
   */
  Comp::FOSPS
};
const char* _kCompNames[] = {
  /**
   * [         ]  :   none               (no comparison applied)
   */
  "NONE",
  /**
   * [  =^     ]  :   -pf [prefix]       (starts-with)
   */
  "PF",
  /**
   * [ &gt;    ]  :   -gt                (greater-than)
   */
  "GT",
  /**
   * [ &gt;=   ]  :   -ge                (greater-equal)
   */
  "GE",
  /**
   * [  =      ]  :   -eq                (equal)
   */
  "EQ",
  /**
   * [ &lt;=   ]  :   -le                (lower-equal)
   */
  "LE",
  /**
   * [ &lt;    ]  :   -lt                (lower-than)
   */
  "LT",
  /**
   * [  !=     ]  :   -ne                (not-equal)
   */
  "NE",
  /**
   * [  re     ]  :   -re [r,regexp]     (regular-expression)
   */
  "RE",
  /**
   * [ v&gt;   ]  :   -vgt               (vol greater-than)
   */
  "VGT",
  /**
   * [ v&gt;=  ]  :   -vge               (vol greater-equal)
   */
  "VGE",
  /**
   * [ v&lt;=  ]  :   -vle               (vol lower-equal)
   */
  "VLE",
  /**
   * [ v&lt;   ]  :   -vlt               (vol lower-than)
   */
  "VLT",
  /**
   * [ %&gt;   ]  :   -subset [sbs]      (subset)
   */
  "SBS",
  /**
   * [ &lt;%   ]  :   -supset [sps]      (superset)
   */
  "SPS",
  /**
   * [ ~&gt;   ]  :   -posubset [posbs]  (eq/part ordered subset)
   */
  "POSBS",
  /**
   * [ &lt;~   ]  :   -posupset [posps]  (eq/part ordered superset)
   */
  "POSPS",
  /**
   * [ -&gt;   ]  :   -fosubset [fosbs]  (eq/full ordered subset)
   */
  "FOSBS",
  /**
   * [ &lt;-   ]  :   -fosupset [fosps]  (eq/full ordered superset)
   */
  "FOSPS"
};
const std::map<int, const char*> _Comp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(19, _kCompValues, _kCompNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Comp::type& val) {
  std::map<int, const char*>::const_iterator it = _Comp_VALUES_TO_NAMES.find(val);
  if (it != _Comp_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Comp::type& val) {
  std::map<int, const char*>::const_iterator it = _Comp_VALUES_TO_NAMES.find(val);
  if (it != _Comp_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSpecFlagsOptValues[] = {
  /**
   * No Flag Applied
   */
  SpecFlagsOpt::NONE,
  /**
   * Cells Limit by Keys
   */
  SpecFlagsOpt::LIMIT_BY_KEYS,
  /**
   * Cells Offset by Keys
   */
  SpecFlagsOpt::OFFSET_BY_KEYS,
  /**
   * Select Cells Only Keys without Value data
   */
  SpecFlagsOpt::ONLY_KEYS,
  /**
   * Select Cells Only with DELETE(cell-flag)
   */
  SpecFlagsOpt::ONLY_DELETES
};
const char* _kSpecFlagsOptNames[] = {
  /**
   * No Flag Applied
   */
  "NONE",
  /**
   * Cells Limit by Keys
   */
  "LIMIT_BY_KEYS",
  /**
   * Cells Offset by Keys
   */
  "OFFSET_BY_KEYS",
  /**
   * Select Cells Only Keys without Value data
   */
  "ONLY_KEYS",
  /**
   * Select Cells Only with DELETE(cell-flag)
   */
  "ONLY_DELETES"
};
const std::map<int, const char*> _SpecFlagsOpt_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kSpecFlagsOptValues, _kSpecFlagsOptNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SpecFlagsOpt::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecFlagsOpt_VALUES_TO_NAMES.find(val);
  if (it != _SpecFlagsOpt_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SpecFlagsOpt::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecFlagsOpt_VALUES_TO_NAMES.find(val);
  if (it != _SpecFlagsOpt_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSpecIntervalOptionsValues[] = {
  /**
   * Update Bit Option
   */
  SpecIntervalOptions::UPDATING,
  /**
   * Delete Bit Option
   */
  SpecIntervalOptions::DELETING
};
const char* _kSpecIntervalOptionsNames[] = {
  /**
   * Update Bit Option
   */
  "UPDATING",
  /**
   * Delete Bit Option
   */
  "DELETING"
};
const std::map<int, const char*> _SpecIntervalOptions_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSpecIntervalOptionsValues, _kSpecIntervalOptionsNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SpecIntervalOptions::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecIntervalOptions_VALUES_TO_NAMES.find(val);
  if (it != _SpecIntervalOptions_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SpecIntervalOptions::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecIntervalOptions_VALUES_TO_NAMES.find(val);
  if (it != _SpecIntervalOptions_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kUpdateOPValues[] = {
  /**
   * The operation to Replace
   */
  UpdateOP::REPLACE,
  /**
   * The operation to Append
   */
  UpdateOP::APPEND,
  /**
   * The operation to Prepend
   */
  UpdateOP::PREPEND,
  /**
   * The operation to Insert
   */
  UpdateOP::INSERT,
  /**
   * The operation is by inner Serial fields defintions
   */
  UpdateOP::SERIAL
};
const char* _kUpdateOPNames[] = {
  /**
   * The operation to Replace
   */
  "REPLACE",
  /**
   * The operation to Append
   */
  "APPEND",
  /**
   * The operation to Prepend
   */
  "PREPEND",
  /**
   * The operation to Insert
   */
  "INSERT",
  /**
   * The operation is by inner Serial fields defintions
   */
  "SERIAL"
};
const std::map<int, const char*> _UpdateOP_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kUpdateOPValues, _kUpdateOPNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const UpdateOP::type& val) {
  std::map<int, const char*>::const_iterator it = _UpdateOP_VALUES_TO_NAMES.find(val);
  if (it != _UpdateOP_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const UpdateOP::type& val) {
  std::map<int, const char*>::const_iterator it = _UpdateOP_VALUES_TO_NAMES.find(val);
  if (it != _UpdateOP_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFlagValues[] = {
  /**
   * Unknown/Undefined
   */
  Flag::NONE,
  /**
   * The Cell is an insert
   */
  Flag::INSERT,
  /**
   * The Cell is a delete versions lower-equal
   */
  Flag::DELETE_LE,
  /**
   * The Cell is a  delete version equal
   */
  Flag::DELETE_EQ
};
const char* _kFlagNames[] = {
  /**
   * Unknown/Undefined
   */
  "NONE",
  /**
   * The Cell is an insert
   */
  "INSERT",
  /**
   * The Cell is a delete versions lower-equal
   */
  "DELETE_LE",
  /**
   * The Cell is a  delete version equal
   */
  "DELETE_EQ"
};
const std::map<int, const char*> _Flag_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kFlagValues, _kFlagNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Flag::type& val) {
  std::map<int, const char*>::const_iterator it = _Flag_VALUES_TO_NAMES.find(val);
  if (it != _Flag_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Flag::type& val) {
  std::map<int, const char*>::const_iterator it = _Flag_VALUES_TO_NAMES.find(val);
  if (it != _Flag_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCellsResultValues[] = {
  /**
   * Correspond to result on Cells (Cells in list)
   */
  CellsResult::IN_LIST,
  /**
   * Correspond to result on CCells (Columns Cells)
   */
  CellsResult::ON_COLUMN,
  /**
   * Correspond to result on KCells (Keys Cells)
   */
  CellsResult::ON_KEY,
  /**
   * Correspond to result on FCells (Fraction Cells)
   */
  CellsResult::ON_FRACTION
};
const char* _kCellsResultNames[] = {
  /**
   * Correspond to result on Cells (Cells in list)
   */
  "IN_LIST",
  /**
   * Correspond to result on CCells (Columns Cells)
   */
  "ON_COLUMN",
  /**
   * Correspond to result on KCells (Keys Cells)
   */
  "ON_KEY",
  /**
   * Correspond to result on FCells (Fraction Cells)
   */
  "ON_FRACTION"
};
const std::map<int, const char*> _CellsResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kCellsResultValues, _kCellsResultNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const CellsResult::type& val) {
  std::map<int, const char*>::const_iterator it = _CellsResult_VALUES_TO_NAMES.find(val);
  if (it != _CellsResult_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CellsResult::type& val) {
  std::map<int, const char*>::const_iterator it = _CellsResult_VALUES_TO_NAMES.find(val);
  if (it != _CellsResult_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Exception::~Exception() noexcept {
}


void Exception::__set_code(const int32_t val) {
  this->code = val;
}

void Exception::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const Exception& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Exception::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Exception::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Exception");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Exception &a, Exception &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

Exception::Exception(const Exception& other0) : TException() {
  code = other0.code;
  message = other0.message;
  __isset = other0.__isset;
}
Exception::Exception(Exception&& other1) noexcept : TException() {
  code = other1.code;
  message = std::move(other1.message);
  __isset = other1.__isset;
}
Exception& Exception::operator=(const Exception& other2) {
  code = other2.code;
  message = other2.message;
  __isset = other2.__isset;
  return *this;
}
Exception& Exception::operator=(Exception&& other3) noexcept {
  code = other3.code;
  message = std::move(other3.message);
  __isset = other3.__isset;
  return *this;
}
void Exception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Exception(";
  out << "code=" << to_string(code);
  out << ", " << "message=" << to_string(message);
  out << ")";
}

const char* Exception::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: Exception";
  }
}


Schema::~Schema() noexcept {
}


void Schema::__set_cid(const int64_t val) {
  this->cid = val;
__isset.cid = true;
}

void Schema::__set_col_name(const std::string& val) {
  this->col_name = val;
__isset.col_name = true;
}

void Schema::__set_col_tags(const std::vector<std::string> & val) {
  this->col_tags = val;
}

void Schema::__set_col_seq(const KeySeq::type val) {
  this->col_seq = val;
__isset.col_seq = true;
}

void Schema::__set_col_type(const ColumnType::type val) {
  this->col_type = val;
__isset.col_type = true;
}

void Schema::__set_cell_versions(const int32_t val) {
  this->cell_versions = val;
__isset.cell_versions = true;
}

void Schema::__set_cell_ttl(const int32_t val) {
  this->cell_ttl = val;
__isset.cell_ttl = true;
}

void Schema::__set_blk_encoding(const EncodingType::type val) {
  this->blk_encoding = val;
__isset.blk_encoding = true;
}

void Schema::__set_blk_size(const int32_t val) {
  this->blk_size = val;
__isset.blk_size = true;
}

void Schema::__set_blk_cells(const int32_t val) {
  this->blk_cells = val;
__isset.blk_cells = true;
}

void Schema::__set_cs_replication(const int8_t val) {
  this->cs_replication = val;
__isset.cs_replication = true;
}

void Schema::__set_cs_size(const int32_t val) {
  this->cs_size = val;
__isset.cs_size = true;
}

void Schema::__set_cs_max(const int8_t val) {
  this->cs_max = val;
__isset.cs_max = true;
}

void Schema::__set_log_rollout_ratio(const int8_t val) {
  this->log_rollout_ratio = val;
__isset.log_rollout_ratio = true;
}

void Schema::__set_log_compact_cointervaling(const int8_t val) {
  this->log_compact_cointervaling = val;
__isset.log_compact_cointervaling = true;
}

void Schema::__set_log_fragment_preload(const int8_t val) {
  this->log_fragment_preload = val;
__isset.log_fragment_preload = true;
}

void Schema::__set_compact_percent(const int8_t val) {
  this->compact_percent = val;
__isset.compact_percent = true;
}

void Schema::__set_revision(const int64_t val) {
  this->revision = val;
__isset.revision = true;
}
std::ostream& operator<<(std::ostream& out, const Schema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Schema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col_name);
          this->__isset.col_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->col_tags.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->col_tags.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += iprot->readString(this->col_tags[_i8]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.col_tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->col_seq = static_cast<KeySeq::type>(ecast9);
          this->__isset.col_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->col_type = static_cast<ColumnType::type>(ecast10);
          this->__isset.col_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_versions);
          this->__isset.cell_versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_ttl);
          this->__isset.cell_ttl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast11;
          xfer += iprot->readI32(ecast11);
          this->blk_encoding = static_cast<EncodingType::type>(ecast11);
          this->__isset.blk_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blk_size);
          this->__isset.blk_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blk_cells);
          this->__isset.blk_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->cs_replication);
          this->__isset.cs_replication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cs_size);
          this->__isset.cs_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->cs_max);
          this->__isset.cs_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->log_rollout_ratio);
          this->__isset.log_rollout_ratio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->log_compact_cointervaling);
          this->__isset.log_compact_cointervaling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->log_fragment_preload);
          this->__isset.log_fragment_preload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->compact_percent);
          this->__isset.compact_percent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Schema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Schema");

  if (this->__isset.cid) {
    xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->cid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_name) {
    xfer += oprot->writeFieldBegin("col_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->col_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("col_tags", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->col_tags.size()));
    std::vector<std::string> ::const_iterator _iter12;
    for (_iter12 = this->col_tags.begin(); _iter12 != this->col_tags.end(); ++_iter12)
    {
      xfer += oprot->writeString((*_iter12));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.col_seq) {
    xfer += oprot->writeFieldBegin("col_seq", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->col_seq));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_type) {
    xfer += oprot->writeFieldBegin("col_type", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(static_cast<int32_t>(this->col_type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_versions) {
    xfer += oprot->writeFieldBegin("cell_versions", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->cell_versions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_ttl) {
    xfer += oprot->writeFieldBegin("cell_ttl", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->cell_ttl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_encoding) {
    xfer += oprot->writeFieldBegin("blk_encoding", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(static_cast<int32_t>(this->blk_encoding));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_size) {
    xfer += oprot->writeFieldBegin("blk_size", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->blk_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_cells) {
    xfer += oprot->writeFieldBegin("blk_cells", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->blk_cells);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_replication) {
    xfer += oprot->writeFieldBegin("cs_replication", ::apache::thrift::protocol::T_BYTE, 11);
    xfer += oprot->writeByte(this->cs_replication);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_size) {
    xfer += oprot->writeFieldBegin("cs_size", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->cs_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_max) {
    xfer += oprot->writeFieldBegin("cs_max", ::apache::thrift::protocol::T_BYTE, 13);
    xfer += oprot->writeByte(this->cs_max);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.log_rollout_ratio) {
    xfer += oprot->writeFieldBegin("log_rollout_ratio", ::apache::thrift::protocol::T_BYTE, 14);
    xfer += oprot->writeByte(this->log_rollout_ratio);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.log_compact_cointervaling) {
    xfer += oprot->writeFieldBegin("log_compact_cointervaling", ::apache::thrift::protocol::T_BYTE, 15);
    xfer += oprot->writeByte(this->log_compact_cointervaling);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.log_fragment_preload) {
    xfer += oprot->writeFieldBegin("log_fragment_preload", ::apache::thrift::protocol::T_BYTE, 16);
    xfer += oprot->writeByte(this->log_fragment_preload);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compact_percent) {
    xfer += oprot->writeFieldBegin("compact_percent", ::apache::thrift::protocol::T_BYTE, 17);
    xfer += oprot->writeByte(this->compact_percent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.revision) {
    xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 18);
    xfer += oprot->writeI64(this->revision);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Schema &a, Schema &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.col_name, b.col_name);
  swap(a.col_tags, b.col_tags);
  swap(a.col_seq, b.col_seq);
  swap(a.col_type, b.col_type);
  swap(a.cell_versions, b.cell_versions);
  swap(a.cell_ttl, b.cell_ttl);
  swap(a.blk_encoding, b.blk_encoding);
  swap(a.blk_size, b.blk_size);
  swap(a.blk_cells, b.blk_cells);
  swap(a.cs_replication, b.cs_replication);
  swap(a.cs_size, b.cs_size);
  swap(a.cs_max, b.cs_max);
  swap(a.log_rollout_ratio, b.log_rollout_ratio);
  swap(a.log_compact_cointervaling, b.log_compact_cointervaling);
  swap(a.log_fragment_preload, b.log_fragment_preload);
  swap(a.compact_percent, b.compact_percent);
  swap(a.revision, b.revision);
  swap(a.__isset, b.__isset);
}

Schema::Schema(const Schema& other13) {
  cid = other13.cid;
  col_name = other13.col_name;
  col_tags = other13.col_tags;
  col_seq = other13.col_seq;
  col_type = other13.col_type;
  cell_versions = other13.cell_versions;
  cell_ttl = other13.cell_ttl;
  blk_encoding = other13.blk_encoding;
  blk_size = other13.blk_size;
  blk_cells = other13.blk_cells;
  cs_replication = other13.cs_replication;
  cs_size = other13.cs_size;
  cs_max = other13.cs_max;
  log_rollout_ratio = other13.log_rollout_ratio;
  log_compact_cointervaling = other13.log_compact_cointervaling;
  log_fragment_preload = other13.log_fragment_preload;
  compact_percent = other13.compact_percent;
  revision = other13.revision;
  __isset = other13.__isset;
}
Schema::Schema(Schema&& other14) noexcept {
  cid = other14.cid;
  col_name = std::move(other14.col_name);
  col_tags = std::move(other14.col_tags);
  col_seq = other14.col_seq;
  col_type = other14.col_type;
  cell_versions = other14.cell_versions;
  cell_ttl = other14.cell_ttl;
  blk_encoding = other14.blk_encoding;
  blk_size = other14.blk_size;
  blk_cells = other14.blk_cells;
  cs_replication = other14.cs_replication;
  cs_size = other14.cs_size;
  cs_max = other14.cs_max;
  log_rollout_ratio = other14.log_rollout_ratio;
  log_compact_cointervaling = other14.log_compact_cointervaling;
  log_fragment_preload = other14.log_fragment_preload;
  compact_percent = other14.compact_percent;
  revision = other14.revision;
  __isset = other14.__isset;
}
Schema& Schema::operator=(const Schema& other15) {
  cid = other15.cid;
  col_name = other15.col_name;
  col_tags = other15.col_tags;
  col_seq = other15.col_seq;
  col_type = other15.col_type;
  cell_versions = other15.cell_versions;
  cell_ttl = other15.cell_ttl;
  blk_encoding = other15.blk_encoding;
  blk_size = other15.blk_size;
  blk_cells = other15.blk_cells;
  cs_replication = other15.cs_replication;
  cs_size = other15.cs_size;
  cs_max = other15.cs_max;
  log_rollout_ratio = other15.log_rollout_ratio;
  log_compact_cointervaling = other15.log_compact_cointervaling;
  log_fragment_preload = other15.log_fragment_preload;
  compact_percent = other15.compact_percent;
  revision = other15.revision;
  __isset = other15.__isset;
  return *this;
}
Schema& Schema::operator=(Schema&& other16) noexcept {
  cid = other16.cid;
  col_name = std::move(other16.col_name);
  col_tags = std::move(other16.col_tags);
  col_seq = other16.col_seq;
  col_type = other16.col_type;
  cell_versions = other16.cell_versions;
  cell_ttl = other16.cell_ttl;
  blk_encoding = other16.blk_encoding;
  blk_size = other16.blk_size;
  blk_cells = other16.blk_cells;
  cs_replication = other16.cs_replication;
  cs_size = other16.cs_size;
  cs_max = other16.cs_max;
  log_rollout_ratio = other16.log_rollout_ratio;
  log_compact_cointervaling = other16.log_compact_cointervaling;
  log_fragment_preload = other16.log_fragment_preload;
  compact_percent = other16.compact_percent;
  revision = other16.revision;
  __isset = other16.__isset;
  return *this;
}
void Schema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Schema(";
  out << "cid="; (__isset.cid ? (out << to_string(cid)) : (out << "<null>"));
  out << ", " << "col_name="; (__isset.col_name ? (out << to_string(col_name)) : (out << "<null>"));
  out << ", " << "col_tags=" << to_string(col_tags);
  out << ", " << "col_seq="; (__isset.col_seq ? (out << to_string(col_seq)) : (out << "<null>"));
  out << ", " << "col_type="; (__isset.col_type ? (out << to_string(col_type)) : (out << "<null>"));
  out << ", " << "cell_versions="; (__isset.cell_versions ? (out << to_string(cell_versions)) : (out << "<null>"));
  out << ", " << "cell_ttl="; (__isset.cell_ttl ? (out << to_string(cell_ttl)) : (out << "<null>"));
  out << ", " << "blk_encoding="; (__isset.blk_encoding ? (out << to_string(blk_encoding)) : (out << "<null>"));
  out << ", " << "blk_size="; (__isset.blk_size ? (out << to_string(blk_size)) : (out << "<null>"));
  out << ", " << "blk_cells="; (__isset.blk_cells ? (out << to_string(blk_cells)) : (out << "<null>"));
  out << ", " << "cs_replication="; (__isset.cs_replication ? (out << to_string(cs_replication)) : (out << "<null>"));
  out << ", " << "cs_size="; (__isset.cs_size ? (out << to_string(cs_size)) : (out << "<null>"));
  out << ", " << "cs_max="; (__isset.cs_max ? (out << to_string(cs_max)) : (out << "<null>"));
  out << ", " << "log_rollout_ratio="; (__isset.log_rollout_ratio ? (out << to_string(log_rollout_ratio)) : (out << "<null>"));
  out << ", " << "log_compact_cointervaling="; (__isset.log_compact_cointervaling ? (out << to_string(log_compact_cointervaling)) : (out << "<null>"));
  out << ", " << "log_fragment_preload="; (__isset.log_fragment_preload ? (out << to_string(log_fragment_preload)) : (out << "<null>"));
  out << ", " << "compact_percent="; (__isset.compact_percent ? (out << to_string(compact_percent)) : (out << "<null>"));
  out << ", " << "revision="; (__isset.revision ? (out << to_string(revision)) : (out << "<null>"));
  out << ")";
}


SchemaPattern::~SchemaPattern() noexcept {
}


void SchemaPattern::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SchemaPattern::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const SchemaPattern& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaPattern::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast17;
          xfer += iprot->readI32(ecast17);
          this->comp = static_cast<Comp::type>(ecast17);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaPattern::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaPattern");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaPattern &a, SchemaPattern &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

SchemaPattern::SchemaPattern(const SchemaPattern& other18) {
  comp = other18.comp;
  value = other18.value;
  __isset = other18.__isset;
}
SchemaPattern::SchemaPattern(SchemaPattern&& other19) noexcept {
  comp = other19.comp;
  value = std::move(other19.value);
  __isset = other19.__isset;
}
SchemaPattern& SchemaPattern::operator=(const SchemaPattern& other20) {
  comp = other20.comp;
  value = other20.value;
  __isset = other20.__isset;
  return *this;
}
SchemaPattern& SchemaPattern::operator=(SchemaPattern&& other21) noexcept {
  comp = other21.comp;
  value = std::move(other21.value);
  __isset = other21.__isset;
  return *this;
}
void SchemaPattern::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaPattern(";
  out << "comp=" << to_string(comp);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


SchemaTagsPatterns::~SchemaTagsPatterns() noexcept {
}


void SchemaTagsPatterns::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SchemaTagsPatterns::__set_values(const std::vector<SchemaPattern> & val) {
  this->values = val;
}
std::ostream& operator<<(std::ostream& out, const SchemaTagsPatterns& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaTagsPatterns::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->comp = static_cast<Comp::type>(ecast22);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->values.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += this->values[_i27].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaTagsPatterns::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaTagsPatterns");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector<SchemaPattern> ::const_iterator _iter28;
    for (_iter28 = this->values.begin(); _iter28 != this->values.end(); ++_iter28)
    {
      xfer += (*_iter28).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaTagsPatterns &a, SchemaTagsPatterns &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.values, b.values);
  swap(a.__isset, b.__isset);
}

SchemaTagsPatterns::SchemaTagsPatterns(const SchemaTagsPatterns& other29) {
  comp = other29.comp;
  values = other29.values;
  __isset = other29.__isset;
}
SchemaTagsPatterns::SchemaTagsPatterns(SchemaTagsPatterns&& other30) noexcept {
  comp = other30.comp;
  values = std::move(other30.values);
  __isset = other30.__isset;
}
SchemaTagsPatterns& SchemaTagsPatterns::operator=(const SchemaTagsPatterns& other31) {
  comp = other31.comp;
  values = other31.values;
  __isset = other31.__isset;
  return *this;
}
SchemaTagsPatterns& SchemaTagsPatterns::operator=(SchemaTagsPatterns&& other32) noexcept {
  comp = other32.comp;
  values = std::move(other32.values);
  __isset = other32.__isset;
  return *this;
}
void SchemaTagsPatterns::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaTagsPatterns(";
  out << "comp=" << to_string(comp);
  out << ", " << "values=" << to_string(values);
  out << ")";
}


SchemaPatterns::~SchemaPatterns() noexcept {
}


void SchemaPatterns::__set_names(const std::vector<SchemaPattern> & val) {
  this->names = val;
}

void SchemaPatterns::__set_tags(const SchemaTagsPatterns& val) {
  this->tags = val;
}
std::ostream& operator<<(std::ostream& out, const SchemaPatterns& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaPatterns::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->names.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += this->names[_i37].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tags.read(iprot);
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaPatterns::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaPatterns");

  xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->names.size()));
    std::vector<SchemaPattern> ::const_iterator _iter38;
    for (_iter38 = this->names.begin(); _iter38 != this->names.end(); ++_iter38)
    {
      xfer += (*_iter38).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tags.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaPatterns &a, SchemaPatterns &b) {
  using ::std::swap;
  swap(a.names, b.names);
  swap(a.tags, b.tags);
  swap(a.__isset, b.__isset);
}

SchemaPatterns::SchemaPatterns(const SchemaPatterns& other39) {
  names = other39.names;
  tags = other39.tags;
  __isset = other39.__isset;
}
SchemaPatterns::SchemaPatterns(SchemaPatterns&& other40) noexcept {
  names = std::move(other40.names);
  tags = std::move(other40.tags);
  __isset = other40.__isset;
}
SchemaPatterns& SchemaPatterns::operator=(const SchemaPatterns& other41) {
  names = other41.names;
  tags = other41.tags;
  __isset = other41.__isset;
  return *this;
}
SchemaPatterns& SchemaPatterns::operator=(SchemaPatterns&& other42) noexcept {
  names = std::move(other42.names);
  tags = std::move(other42.tags);
  __isset = other42.__isset;
  return *this;
}
void SchemaPatterns::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaPatterns(";
  out << "names=" << to_string(names);
  out << ", " << "tags=" << to_string(tags);
  out << ")";
}


SpecSchemas::~SpecSchemas() noexcept {
}


void SpecSchemas::__set_cids(const std::vector<int64_t> & val) {
  this->cids = val;
}

void SpecSchemas::__set_names(const std::vector<std::string> & val) {
  this->names = val;
}

void SpecSchemas::__set_patterns(const SchemaPatterns& val) {
  this->patterns = val;
}
std::ostream& operator<<(std::ostream& out, const SpecSchemas& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecSchemas::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cids.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->cids.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += iprot->readI64(this->cids[_i47]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->names.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += iprot->readString(this->names[_i52]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->patterns.read(iprot);
          this->__isset.patterns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecSchemas::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecSchemas");

  xfer += oprot->writeFieldBegin("cids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->cids.size()));
    std::vector<int64_t> ::const_iterator _iter53;
    for (_iter53 = this->cids.begin(); _iter53 != this->cids.end(); ++_iter53)
    {
      xfer += oprot->writeI64((*_iter53));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
    std::vector<std::string> ::const_iterator _iter54;
    for (_iter54 = this->names.begin(); _iter54 != this->names.end(); ++_iter54)
    {
      xfer += oprot->writeString((*_iter54));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("patterns", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->patterns.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecSchemas &a, SpecSchemas &b) {
  using ::std::swap;
  swap(a.cids, b.cids);
  swap(a.names, b.names);
  swap(a.patterns, b.patterns);
  swap(a.__isset, b.__isset);
}

SpecSchemas::SpecSchemas(const SpecSchemas& other55) {
  cids = other55.cids;
  names = other55.names;
  patterns = other55.patterns;
  __isset = other55.__isset;
}
SpecSchemas::SpecSchemas(SpecSchemas&& other56) noexcept {
  cids = std::move(other56.cids);
  names = std::move(other56.names);
  patterns = std::move(other56.patterns);
  __isset = other56.__isset;
}
SpecSchemas& SpecSchemas::operator=(const SpecSchemas& other57) {
  cids = other57.cids;
  names = other57.names;
  patterns = other57.patterns;
  __isset = other57.__isset;
  return *this;
}
SpecSchemas& SpecSchemas::operator=(SpecSchemas&& other58) noexcept {
  cids = std::move(other58.cids);
  names = std::move(other58.names);
  patterns = std::move(other58.patterns);
  __isset = other58.__isset;
  return *this;
}
void SpecSchemas::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecSchemas(";
  out << "cids=" << to_string(cids);
  out << ", " << "names=" << to_string(names);
  out << ", " << "patterns=" << to_string(patterns);
  out << ")";
}


SpecFlags::~SpecFlags() noexcept {
}


void SpecFlags::__set_limit(const int64_t val) {
  this->limit = val;
__isset.limit = true;
}

void SpecFlags::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}

void SpecFlags::__set_max_versions(const int32_t val) {
  this->max_versions = val;
__isset.max_versions = true;
}

void SpecFlags::__set_max_buffer(const int32_t val) {
  this->max_buffer = val;
__isset.max_buffer = true;
}

void SpecFlags::__set_options(const int8_t val) {
  this->options = val;
__isset.options = true;
}
std::ostream& operator<<(std::ostream& out, const SpecFlags& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecFlags::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_versions);
          this->__isset.max_versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_buffer);
          this->__isset.max_buffer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->options);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecFlags::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecFlags");

  if (this->__isset.limit) {
    xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_versions) {
    xfer += oprot->writeFieldBegin("max_versions", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->max_versions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_buffer) {
    xfer += oprot->writeFieldBegin("max_buffer", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->max_buffer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_BYTE, 5);
    xfer += oprot->writeByte(this->options);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecFlags &a, SpecFlags &b) {
  using ::std::swap;
  swap(a.limit, b.limit);
  swap(a.offset, b.offset);
  swap(a.max_versions, b.max_versions);
  swap(a.max_buffer, b.max_buffer);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

SpecFlags::SpecFlags(const SpecFlags& other59) noexcept {
  limit = other59.limit;
  offset = other59.offset;
  max_versions = other59.max_versions;
  max_buffer = other59.max_buffer;
  options = other59.options;
  __isset = other59.__isset;
}
SpecFlags::SpecFlags(SpecFlags&& other60) noexcept {
  limit = other60.limit;
  offset = other60.offset;
  max_versions = other60.max_versions;
  max_buffer = other60.max_buffer;
  options = other60.options;
  __isset = other60.__isset;
}
SpecFlags& SpecFlags::operator=(const SpecFlags& other61) noexcept {
  limit = other61.limit;
  offset = other61.offset;
  max_versions = other61.max_versions;
  max_buffer = other61.max_buffer;
  options = other61.options;
  __isset = other61.__isset;
  return *this;
}
SpecFlags& SpecFlags::operator=(SpecFlags&& other62) noexcept {
  limit = other62.limit;
  offset = other62.offset;
  max_versions = other62.max_versions;
  max_buffer = other62.max_buffer;
  options = other62.options;
  __isset = other62.__isset;
  return *this;
}
void SpecFlags::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecFlags(";
  out << "limit="; (__isset.limit ? (out << to_string(limit)) : (out << "<null>"));
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ", " << "max_versions="; (__isset.max_versions ? (out << to_string(max_versions)) : (out << "<null>"));
  out << ", " << "max_buffer="; (__isset.max_buffer ? (out << to_string(max_buffer)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ")";
}


SpecFraction::~SpecFraction() noexcept {
}


void SpecFraction::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecFraction::__set_f(const std::string& val) {
  this->f = val;
}
std::ostream& operator<<(std::ostream& out, const SpecFraction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecFraction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast63;
          xfer += iprot->readI32(ecast63);
          this->comp = static_cast<Comp::type>(ecast63);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->f);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecFraction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecFraction");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->f);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecFraction &a, SpecFraction &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.f, b.f);
  swap(a.__isset, b.__isset);
}

SpecFraction::SpecFraction(const SpecFraction& other64) {
  comp = other64.comp;
  f = other64.f;
  __isset = other64.__isset;
}
SpecFraction::SpecFraction(SpecFraction&& other65) noexcept {
  comp = other65.comp;
  f = std::move(other65.f);
  __isset = other65.__isset;
}
SpecFraction& SpecFraction::operator=(const SpecFraction& other66) {
  comp = other66.comp;
  f = other66.f;
  __isset = other66.__isset;
  return *this;
}
SpecFraction& SpecFraction::operator=(SpecFraction&& other67) noexcept {
  comp = other67.comp;
  f = std::move(other67.f);
  __isset = other67.__isset;
  return *this;
}
void SpecFraction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecFraction(";
  out << "comp=" << to_string(comp);
  out << ", " << "f=" << to_string(f);
  out << ")";
}


SpecTimestamp::~SpecTimestamp() noexcept {
}


void SpecTimestamp::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecTimestamp::__set_ts(const int64_t val) {
  this->ts = val;
}
std::ostream& operator<<(std::ostream& out, const SpecTimestamp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecTimestamp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast68;
          xfer += iprot->readI32(ecast68);
          this->comp = static_cast<Comp::type>(ecast68);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecTimestamp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecTimestamp");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecTimestamp &a, SpecTimestamp &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.ts, b.ts);
  swap(a.__isset, b.__isset);
}

SpecTimestamp::SpecTimestamp(const SpecTimestamp& other69) noexcept {
  comp = other69.comp;
  ts = other69.ts;
  __isset = other69.__isset;
}
SpecTimestamp::SpecTimestamp(SpecTimestamp&& other70) noexcept {
  comp = other70.comp;
  ts = other70.ts;
  __isset = other70.__isset;
}
SpecTimestamp& SpecTimestamp::operator=(const SpecTimestamp& other71) noexcept {
  comp = other71.comp;
  ts = other71.ts;
  __isset = other71.__isset;
  return *this;
}
SpecTimestamp& SpecTimestamp::operator=(SpecTimestamp&& other72) noexcept {
  comp = other72.comp;
  ts = other72.ts;
  __isset = other72.__isset;
  return *this;
}
void SpecTimestamp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecTimestamp(";
  out << "comp=" << to_string(comp);
  out << ", " << "ts=" << to_string(ts);
  out << ")";
}


SpecKeyInterval::~SpecKeyInterval() noexcept {
}


void SpecKeyInterval::__set_start(const SpecKey& val) {
  this->start = val;
}

void SpecKeyInterval::__set_finish(const SpecKey& val) {
  this->finish = val;
}
std::ostream& operator<<(std::ostream& out, const SpecKeyInterval& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecKeyInterval::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->start.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _etype76;
            xfer += iprot->readListBegin(_etype76, _size73);
            this->start.resize(_size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              xfer += this->start[_i77].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->finish.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _etype81;
            xfer += iprot->readListBegin(_etype81, _size78);
            this->finish.resize(_size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              xfer += this->finish[_i82].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecKeyInterval::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecKeyInterval");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->start.size()));
    std::vector<SpecFraction> ::const_iterator _iter83;
    for (_iter83 = this->start.begin(); _iter83 != this->start.end(); ++_iter83)
    {
      xfer += (*_iter83).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("finish", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->finish.size()));
    std::vector<SpecFraction> ::const_iterator _iter84;
    for (_iter84 = this->finish.begin(); _iter84 != this->finish.end(); ++_iter84)
    {
      xfer += (*_iter84).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecKeyInterval &a, SpecKeyInterval &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.finish, b.finish);
  swap(a.__isset, b.__isset);
}

SpecKeyInterval::SpecKeyInterval(const SpecKeyInterval& other85) {
  start = other85.start;
  finish = other85.finish;
  __isset = other85.__isset;
}
SpecKeyInterval::SpecKeyInterval(SpecKeyInterval&& other86) noexcept {
  start = std::move(other86.start);
  finish = std::move(other86.finish);
  __isset = other86.__isset;
}
SpecKeyInterval& SpecKeyInterval::operator=(const SpecKeyInterval& other87) {
  start = other87.start;
  finish = other87.finish;
  __isset = other87.__isset;
  return *this;
}
SpecKeyInterval& SpecKeyInterval::operator=(SpecKeyInterval&& other88) noexcept {
  start = std::move(other88.start);
  finish = std::move(other88.finish);
  __isset = other88.__isset;
  return *this;
}
void SpecKeyInterval::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecKeyInterval(";
  out << "start=" << to_string(start);
  out << ", " << "finish=" << to_string(finish);
  out << ")";
}


SpecValue::~SpecValue() noexcept {
}


void SpecValue::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValue::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast89;
          xfer += iprot->readI32(ecast89);
          this->comp = static_cast<Comp::type>(ecast89);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValue");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValue &a, SpecValue &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValue::SpecValue(const SpecValue& other90) {
  comp = other90.comp;
  v = other90.v;
  __isset = other90.__isset;
}
SpecValue::SpecValue(SpecValue&& other91) noexcept {
  comp = other91.comp;
  v = std::move(other91.v);
  __isset = other91.__isset;
}
SpecValue& SpecValue::operator=(const SpecValue& other92) {
  comp = other92.comp;
  v = other92.v;
  __isset = other92.__isset;
  return *this;
}
SpecValue& SpecValue::operator=(SpecValue&& other93) noexcept {
  comp = other93.comp;
  v = std::move(other93.v);
  __isset = other93.__isset;
  return *this;
}
void SpecValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValue(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecUpdateOP::~SpecUpdateOP() noexcept {
}


void SpecUpdateOP::__set_op(const UpdateOP::type val) {
  this->op = val;
}

void SpecUpdateOP::__set_pos(const int32_t val) {
  this->pos = val;
__isset.pos = true;
}
std::ostream& operator<<(std::ostream& out, const SpecUpdateOP& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecUpdateOP::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast94;
          xfer += iprot->readI32(ecast94);
          this->op = static_cast<UpdateOP::type>(ecast94);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecUpdateOP::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecUpdateOP");

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->op));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecUpdateOP &a, SpecUpdateOP &b) {
  using ::std::swap;
  swap(a.op, b.op);
  swap(a.pos, b.pos);
  swap(a.__isset, b.__isset);
}

SpecUpdateOP::SpecUpdateOP(const SpecUpdateOP& other95) noexcept {
  op = other95.op;
  pos = other95.pos;
  __isset = other95.__isset;
}
SpecUpdateOP::SpecUpdateOP(SpecUpdateOP&& other96) noexcept {
  op = other96.op;
  pos = other96.pos;
  __isset = other96.__isset;
}
SpecUpdateOP& SpecUpdateOP::operator=(const SpecUpdateOP& other97) noexcept {
  op = other97.op;
  pos = other97.pos;
  __isset = other97.__isset;
  return *this;
}
SpecUpdateOP& SpecUpdateOP::operator=(SpecUpdateOP&& other98) noexcept {
  op = other98.op;
  pos = other98.pos;
  __isset = other98.__isset;
  return *this;
}
void SpecUpdateOP::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecUpdateOP(";
  out << "op=" << to_string(op);
  out << ", " << "pos="; (__isset.pos ? (out << to_string(pos)) : (out << "<null>"));
  out << ")";
}


SpecIntervalUpdate::~SpecIntervalUpdate() noexcept {
}


void SpecIntervalUpdate::__set_v(const std::string& val) {
  this->v = val;
}

void SpecIntervalUpdate::__set_ts(const int64_t val) {
  this->ts = val;
__isset.ts = true;
}

void SpecIntervalUpdate::__set_encoder(const EncodingType::type val) {
  this->encoder = val;
__isset.encoder = true;
}

void SpecIntervalUpdate::__set_update_op(const SpecUpdateOP& val) {
  this->update_op = val;
__isset.update_op = true;
}
std::ostream& operator<<(std::ostream& out, const SpecIntervalUpdate& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecIntervalUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast99;
          xfer += iprot->readI32(ecast99);
          this->encoder = static_cast<EncodingType::type>(ecast99);
          this->__isset.encoder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->update_op.read(iprot);
          this->__isset.update_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecIntervalUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecIntervalUpdate");

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts) {
    xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.encoder) {
    xfer += oprot->writeFieldBegin("encoder", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(static_cast<int32_t>(this->encoder));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.update_op) {
    xfer += oprot->writeFieldBegin("update_op", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->update_op.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecIntervalUpdate &a, SpecIntervalUpdate &b) {
  using ::std::swap;
  swap(a.v, b.v);
  swap(a.ts, b.ts);
  swap(a.encoder, b.encoder);
  swap(a.update_op, b.update_op);
  swap(a.__isset, b.__isset);
}

SpecIntervalUpdate::SpecIntervalUpdate(const SpecIntervalUpdate& other100) {
  v = other100.v;
  ts = other100.ts;
  encoder = other100.encoder;
  update_op = other100.update_op;
  __isset = other100.__isset;
}
SpecIntervalUpdate::SpecIntervalUpdate(SpecIntervalUpdate&& other101) noexcept {
  v = std::move(other101.v);
  ts = other101.ts;
  encoder = other101.encoder;
  update_op = std::move(other101.update_op);
  __isset = other101.__isset;
}
SpecIntervalUpdate& SpecIntervalUpdate::operator=(const SpecIntervalUpdate& other102) {
  v = other102.v;
  ts = other102.ts;
  encoder = other102.encoder;
  update_op = other102.update_op;
  __isset = other102.__isset;
  return *this;
}
SpecIntervalUpdate& SpecIntervalUpdate::operator=(SpecIntervalUpdate&& other103) noexcept {
  v = std::move(other103.v);
  ts = other103.ts;
  encoder = other103.encoder;
  update_op = std::move(other103.update_op);
  __isset = other103.__isset;
  return *this;
}
void SpecIntervalUpdate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecIntervalUpdate(";
  out << "v=" << to_string(v);
  out << ", " << "ts="; (__isset.ts ? (out << to_string(ts)) : (out << "<null>"));
  out << ", " << "encoder="; (__isset.encoder ? (out << to_string(encoder)) : (out << "<null>"));
  out << ", " << "update_op="; (__isset.update_op ? (out << to_string(update_op)) : (out << "<null>"));
  out << ")";
}


SpecIntervalUpdateSerial::~SpecIntervalUpdateSerial() noexcept {
}


void SpecIntervalUpdateSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void SpecIntervalUpdateSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}

void SpecIntervalUpdateSerial::__set_encoder(const EncodingType::type val) {
  this->encoder = val;
__isset.encoder = true;
}

void SpecIntervalUpdateSerial::__set_update_op(const SpecUpdateOP& val) {
  this->update_op = val;
__isset.update_op = true;
}
std::ostream& operator<<(std::ostream& out, const SpecIntervalUpdateSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecIntervalUpdateSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size104;
            ::apache::thrift::protocol::TType _etype107;
            xfer += iprot->readListBegin(_etype107, _size104);
            this->v.resize(_size104);
            uint32_t _i108;
            for (_i108 = 0; _i108 < _size104; ++_i108)
            {
              xfer += this->v[_i108].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast109;
          xfer += iprot->readI32(ecast109);
          this->encoder = static_cast<EncodingType::type>(ecast109);
          this->__isset.encoder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->update_op.read(iprot);
          this->__isset.update_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecIntervalUpdateSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecIntervalUpdateSerial");

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter110;
    for (_iter110 = this->v.begin(); _iter110 != this->v.end(); ++_iter110)
    {
      xfer += (*_iter110).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.encoder) {
    xfer += oprot->writeFieldBegin("encoder", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(static_cast<int32_t>(this->encoder));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.update_op) {
    xfer += oprot->writeFieldBegin("update_op", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->update_op.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecIntervalUpdateSerial &a, SpecIntervalUpdateSerial &b) {
  using ::std::swap;
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.encoder, b.encoder);
  swap(a.update_op, b.update_op);
  swap(a.__isset, b.__isset);
}

SpecIntervalUpdateSerial::SpecIntervalUpdateSerial(const SpecIntervalUpdateSerial& other111) {
  ts = other111.ts;
  v = other111.v;
  encoder = other111.encoder;
  update_op = other111.update_op;
  __isset = other111.__isset;
}
SpecIntervalUpdateSerial::SpecIntervalUpdateSerial(SpecIntervalUpdateSerial&& other112) noexcept {
  ts = other112.ts;
  v = std::move(other112.v);
  encoder = other112.encoder;
  update_op = std::move(other112.update_op);
  __isset = other112.__isset;
}
SpecIntervalUpdateSerial& SpecIntervalUpdateSerial::operator=(const SpecIntervalUpdateSerial& other113) {
  ts = other113.ts;
  v = other113.v;
  encoder = other113.encoder;
  update_op = other113.update_op;
  __isset = other113.__isset;
  return *this;
}
SpecIntervalUpdateSerial& SpecIntervalUpdateSerial::operator=(SpecIntervalUpdateSerial&& other114) noexcept {
  ts = other114.ts;
  v = std::move(other114.v);
  encoder = other114.encoder;
  update_op = std::move(other114.update_op);
  __isset = other114.__isset;
  return *this;
}
void SpecIntervalUpdateSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecIntervalUpdateSerial(";
  out << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ", " << "encoder="; (__isset.encoder ? (out << to_string(encoder)) : (out << "<null>"));
  out << ", " << "update_op="; (__isset.update_op ? (out << to_string(update_op)) : (out << "<null>"));
  out << ")";
}


SpecInterval::~SpecInterval() noexcept {
}


void SpecInterval::__set_range_begin(const Key& val) {
  this->range_begin = val;
}

void SpecInterval::__set_range_end(const Key& val) {
  this->range_end = val;
}

void SpecInterval::__set_offset_key(const Key& val) {
  this->offset_key = val;
}

void SpecInterval::__set_offset_rev(const int64_t val) {
  this->offset_rev = val;
__isset.offset_rev = true;
}

void SpecInterval::__set_key_intervals(const SpecKeyIntervals& val) {
  this->key_intervals = val;
}

void SpecInterval::__set_values(const SpecValues& val) {
  this->values = val;
}

void SpecInterval::__set_ts_start(const SpecTimestamp& val) {
  this->ts_start = val;
__isset.ts_start = true;
}

void SpecInterval::__set_ts_finish(const SpecTimestamp& val) {
  this->ts_finish = val;
__isset.ts_finish = true;
}

void SpecInterval::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}

void SpecInterval::__set_options(const SpecIntervalOptions::type val) {
  this->options = val;
__isset.options = true;
}

void SpecInterval::__set_updating(const SpecIntervalUpdate& val) {
  this->updating = val;
__isset.updating = true;
}
std::ostream& operator<<(std::ostream& out, const SpecInterval& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecInterval::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_begin.clear();
            uint32_t _size115;
            ::apache::thrift::protocol::TType _etype118;
            xfer += iprot->readListBegin(_etype118, _size115);
            this->range_begin.resize(_size115);
            uint32_t _i119;
            for (_i119 = 0; _i119 < _size115; ++_i119)
            {
              xfer += iprot->readBinary(this->range_begin[_i119]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_end.clear();
            uint32_t _size120;
            ::apache::thrift::protocol::TType _etype123;
            xfer += iprot->readListBegin(_etype123, _size120);
            this->range_end.resize(_size120);
            uint32_t _i124;
            for (_i124 = 0; _i124 < _size120; ++_i124)
            {
              xfer += iprot->readBinary(this->range_end[_i124]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->offset_key.clear();
            uint32_t _size125;
            ::apache::thrift::protocol::TType _etype128;
            xfer += iprot->readListBegin(_etype128, _size125);
            this->offset_key.resize(_size125);
            uint32_t _i129;
            for (_i129 = 0; _i129 < _size125; ++_i129)
            {
              xfer += iprot->readBinary(this->offset_key[_i129]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.offset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset_rev);
          this->__isset.offset_rev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_intervals.clear();
            uint32_t _size130;
            ::apache::thrift::protocol::TType _etype133;
            xfer += iprot->readListBegin(_etype133, _size130);
            this->key_intervals.resize(_size130);
            uint32_t _i134;
            for (_i134 = 0; _i134 < _size130; ++_i134)
            {
              xfer += this->key_intervals[_i134].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size135;
            ::apache::thrift::protocol::TType _etype138;
            xfer += iprot->readListBegin(_etype138, _size135);
            this->values.resize(_size135);
            uint32_t _i139;
            for (_i139 = 0; _i139 < _size135; ++_i139)
            {
              xfer += this->values[_i139].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_start.read(iprot);
          this->__isset.ts_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_finish.read(iprot);
          this->__isset.ts_finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast140;
          xfer += iprot->readI32(ecast140);
          this->options = static_cast<SpecIntervalOptions::type>(ecast140);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->updating.read(iprot);
          this->__isset.updating = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecInterval::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecInterval");

  xfer += oprot->writeFieldBegin("range_begin", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_begin.size()));
    std::vector<std::string> ::const_iterator _iter141;
    for (_iter141 = this->range_begin.begin(); _iter141 != this->range_begin.end(); ++_iter141)
    {
      xfer += oprot->writeBinary((*_iter141));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range_end", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_end.size()));
    std::vector<std::string> ::const_iterator _iter142;
    for (_iter142 = this->range_end.begin(); _iter142 != this->range_end.end(); ++_iter142)
    {
      xfer += oprot->writeBinary((*_iter142));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset_key", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->offset_key.size()));
    std::vector<std::string> ::const_iterator _iter143;
    for (_iter143 = this->offset_key.begin(); _iter143 != this->offset_key.end(); ++_iter143)
    {
      xfer += oprot->writeBinary((*_iter143));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offset_rev) {
    xfer += oprot->writeFieldBegin("offset_rev", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->offset_rev);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("key_intervals", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->key_intervals.size()));
    std::vector<SpecKeyInterval> ::const_iterator _iter144;
    for (_iter144 = this->key_intervals.begin(); _iter144 != this->key_intervals.end(); ++_iter144)
    {
      xfer += (*_iter144).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector<SpecValue> ::const_iterator _iter145;
    for (_iter145 = this->values.begin(); _iter145 != this->values.end(); ++_iter145)
    {
      xfer += (*_iter145).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts_start) {
    xfer += oprot->writeFieldBegin("ts_start", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->ts_start.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_finish) {
    xfer += oprot->writeFieldBegin("ts_finish", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->ts_finish.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(static_cast<int32_t>(this->options));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updating) {
    xfer += oprot->writeFieldBegin("updating", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->updating.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecInterval &a, SpecInterval &b) {
  using ::std::swap;
  swap(a.range_begin, b.range_begin);
  swap(a.range_end, b.range_end);
  swap(a.offset_key, b.offset_key);
  swap(a.offset_rev, b.offset_rev);
  swap(a.key_intervals, b.key_intervals);
  swap(a.values, b.values);
  swap(a.ts_start, b.ts_start);
  swap(a.ts_finish, b.ts_finish);
  swap(a.flags, b.flags);
  swap(a.options, b.options);
  swap(a.updating, b.updating);
  swap(a.__isset, b.__isset);
}

SpecInterval::SpecInterval(const SpecInterval& other146) {
  range_begin = other146.range_begin;
  range_end = other146.range_end;
  offset_key = other146.offset_key;
  offset_rev = other146.offset_rev;
  key_intervals = other146.key_intervals;
  values = other146.values;
  ts_start = other146.ts_start;
  ts_finish = other146.ts_finish;
  flags = other146.flags;
  options = other146.options;
  updating = other146.updating;
  __isset = other146.__isset;
}
SpecInterval::SpecInterval(SpecInterval&& other147) noexcept {
  range_begin = std::move(other147.range_begin);
  range_end = std::move(other147.range_end);
  offset_key = std::move(other147.offset_key);
  offset_rev = other147.offset_rev;
  key_intervals = std::move(other147.key_intervals);
  values = std::move(other147.values);
  ts_start = std::move(other147.ts_start);
  ts_finish = std::move(other147.ts_finish);
  flags = std::move(other147.flags);
  options = other147.options;
  updating = std::move(other147.updating);
  __isset = other147.__isset;
}
SpecInterval& SpecInterval::operator=(const SpecInterval& other148) {
  range_begin = other148.range_begin;
  range_end = other148.range_end;
  offset_key = other148.offset_key;
  offset_rev = other148.offset_rev;
  key_intervals = other148.key_intervals;
  values = other148.values;
  ts_start = other148.ts_start;
  ts_finish = other148.ts_finish;
  flags = other148.flags;
  options = other148.options;
  updating = other148.updating;
  __isset = other148.__isset;
  return *this;
}
SpecInterval& SpecInterval::operator=(SpecInterval&& other149) noexcept {
  range_begin = std::move(other149.range_begin);
  range_end = std::move(other149.range_end);
  offset_key = std::move(other149.offset_key);
  offset_rev = other149.offset_rev;
  key_intervals = std::move(other149.key_intervals);
  values = std::move(other149.values);
  ts_start = std::move(other149.ts_start);
  ts_finish = std::move(other149.ts_finish);
  flags = std::move(other149.flags);
  options = other149.options;
  updating = std::move(other149.updating);
  __isset = other149.__isset;
  return *this;
}
void SpecInterval::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecInterval(";
  out << "range_begin=" << to_string(range_begin);
  out << ", " << "range_end=" << to_string(range_end);
  out << ", " << "offset_key=" << to_string(offset_key);
  out << ", " << "offset_rev="; (__isset.offset_rev ? (out << to_string(offset_rev)) : (out << "<null>"));
  out << ", " << "key_intervals=" << to_string(key_intervals);
  out << ", " << "values=" << to_string(values);
  out << ", " << "ts_start="; (__isset.ts_start ? (out << to_string(ts_start)) : (out << "<null>"));
  out << ", " << "ts_finish="; (__isset.ts_finish ? (out << to_string(ts_finish)) : (out << "<null>"));
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ", " << "updating="; (__isset.updating ? (out << to_string(updating)) : (out << "<null>"));
  out << ")";
}


SpecColumn::~SpecColumn() noexcept {
}


void SpecColumn::__set_cid(const int64_t val) {
  this->cid = val;
}

void SpecColumn::__set_intervals(const std::vector<SpecInterval> & val) {
  this->intervals = val;
}
std::ostream& operator<<(std::ostream& out, const SpecColumn& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecColumn::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->intervals.clear();
            uint32_t _size150;
            ::apache::thrift::protocol::TType _etype153;
            xfer += iprot->readListBegin(_etype153, _size150);
            this->intervals.resize(_size150);
            uint32_t _i154;
            for (_i154 = 0; _i154 < _size150; ++_i154)
            {
              xfer += this->intervals[_i154].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecColumn::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecColumn");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intervals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->intervals.size()));
    std::vector<SpecInterval> ::const_iterator _iter155;
    for (_iter155 = this->intervals.begin(); _iter155 != this->intervals.end(); ++_iter155)
    {
      xfer += (*_iter155).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecColumn &a, SpecColumn &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.intervals, b.intervals);
  swap(a.__isset, b.__isset);
}

SpecColumn::SpecColumn(const SpecColumn& other156) {
  cid = other156.cid;
  intervals = other156.intervals;
  __isset = other156.__isset;
}
SpecColumn::SpecColumn(SpecColumn&& other157) noexcept {
  cid = other157.cid;
  intervals = std::move(other157.intervals);
  __isset = other157.__isset;
}
SpecColumn& SpecColumn::operator=(const SpecColumn& other158) {
  cid = other158.cid;
  intervals = other158.intervals;
  __isset = other158.__isset;
  return *this;
}
SpecColumn& SpecColumn::operator=(SpecColumn&& other159) noexcept {
  cid = other159.cid;
  intervals = std::move(other159.intervals);
  __isset = other159.__isset;
  return *this;
}
void SpecColumn::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecColumn(";
  out << "cid=" << to_string(cid);
  out << ", " << "intervals=" << to_string(intervals);
  out << ")";
}


SpecValueSerial_INT64::~SpecValueSerial_INT64() noexcept {
}


void SpecValueSerial_INT64::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_INT64::__set_v(const int64_t val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_INT64& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_INT64::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast160;
          xfer += iprot->readI32(ecast160);
          this->comp = static_cast<Comp::type>(ecast160);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_INT64::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_INT64");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_INT64 &a, SpecValueSerial_INT64 &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_INT64::SpecValueSerial_INT64(const SpecValueSerial_INT64& other161) noexcept {
  comp = other161.comp;
  v = other161.v;
  __isset = other161.__isset;
}
SpecValueSerial_INT64::SpecValueSerial_INT64(SpecValueSerial_INT64&& other162) noexcept {
  comp = other162.comp;
  v = other162.v;
  __isset = other162.__isset;
}
SpecValueSerial_INT64& SpecValueSerial_INT64::operator=(const SpecValueSerial_INT64& other163) noexcept {
  comp = other163.comp;
  v = other163.v;
  __isset = other163.__isset;
  return *this;
}
SpecValueSerial_INT64& SpecValueSerial_INT64::operator=(SpecValueSerial_INT64&& other164) noexcept {
  comp = other164.comp;
  v = other164.v;
  __isset = other164.__isset;
  return *this;
}
void SpecValueSerial_INT64::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_INT64(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_DOUBLE::~SpecValueSerial_DOUBLE() noexcept {
}


void SpecValueSerial_DOUBLE::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_DOUBLE::__set_v(const double val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_DOUBLE& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_DOUBLE::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast165;
          xfer += iprot->readI32(ecast165);
          this->comp = static_cast<Comp::type>(ecast165);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_DOUBLE::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_DOUBLE");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_DOUBLE &a, SpecValueSerial_DOUBLE &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_DOUBLE::SpecValueSerial_DOUBLE(const SpecValueSerial_DOUBLE& other166) noexcept {
  comp = other166.comp;
  v = other166.v;
  __isset = other166.__isset;
}
SpecValueSerial_DOUBLE::SpecValueSerial_DOUBLE(SpecValueSerial_DOUBLE&& other167) noexcept {
  comp = other167.comp;
  v = other167.v;
  __isset = other167.__isset;
}
SpecValueSerial_DOUBLE& SpecValueSerial_DOUBLE::operator=(const SpecValueSerial_DOUBLE& other168) noexcept {
  comp = other168.comp;
  v = other168.v;
  __isset = other168.__isset;
  return *this;
}
SpecValueSerial_DOUBLE& SpecValueSerial_DOUBLE::operator=(SpecValueSerial_DOUBLE&& other169) noexcept {
  comp = other169.comp;
  v = other169.v;
  __isset = other169.__isset;
  return *this;
}
void SpecValueSerial_DOUBLE::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_DOUBLE(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_BYTES::~SpecValueSerial_BYTES() noexcept {
}


void SpecValueSerial_BYTES::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_BYTES::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_BYTES& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_BYTES::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast170;
          xfer += iprot->readI32(ecast170);
          this->comp = static_cast<Comp::type>(ecast170);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_BYTES::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_BYTES");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_BYTES &a, SpecValueSerial_BYTES &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_BYTES::SpecValueSerial_BYTES(const SpecValueSerial_BYTES& other171) {
  comp = other171.comp;
  v = other171.v;
  __isset = other171.__isset;
}
SpecValueSerial_BYTES::SpecValueSerial_BYTES(SpecValueSerial_BYTES&& other172) noexcept {
  comp = other172.comp;
  v = std::move(other172.v);
  __isset = other172.__isset;
}
SpecValueSerial_BYTES& SpecValueSerial_BYTES::operator=(const SpecValueSerial_BYTES& other173) {
  comp = other173.comp;
  v = other173.v;
  __isset = other173.__isset;
  return *this;
}
SpecValueSerial_BYTES& SpecValueSerial_BYTES::operator=(SpecValueSerial_BYTES&& other174) noexcept {
  comp = other174.comp;
  v = std::move(other174.v);
  __isset = other174.__isset;
  return *this;
}
void SpecValueSerial_BYTES::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_BYTES(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_KEY::~SpecValueSerial_KEY() noexcept {
}


void SpecValueSerial_KEY::__set_seq(const KeySeq::type val) {
  this->seq = val;
}

void SpecValueSerial_KEY::__set_v(const SpecKey& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_KEY& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_KEY::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast175;
          xfer += iprot->readI32(ecast175);
          this->seq = static_cast<KeySeq::type>(ecast175);
          this->__isset.seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size176;
            ::apache::thrift::protocol::TType _etype179;
            xfer += iprot->readListBegin(_etype179, _size176);
            this->v.resize(_size176);
            uint32_t _i180;
            for (_i180 = 0; _i180 < _size176; ++_i180)
            {
              xfer += this->v[_i180].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_KEY::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_KEY");

  xfer += oprot->writeFieldBegin("seq", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->seq));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<SpecFraction> ::const_iterator _iter181;
    for (_iter181 = this->v.begin(); _iter181 != this->v.end(); ++_iter181)
    {
      xfer += (*_iter181).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_KEY &a, SpecValueSerial_KEY &b) {
  using ::std::swap;
  swap(a.seq, b.seq);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_KEY::SpecValueSerial_KEY(const SpecValueSerial_KEY& other182) {
  seq = other182.seq;
  v = other182.v;
  __isset = other182.__isset;
}
SpecValueSerial_KEY::SpecValueSerial_KEY(SpecValueSerial_KEY&& other183) noexcept {
  seq = other183.seq;
  v = std::move(other183.v);
  __isset = other183.__isset;
}
SpecValueSerial_KEY& SpecValueSerial_KEY::operator=(const SpecValueSerial_KEY& other184) {
  seq = other184.seq;
  v = other184.v;
  __isset = other184.__isset;
  return *this;
}
SpecValueSerial_KEY& SpecValueSerial_KEY::operator=(SpecValueSerial_KEY&& other185) noexcept {
  seq = other185.seq;
  v = std::move(other185.v);
  __isset = other185.__isset;
  return *this;
}
void SpecValueSerial_KEY::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_KEY(";
  out << "seq=" << to_string(seq);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_LI::~SpecValueSerial_LI() noexcept {
}


void SpecValueSerial_LI::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_LI::__set_v(const std::vector<SpecValueSerial_INT64> & val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_LI& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_LI::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast186;
          xfer += iprot->readI32(ecast186);
          this->comp = static_cast<Comp::type>(ecast186);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size187;
            ::apache::thrift::protocol::TType _etype190;
            xfer += iprot->readListBegin(_etype190, _size187);
            this->v.resize(_size187);
            uint32_t _i191;
            for (_i191 = 0; _i191 < _size187; ++_i191)
            {
              xfer += this->v[_i191].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_LI::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_LI");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<SpecValueSerial_INT64> ::const_iterator _iter192;
    for (_iter192 = this->v.begin(); _iter192 != this->v.end(); ++_iter192)
    {
      xfer += (*_iter192).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_LI &a, SpecValueSerial_LI &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_LI::SpecValueSerial_LI(const SpecValueSerial_LI& other193) {
  comp = other193.comp;
  v = other193.v;
  __isset = other193.__isset;
}
SpecValueSerial_LI::SpecValueSerial_LI(SpecValueSerial_LI&& other194) noexcept {
  comp = other194.comp;
  v = std::move(other194.v);
  __isset = other194.__isset;
}
SpecValueSerial_LI& SpecValueSerial_LI::operator=(const SpecValueSerial_LI& other195) {
  comp = other195.comp;
  v = other195.v;
  __isset = other195.__isset;
  return *this;
}
SpecValueSerial_LI& SpecValueSerial_LI::operator=(SpecValueSerial_LI&& other196) noexcept {
  comp = other196.comp;
  v = std::move(other196.v);
  __isset = other196.__isset;
  return *this;
}
void SpecValueSerial_LI::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_LI(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_LB::~SpecValueSerial_LB() noexcept {
}


void SpecValueSerial_LB::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_LB::__set_v(const std::vector<SpecValueSerial_BYTES> & val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_LB& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_LB::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast197;
          xfer += iprot->readI32(ecast197);
          this->comp = static_cast<Comp::type>(ecast197);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size198;
            ::apache::thrift::protocol::TType _etype201;
            xfer += iprot->readListBegin(_etype201, _size198);
            this->v.resize(_size198);
            uint32_t _i202;
            for (_i202 = 0; _i202 < _size198; ++_i202)
            {
              xfer += this->v[_i202].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_LB::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_LB");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<SpecValueSerial_BYTES> ::const_iterator _iter203;
    for (_iter203 = this->v.begin(); _iter203 != this->v.end(); ++_iter203)
    {
      xfer += (*_iter203).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_LB &a, SpecValueSerial_LB &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_LB::SpecValueSerial_LB(const SpecValueSerial_LB& other204) {
  comp = other204.comp;
  v = other204.v;
  __isset = other204.__isset;
}
SpecValueSerial_LB::SpecValueSerial_LB(SpecValueSerial_LB&& other205) noexcept {
  comp = other205.comp;
  v = std::move(other205.v);
  __isset = other205.__isset;
}
SpecValueSerial_LB& SpecValueSerial_LB::operator=(const SpecValueSerial_LB& other206) {
  comp = other206.comp;
  v = other206.v;
  __isset = other206.__isset;
  return *this;
}
SpecValueSerial_LB& SpecValueSerial_LB::operator=(SpecValueSerial_LB&& other207) noexcept {
  comp = other207.comp;
  v = std::move(other207.v);
  __isset = other207.__isset;
  return *this;
}
void SpecValueSerial_LB::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_LB(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerialField::~SpecValueSerialField() noexcept {
}


void SpecValueSerialField::__set_field_id(const int32_t val) {
  this->field_id = val;
}

void SpecValueSerialField::__set_spec_int64(const SpecValueSerial_INT64& val) {
  this->spec_int64 = val;
__isset.spec_int64 = true;
}

void SpecValueSerialField::__set_spec_double(const SpecValueSerial_DOUBLE& val) {
  this->spec_double = val;
__isset.spec_double = true;
}

void SpecValueSerialField::__set_spec_bytes(const SpecValueSerial_BYTES& val) {
  this->spec_bytes = val;
}

void SpecValueSerialField::__set_spec_key(const SpecValueSerial_KEY& val) {
  this->spec_key = val;
}

void SpecValueSerialField::__set_spec_li(const SpecValueSerial_LI& val) {
  this->spec_li = val;
}

void SpecValueSerialField::__set_spec_lb(const SpecValueSerial_LB& val) {
  this->spec_lb = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerialField& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerialField::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field_id);
          this->__isset.field_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_int64.read(iprot);
          this->__isset.spec_int64 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_double.read(iprot);
          this->__isset.spec_double = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_bytes.read(iprot);
          this->__isset.spec_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_key.read(iprot);
          this->__isset.spec_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_li.read(iprot);
          this->__isset.spec_li = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_lb.read(iprot);
          this->__isset.spec_lb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerialField::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerialField");

  xfer += oprot->writeFieldBegin("field_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.spec_int64) {
    xfer += oprot->writeFieldBegin("spec_int64", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->spec_int64.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.spec_double) {
    xfer += oprot->writeFieldBegin("spec_double", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->spec_double.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("spec_bytes", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->spec_bytes.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spec_key", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->spec_key.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spec_li", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->spec_li.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spec_lb", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->spec_lb.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerialField &a, SpecValueSerialField &b) {
  using ::std::swap;
  swap(a.field_id, b.field_id);
  swap(a.spec_int64, b.spec_int64);
  swap(a.spec_double, b.spec_double);
  swap(a.spec_bytes, b.spec_bytes);
  swap(a.spec_key, b.spec_key);
  swap(a.spec_li, b.spec_li);
  swap(a.spec_lb, b.spec_lb);
  swap(a.__isset, b.__isset);
}

SpecValueSerialField::SpecValueSerialField(const SpecValueSerialField& other208) {
  field_id = other208.field_id;
  spec_int64 = other208.spec_int64;
  spec_double = other208.spec_double;
  spec_bytes = other208.spec_bytes;
  spec_key = other208.spec_key;
  spec_li = other208.spec_li;
  spec_lb = other208.spec_lb;
  __isset = other208.__isset;
}
SpecValueSerialField::SpecValueSerialField(SpecValueSerialField&& other209) noexcept {
  field_id = other209.field_id;
  spec_int64 = std::move(other209.spec_int64);
  spec_double = std::move(other209.spec_double);
  spec_bytes = std::move(other209.spec_bytes);
  spec_key = std::move(other209.spec_key);
  spec_li = std::move(other209.spec_li);
  spec_lb = std::move(other209.spec_lb);
  __isset = other209.__isset;
}
SpecValueSerialField& SpecValueSerialField::operator=(const SpecValueSerialField& other210) {
  field_id = other210.field_id;
  spec_int64 = other210.spec_int64;
  spec_double = other210.spec_double;
  spec_bytes = other210.spec_bytes;
  spec_key = other210.spec_key;
  spec_li = other210.spec_li;
  spec_lb = other210.spec_lb;
  __isset = other210.__isset;
  return *this;
}
SpecValueSerialField& SpecValueSerialField::operator=(SpecValueSerialField&& other211) noexcept {
  field_id = other211.field_id;
  spec_int64 = std::move(other211.spec_int64);
  spec_double = std::move(other211.spec_double);
  spec_bytes = std::move(other211.spec_bytes);
  spec_key = std::move(other211.spec_key);
  spec_li = std::move(other211.spec_li);
  spec_lb = std::move(other211.spec_lb);
  __isset = other211.__isset;
  return *this;
}
void SpecValueSerialField::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerialField(";
  out << "field_id=" << to_string(field_id);
  out << ", " << "spec_int64="; (__isset.spec_int64 ? (out << to_string(spec_int64)) : (out << "<null>"));
  out << ", " << "spec_double="; (__isset.spec_double ? (out << to_string(spec_double)) : (out << "<null>"));
  out << ", " << "spec_bytes=" << to_string(spec_bytes);
  out << ", " << "spec_key=" << to_string(spec_key);
  out << ", " << "spec_li=" << to_string(spec_li);
  out << ", " << "spec_lb=" << to_string(spec_lb);
  out << ")";
}


SpecValueSerial::~SpecValueSerial() noexcept {
}


void SpecValueSerial::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial::__set_fields(const SpecValueSerialFields& val) {
  this->fields = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast212;
          xfer += iprot->readI32(ecast212);
          this->comp = static_cast<Comp::type>(ecast212);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size213;
            ::apache::thrift::protocol::TType _etype216;
            xfer += iprot->readListBegin(_etype216, _size213);
            this->fields.resize(_size213);
            uint32_t _i217;
            for (_i217 = 0; _i217 < _size213; ++_i217)
            {
              xfer += this->fields[_i217].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fields.size()));
    std::vector<SpecValueSerialField> ::const_iterator _iter218;
    for (_iter218 = this->fields.begin(); _iter218 != this->fields.end(); ++_iter218)
    {
      xfer += (*_iter218).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial &a, SpecValueSerial &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.fields, b.fields);
  swap(a.__isset, b.__isset);
}

SpecValueSerial::SpecValueSerial(const SpecValueSerial& other219) {
  comp = other219.comp;
  fields = other219.fields;
  __isset = other219.__isset;
}
SpecValueSerial::SpecValueSerial(SpecValueSerial&& other220) noexcept {
  comp = other220.comp;
  fields = std::move(other220.fields);
  __isset = other220.__isset;
}
SpecValueSerial& SpecValueSerial::operator=(const SpecValueSerial& other221) {
  comp = other221.comp;
  fields = other221.fields;
  __isset = other221.__isset;
  return *this;
}
SpecValueSerial& SpecValueSerial::operator=(SpecValueSerial&& other222) noexcept {
  comp = other222.comp;
  fields = std::move(other222.fields);
  __isset = other222.__isset;
  return *this;
}
void SpecValueSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial(";
  out << "comp=" << to_string(comp);
  out << ", " << "fields=" << to_string(fields);
  out << ")";
}


SpecIntervalSerial::~SpecIntervalSerial() noexcept {
}


void SpecIntervalSerial::__set_range_begin(const Key& val) {
  this->range_begin = val;
}

void SpecIntervalSerial::__set_range_end(const Key& val) {
  this->range_end = val;
}

void SpecIntervalSerial::__set_offset_key(const Key& val) {
  this->offset_key = val;
}

void SpecIntervalSerial::__set_offset_rev(const int64_t val) {
  this->offset_rev = val;
__isset.offset_rev = true;
}

void SpecIntervalSerial::__set_key_intervals(const SpecKeyIntervals& val) {
  this->key_intervals = val;
}

void SpecIntervalSerial::__set_values(const SpecValuesSerial& val) {
  this->values = val;
}

void SpecIntervalSerial::__set_ts_start(const SpecTimestamp& val) {
  this->ts_start = val;
__isset.ts_start = true;
}

void SpecIntervalSerial::__set_ts_finish(const SpecTimestamp& val) {
  this->ts_finish = val;
__isset.ts_finish = true;
}

void SpecIntervalSerial::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}

void SpecIntervalSerial::__set_options(const SpecIntervalOptions::type val) {
  this->options = val;
__isset.options = true;
}

void SpecIntervalSerial::__set_updating(const SpecIntervalUpdateSerial& val) {
  this->updating = val;
__isset.updating = true;
}
std::ostream& operator<<(std::ostream& out, const SpecIntervalSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecIntervalSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_begin.clear();
            uint32_t _size223;
            ::apache::thrift::protocol::TType _etype226;
            xfer += iprot->readListBegin(_etype226, _size223);
            this->range_begin.resize(_size223);
            uint32_t _i227;
            for (_i227 = 0; _i227 < _size223; ++_i227)
            {
              xfer += iprot->readBinary(this->range_begin[_i227]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_end.clear();
            uint32_t _size228;
            ::apache::thrift::protocol::TType _etype231;
            xfer += iprot->readListBegin(_etype231, _size228);
            this->range_end.resize(_size228);
            uint32_t _i232;
            for (_i232 = 0; _i232 < _size228; ++_i232)
            {
              xfer += iprot->readBinary(this->range_end[_i232]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->offset_key.clear();
            uint32_t _size233;
            ::apache::thrift::protocol::TType _etype236;
            xfer += iprot->readListBegin(_etype236, _size233);
            this->offset_key.resize(_size233);
            uint32_t _i237;
            for (_i237 = 0; _i237 < _size233; ++_i237)
            {
              xfer += iprot->readBinary(this->offset_key[_i237]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.offset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset_rev);
          this->__isset.offset_rev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_intervals.clear();
            uint32_t _size238;
            ::apache::thrift::protocol::TType _etype241;
            xfer += iprot->readListBegin(_etype241, _size238);
            this->key_intervals.resize(_size238);
            uint32_t _i242;
            for (_i242 = 0; _i242 < _size238; ++_i242)
            {
              xfer += this->key_intervals[_i242].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size243;
            ::apache::thrift::protocol::TType _etype246;
            xfer += iprot->readListBegin(_etype246, _size243);
            this->values.resize(_size243);
            uint32_t _i247;
            for (_i247 = 0; _i247 < _size243; ++_i247)
            {
              xfer += this->values[_i247].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_start.read(iprot);
          this->__isset.ts_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_finish.read(iprot);
          this->__isset.ts_finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast248;
          xfer += iprot->readI32(ecast248);
          this->options = static_cast<SpecIntervalOptions::type>(ecast248);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->updating.read(iprot);
          this->__isset.updating = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecIntervalSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecIntervalSerial");

  xfer += oprot->writeFieldBegin("range_begin", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_begin.size()));
    std::vector<std::string> ::const_iterator _iter249;
    for (_iter249 = this->range_begin.begin(); _iter249 != this->range_begin.end(); ++_iter249)
    {
      xfer += oprot->writeBinary((*_iter249));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range_end", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_end.size()));
    std::vector<std::string> ::const_iterator _iter250;
    for (_iter250 = this->range_end.begin(); _iter250 != this->range_end.end(); ++_iter250)
    {
      xfer += oprot->writeBinary((*_iter250));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset_key", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->offset_key.size()));
    std::vector<std::string> ::const_iterator _iter251;
    for (_iter251 = this->offset_key.begin(); _iter251 != this->offset_key.end(); ++_iter251)
    {
      xfer += oprot->writeBinary((*_iter251));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offset_rev) {
    xfer += oprot->writeFieldBegin("offset_rev", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->offset_rev);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("key_intervals", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->key_intervals.size()));
    std::vector<SpecKeyInterval> ::const_iterator _iter252;
    for (_iter252 = this->key_intervals.begin(); _iter252 != this->key_intervals.end(); ++_iter252)
    {
      xfer += (*_iter252).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector<SpecValueSerial> ::const_iterator _iter253;
    for (_iter253 = this->values.begin(); _iter253 != this->values.end(); ++_iter253)
    {
      xfer += (*_iter253).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts_start) {
    xfer += oprot->writeFieldBegin("ts_start", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->ts_start.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_finish) {
    xfer += oprot->writeFieldBegin("ts_finish", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->ts_finish.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(static_cast<int32_t>(this->options));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updating) {
    xfer += oprot->writeFieldBegin("updating", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->updating.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecIntervalSerial &a, SpecIntervalSerial &b) {
  using ::std::swap;
  swap(a.range_begin, b.range_begin);
  swap(a.range_end, b.range_end);
  swap(a.offset_key, b.offset_key);
  swap(a.offset_rev, b.offset_rev);
  swap(a.key_intervals, b.key_intervals);
  swap(a.values, b.values);
  swap(a.ts_start, b.ts_start);
  swap(a.ts_finish, b.ts_finish);
  swap(a.flags, b.flags);
  swap(a.options, b.options);
  swap(a.updating, b.updating);
  swap(a.__isset, b.__isset);
}

SpecIntervalSerial::SpecIntervalSerial(const SpecIntervalSerial& other254) {
  range_begin = other254.range_begin;
  range_end = other254.range_end;
  offset_key = other254.offset_key;
  offset_rev = other254.offset_rev;
  key_intervals = other254.key_intervals;
  values = other254.values;
  ts_start = other254.ts_start;
  ts_finish = other254.ts_finish;
  flags = other254.flags;
  options = other254.options;
  updating = other254.updating;
  __isset = other254.__isset;
}
SpecIntervalSerial::SpecIntervalSerial(SpecIntervalSerial&& other255) noexcept {
  range_begin = std::move(other255.range_begin);
  range_end = std::move(other255.range_end);
  offset_key = std::move(other255.offset_key);
  offset_rev = other255.offset_rev;
  key_intervals = std::move(other255.key_intervals);
  values = std::move(other255.values);
  ts_start = std::move(other255.ts_start);
  ts_finish = std::move(other255.ts_finish);
  flags = std::move(other255.flags);
  options = other255.options;
  updating = std::move(other255.updating);
  __isset = other255.__isset;
}
SpecIntervalSerial& SpecIntervalSerial::operator=(const SpecIntervalSerial& other256) {
  range_begin = other256.range_begin;
  range_end = other256.range_end;
  offset_key = other256.offset_key;
  offset_rev = other256.offset_rev;
  key_intervals = other256.key_intervals;
  values = other256.values;
  ts_start = other256.ts_start;
  ts_finish = other256.ts_finish;
  flags = other256.flags;
  options = other256.options;
  updating = other256.updating;
  __isset = other256.__isset;
  return *this;
}
SpecIntervalSerial& SpecIntervalSerial::operator=(SpecIntervalSerial&& other257) noexcept {
  range_begin = std::move(other257.range_begin);
  range_end = std::move(other257.range_end);
  offset_key = std::move(other257.offset_key);
  offset_rev = other257.offset_rev;
  key_intervals = std::move(other257.key_intervals);
  values = std::move(other257.values);
  ts_start = std::move(other257.ts_start);
  ts_finish = std::move(other257.ts_finish);
  flags = std::move(other257.flags);
  options = other257.options;
  updating = std::move(other257.updating);
  __isset = other257.__isset;
  return *this;
}
void SpecIntervalSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecIntervalSerial(";
  out << "range_begin=" << to_string(range_begin);
  out << ", " << "range_end=" << to_string(range_end);
  out << ", " << "offset_key=" << to_string(offset_key);
  out << ", " << "offset_rev="; (__isset.offset_rev ? (out << to_string(offset_rev)) : (out << "<null>"));
  out << ", " << "key_intervals=" << to_string(key_intervals);
  out << ", " << "values=" << to_string(values);
  out << ", " << "ts_start="; (__isset.ts_start ? (out << to_string(ts_start)) : (out << "<null>"));
  out << ", " << "ts_finish="; (__isset.ts_finish ? (out << to_string(ts_finish)) : (out << "<null>"));
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ", " << "updating="; (__isset.updating ? (out << to_string(updating)) : (out << "<null>"));
  out << ")";
}


SpecColumnSerial::~SpecColumnSerial() noexcept {
}


void SpecColumnSerial::__set_cid(const int64_t val) {
  this->cid = val;
}

void SpecColumnSerial::__set_intervals(const std::vector<SpecIntervalSerial> & val) {
  this->intervals = val;
}
std::ostream& operator<<(std::ostream& out, const SpecColumnSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecColumnSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->intervals.clear();
            uint32_t _size258;
            ::apache::thrift::protocol::TType _etype261;
            xfer += iprot->readListBegin(_etype261, _size258);
            this->intervals.resize(_size258);
            uint32_t _i262;
            for (_i262 = 0; _i262 < _size258; ++_i262)
            {
              xfer += this->intervals[_i262].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecColumnSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecColumnSerial");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intervals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->intervals.size()));
    std::vector<SpecIntervalSerial> ::const_iterator _iter263;
    for (_iter263 = this->intervals.begin(); _iter263 != this->intervals.end(); ++_iter263)
    {
      xfer += (*_iter263).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecColumnSerial &a, SpecColumnSerial &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.intervals, b.intervals);
  swap(a.__isset, b.__isset);
}

SpecColumnSerial::SpecColumnSerial(const SpecColumnSerial& other264) {
  cid = other264.cid;
  intervals = other264.intervals;
  __isset = other264.__isset;
}
SpecColumnSerial::SpecColumnSerial(SpecColumnSerial&& other265) noexcept {
  cid = other265.cid;
  intervals = std::move(other265.intervals);
  __isset = other265.__isset;
}
SpecColumnSerial& SpecColumnSerial::operator=(const SpecColumnSerial& other266) {
  cid = other266.cid;
  intervals = other266.intervals;
  __isset = other266.__isset;
  return *this;
}
SpecColumnSerial& SpecColumnSerial::operator=(SpecColumnSerial&& other267) noexcept {
  cid = other267.cid;
  intervals = std::move(other267.intervals);
  __isset = other267.__isset;
  return *this;
}
void SpecColumnSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecColumnSerial(";
  out << "cid=" << to_string(cid);
  out << ", " << "intervals=" << to_string(intervals);
  out << ")";
}


SpecScan::~SpecScan() noexcept {
}


void SpecScan::__set_columns(const std::vector<SpecColumn> & val) {
  this->columns = val;
}

void SpecScan::__set_columns_serial(const std::vector<SpecColumnSerial> & val) {
  this->columns_serial = val;
}

void SpecScan::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}
std::ostream& operator<<(std::ostream& out, const SpecScan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecScan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size268;
            ::apache::thrift::protocol::TType _etype271;
            xfer += iprot->readListBegin(_etype271, _size268);
            this->columns.resize(_size268);
            uint32_t _i272;
            for (_i272 = 0; _i272 < _size268; ++_i272)
            {
              xfer += this->columns[_i272].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns_serial.clear();
            uint32_t _size273;
            ::apache::thrift::protocol::TType _etype276;
            xfer += iprot->readListBegin(_etype276, _size273);
            this->columns_serial.resize(_size273);
            uint32_t _i277;
            for (_i277 = 0; _i277 < _size273; ++_i277)
            {
              xfer += this->columns_serial[_i277].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns_serial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecScan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecScan");

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns.size()));
    std::vector<SpecColumn> ::const_iterator _iter278;
    for (_iter278 = this->columns.begin(); _iter278 != this->columns.end(); ++_iter278)
    {
      xfer += (*_iter278).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns_serial", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns_serial.size()));
    std::vector<SpecColumnSerial> ::const_iterator _iter279;
    for (_iter279 = this->columns_serial.begin(); _iter279 != this->columns_serial.end(); ++_iter279)
    {
      xfer += (*_iter279).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecScan &a, SpecScan &b) {
  using ::std::swap;
  swap(a.columns, b.columns);
  swap(a.columns_serial, b.columns_serial);
  swap(a.flags, b.flags);
  swap(a.__isset, b.__isset);
}

SpecScan::SpecScan(const SpecScan& other280) {
  columns = other280.columns;
  columns_serial = other280.columns_serial;
  flags = other280.flags;
  __isset = other280.__isset;
}
SpecScan::SpecScan(SpecScan&& other281) noexcept {
  columns = std::move(other281.columns);
  columns_serial = std::move(other281.columns_serial);
  flags = std::move(other281.flags);
  __isset = other281.__isset;
}
SpecScan& SpecScan::operator=(const SpecScan& other282) {
  columns = other282.columns;
  columns_serial = other282.columns_serial;
  flags = other282.flags;
  __isset = other282.__isset;
  return *this;
}
SpecScan& SpecScan::operator=(SpecScan&& other283) noexcept {
  columns = std::move(other283.columns);
  columns_serial = std::move(other283.columns_serial);
  flags = std::move(other283.flags);
  __isset = other283.__isset;
  return *this;
}
void SpecScan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecScan(";
  out << "columns=" << to_string(columns);
  out << ", " << "columns_serial=" << to_string(columns_serial);
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ")";
}


UCell::~UCell() noexcept {
}


void UCell::__set_f(const Flag::type val) {
  this->f = val;
}

void UCell::__set_k(const Key& val) {
  this->k = val;
}

void UCell::__set_ts(const int64_t val) {
  this->ts = val;
__isset.ts = true;
}

void UCell::__set_ts_desc(const bool val) {
  this->ts_desc = val;
__isset.ts_desc = true;
}

void UCell::__set_v(const std::string& val) {
  this->v = val;
}

void UCell::__set_encoder(const EncodingType::type val) {
  this->encoder = val;
__isset.encoder = true;
}
std::ostream& operator<<(std::ostream& out, const UCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast284;
          xfer += iprot->readI32(ecast284);
          this->f = static_cast<Flag::type>(ecast284);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size285;
            ::apache::thrift::protocol::TType _etype288;
            xfer += iprot->readListBegin(_etype288, _size285);
            this->k.resize(_size285);
            uint32_t _i289;
            for (_i289 = 0; _i289 < _size285; ++_i289)
            {
              xfer += iprot->readBinary(this->k[_i289]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ts_desc);
          this->__isset.ts_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast290;
          xfer += iprot->readI32(ecast290);
          this->encoder = static_cast<EncodingType::type>(ecast290);
          this->__isset.encoder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UCell");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->f));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter291;
    for (_iter291 = this->k.begin(); _iter291 != this->k.end(); ++_iter291)
    {
      xfer += oprot->writeBinary((*_iter291));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts) {
    xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_desc) {
    xfer += oprot->writeFieldBegin("ts_desc", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->ts_desc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.encoder) {
    xfer += oprot->writeFieldBegin("encoder", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->encoder));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UCell &a, UCell &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.ts_desc, b.ts_desc);
  swap(a.v, b.v);
  swap(a.encoder, b.encoder);
  swap(a.__isset, b.__isset);
}

UCell::UCell(const UCell& other292) {
  f = other292.f;
  k = other292.k;
  ts = other292.ts;
  ts_desc = other292.ts_desc;
  v = other292.v;
  encoder = other292.encoder;
  __isset = other292.__isset;
}
UCell::UCell(UCell&& other293) noexcept {
  f = other293.f;
  k = std::move(other293.k);
  ts = other293.ts;
  ts_desc = other293.ts_desc;
  v = std::move(other293.v);
  encoder = other293.encoder;
  __isset = other293.__isset;
}
UCell& UCell::operator=(const UCell& other294) {
  f = other294.f;
  k = other294.k;
  ts = other294.ts;
  ts_desc = other294.ts_desc;
  v = other294.v;
  encoder = other294.encoder;
  __isset = other294.__isset;
  return *this;
}
UCell& UCell::operator=(UCell&& other295) noexcept {
  f = other295.f;
  k = std::move(other295.k);
  ts = other295.ts;
  ts_desc = other295.ts_desc;
  v = std::move(other295.v);
  encoder = other295.encoder;
  __isset = other295.__isset;
  return *this;
}
void UCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UCell(";
  out << "f=" << to_string(f);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts="; (__isset.ts ? (out << to_string(ts)) : (out << "<null>"));
  out << ", " << "ts_desc="; (__isset.ts_desc ? (out << to_string(ts_desc)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ", " << "encoder="; (__isset.encoder ? (out << to_string(encoder)) : (out << "<null>"));
  out << ")";
}


CellValueSerial::~CellValueSerial() noexcept {
}


void CellValueSerial::__set_field_id(const int32_t val) {
  this->field_id = val;
}

void CellValueSerial::__set_v_int64(const int64_t val) {
  this->v_int64 = val;
__isset.v_int64 = true;
}

void CellValueSerial::__set_v_double(const double val) {
  this->v_double = val;
__isset.v_double = true;
}

void CellValueSerial::__set_v_bytes(const std::string& val) {
  this->v_bytes = val;
}

void CellValueSerial::__set_v_key(const Key& val) {
  this->v_key = val;
}

void CellValueSerial::__set_v_li(const std::vector<int64_t> & val) {
  this->v_li = val;
}

void CellValueSerial::__set_v_lb(const std::vector<std::string> & val) {
  this->v_lb = val;
}
std::ostream& operator<<(std::ostream& out, const CellValueSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellValueSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field_id);
          this->__isset.field_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v_int64);
          this->__isset.v_int64 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v_double);
          this->__isset.v_double = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v_bytes);
          this->__isset.v_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_key.clear();
            uint32_t _size296;
            ::apache::thrift::protocol::TType _etype299;
            xfer += iprot->readListBegin(_etype299, _size296);
            this->v_key.resize(_size296);
            uint32_t _i300;
            for (_i300 = 0; _i300 < _size296; ++_i300)
            {
              xfer += iprot->readBinary(this->v_key[_i300]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_li.clear();
            uint32_t _size301;
            ::apache::thrift::protocol::TType _etype304;
            xfer += iprot->readListBegin(_etype304, _size301);
            this->v_li.resize(_size301);
            uint32_t _i305;
            for (_i305 = 0; _i305 < _size301; ++_i305)
            {
              xfer += iprot->readI64(this->v_li[_i305]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_li = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_lb.clear();
            uint32_t _size306;
            ::apache::thrift::protocol::TType _etype309;
            xfer += iprot->readListBegin(_etype309, _size306);
            this->v_lb.resize(_size306);
            uint32_t _i310;
            for (_i310 = 0; _i310 < _size306; ++_i310)
            {
              xfer += iprot->readBinary(this->v_lb[_i310]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_lb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellValueSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellValueSerial");

  xfer += oprot->writeFieldBegin("field_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.v_int64) {
    xfer += oprot->writeFieldBegin("v_int64", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->v_int64);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_double) {
    xfer += oprot->writeFieldBegin("v_double", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->v_double);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v_bytes", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->v_bytes);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_key", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->v_key.size()));
    std::vector<std::string> ::const_iterator _iter311;
    for (_iter311 = this->v_key.begin(); _iter311 != this->v_key.end(); ++_iter311)
    {
      xfer += oprot->writeBinary((*_iter311));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_li", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->v_li.size()));
    std::vector<int64_t> ::const_iterator _iter312;
    for (_iter312 = this->v_li.begin(); _iter312 != this->v_li.end(); ++_iter312)
    {
      xfer += oprot->writeI64((*_iter312));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_lb", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->v_lb.size()));
    std::vector<std::string> ::const_iterator _iter313;
    for (_iter313 = this->v_lb.begin(); _iter313 != this->v_lb.end(); ++_iter313)
    {
      xfer += oprot->writeBinary((*_iter313));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellValueSerial &a, CellValueSerial &b) {
  using ::std::swap;
  swap(a.field_id, b.field_id);
  swap(a.v_int64, b.v_int64);
  swap(a.v_double, b.v_double);
  swap(a.v_bytes, b.v_bytes);
  swap(a.v_key, b.v_key);
  swap(a.v_li, b.v_li);
  swap(a.v_lb, b.v_lb);
  swap(a.__isset, b.__isset);
}

CellValueSerial::CellValueSerial(const CellValueSerial& other314) {
  field_id = other314.field_id;
  v_int64 = other314.v_int64;
  v_double = other314.v_double;
  v_bytes = other314.v_bytes;
  v_key = other314.v_key;
  v_li = other314.v_li;
  v_lb = other314.v_lb;
  __isset = other314.__isset;
}
CellValueSerial::CellValueSerial(CellValueSerial&& other315) noexcept {
  field_id = other315.field_id;
  v_int64 = other315.v_int64;
  v_double = other315.v_double;
  v_bytes = std::move(other315.v_bytes);
  v_key = std::move(other315.v_key);
  v_li = std::move(other315.v_li);
  v_lb = std::move(other315.v_lb);
  __isset = other315.__isset;
}
CellValueSerial& CellValueSerial::operator=(const CellValueSerial& other316) {
  field_id = other316.field_id;
  v_int64 = other316.v_int64;
  v_double = other316.v_double;
  v_bytes = other316.v_bytes;
  v_key = other316.v_key;
  v_li = other316.v_li;
  v_lb = other316.v_lb;
  __isset = other316.__isset;
  return *this;
}
CellValueSerial& CellValueSerial::operator=(CellValueSerial&& other317) noexcept {
  field_id = other317.field_id;
  v_int64 = other317.v_int64;
  v_double = other317.v_double;
  v_bytes = std::move(other317.v_bytes);
  v_key = std::move(other317.v_key);
  v_li = std::move(other317.v_li);
  v_lb = std::move(other317.v_lb);
  __isset = other317.__isset;
  return *this;
}
void CellValueSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellValueSerial(";
  out << "field_id=" << to_string(field_id);
  out << ", " << "v_int64="; (__isset.v_int64 ? (out << to_string(v_int64)) : (out << "<null>"));
  out << ", " << "v_double="; (__isset.v_double ? (out << to_string(v_double)) : (out << "<null>"));
  out << ", " << "v_bytes=" << to_string(v_bytes);
  out << ", " << "v_key=" << to_string(v_key);
  out << ", " << "v_li=" << to_string(v_li);
  out << ", " << "v_lb=" << to_string(v_lb);
  out << ")";
}


UCellSerial::~UCellSerial() noexcept {
}


void UCellSerial::__set_f(const Flag::type val) {
  this->f = val;
}

void UCellSerial::__set_k(const Key& val) {
  this->k = val;
}

void UCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
__isset.ts = true;
}

void UCellSerial::__set_ts_desc(const bool val) {
  this->ts_desc = val;
__isset.ts_desc = true;
}

void UCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}

void UCellSerial::__set_encoder(const EncodingType::type val) {
  this->encoder = val;
__isset.encoder = true;
}
std::ostream& operator<<(std::ostream& out, const UCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast318;
          xfer += iprot->readI32(ecast318);
          this->f = static_cast<Flag::type>(ecast318);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size319;
            ::apache::thrift::protocol::TType _etype322;
            xfer += iprot->readListBegin(_etype322, _size319);
            this->k.resize(_size319);
            uint32_t _i323;
            for (_i323 = 0; _i323 < _size319; ++_i323)
            {
              xfer += iprot->readBinary(this->k[_i323]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ts_desc);
          this->__isset.ts_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size324;
            ::apache::thrift::protocol::TType _etype327;
            xfer += iprot->readListBegin(_etype327, _size324);
            this->v.resize(_size324);
            uint32_t _i328;
            for (_i328 = 0; _i328 < _size324; ++_i328)
            {
              xfer += this->v[_i328].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast329;
          xfer += iprot->readI32(ecast329);
          this->encoder = static_cast<EncodingType::type>(ecast329);
          this->__isset.encoder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UCellSerial");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->f));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter330;
    for (_iter330 = this->k.begin(); _iter330 != this->k.end(); ++_iter330)
    {
      xfer += oprot->writeBinary((*_iter330));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts) {
    xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_desc) {
    xfer += oprot->writeFieldBegin("ts_desc", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->ts_desc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter331;
    for (_iter331 = this->v.begin(); _iter331 != this->v.end(); ++_iter331)
    {
      xfer += (*_iter331).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.encoder) {
    xfer += oprot->writeFieldBegin("encoder", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->encoder));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UCellSerial &a, UCellSerial &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.ts_desc, b.ts_desc);
  swap(a.v, b.v);
  swap(a.encoder, b.encoder);
  swap(a.__isset, b.__isset);
}

UCellSerial::UCellSerial(const UCellSerial& other332) {
  f = other332.f;
  k = other332.k;
  ts = other332.ts;
  ts_desc = other332.ts_desc;
  v = other332.v;
  encoder = other332.encoder;
  __isset = other332.__isset;
}
UCellSerial::UCellSerial(UCellSerial&& other333) noexcept {
  f = other333.f;
  k = std::move(other333.k);
  ts = other333.ts;
  ts_desc = other333.ts_desc;
  v = std::move(other333.v);
  encoder = other333.encoder;
  __isset = other333.__isset;
}
UCellSerial& UCellSerial::operator=(const UCellSerial& other334) {
  f = other334.f;
  k = other334.k;
  ts = other334.ts;
  ts_desc = other334.ts_desc;
  v = other334.v;
  encoder = other334.encoder;
  __isset = other334.__isset;
  return *this;
}
UCellSerial& UCellSerial::operator=(UCellSerial&& other335) noexcept {
  f = other335.f;
  k = std::move(other335.k);
  ts = other335.ts;
  ts_desc = other335.ts_desc;
  v = std::move(other335.v);
  encoder = other335.encoder;
  __isset = other335.__isset;
  return *this;
}
void UCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UCellSerial(";
  out << "f=" << to_string(f);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts="; (__isset.ts ? (out << to_string(ts)) : (out << "<null>"));
  out << ", " << "ts_desc="; (__isset.ts_desc ? (out << to_string(ts_desc)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ", " << "encoder="; (__isset.encoder ? (out << to_string(encoder)) : (out << "<null>"));
  out << ")";
}


Cell::~Cell() noexcept {
}


void Cell::__set_c(const std::string& val) {
  this->c = val;
}

void Cell::__set_k(const Key& val) {
  this->k = val;
}

void Cell::__set_ts(const int64_t val) {
  this->ts = val;
}

void Cell::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const Cell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size336;
            ::apache::thrift::protocol::TType _etype339;
            xfer += iprot->readListBegin(_etype339, _size336);
            this->k.resize(_size336);
            uint32_t _i340;
            for (_i340 = 0; _i340 < _size336; ++_i340)
            {
              xfer += iprot->readBinary(this->k[_i340]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cell");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter341;
    for (_iter341 = this->k.begin(); _iter341 != this->k.end(); ++_iter341)
    {
      xfer += oprot->writeBinary((*_iter341));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cell &a, Cell &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

Cell::Cell(const Cell& other342) {
  c = other342.c;
  k = other342.k;
  ts = other342.ts;
  v = other342.v;
  __isset = other342.__isset;
}
Cell::Cell(Cell&& other343) noexcept {
  c = std::move(other343.c);
  k = std::move(other343.k);
  ts = other343.ts;
  v = std::move(other343.v);
  __isset = other343.__isset;
}
Cell& Cell::operator=(const Cell& other344) {
  c = other344.c;
  k = other344.k;
  ts = other344.ts;
  v = other344.v;
  __isset = other344.__isset;
  return *this;
}
Cell& Cell::operator=(Cell&& other345) noexcept {
  c = std::move(other345.c);
  k = std::move(other345.k);
  ts = other345.ts;
  v = std::move(other345.v);
  __isset = other345.__isset;
  return *this;
}
void Cell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cell(";
  out << "c=" << to_string(c);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


CellSerial::~CellSerial() noexcept {
}


void CellSerial::__set_c(const std::string& val) {
  this->c = val;
}

void CellSerial::__set_k(const Key& val) {
  this->k = val;
}

void CellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void CellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const CellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size346;
            ::apache::thrift::protocol::TType _etype349;
            xfer += iprot->readListBegin(_etype349, _size346);
            this->k.resize(_size346);
            uint32_t _i350;
            for (_i350 = 0; _i350 < _size346; ++_i350)
            {
              xfer += iprot->readBinary(this->k[_i350]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size351;
            ::apache::thrift::protocol::TType _etype354;
            xfer += iprot->readListBegin(_etype354, _size351);
            this->v.resize(_size351);
            uint32_t _i355;
            for (_i355 = 0; _i355 < _size351; ++_i355)
            {
              xfer += this->v[_i355].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellSerial");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter356;
    for (_iter356 = this->k.begin(); _iter356 != this->k.end(); ++_iter356)
    {
      xfer += oprot->writeBinary((*_iter356));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter357;
    for (_iter357 = this->v.begin(); _iter357 != this->v.end(); ++_iter357)
    {
      xfer += (*_iter357).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellSerial &a, CellSerial &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CellSerial::CellSerial(const CellSerial& other358) {
  c = other358.c;
  k = other358.k;
  ts = other358.ts;
  v = other358.v;
  __isset = other358.__isset;
}
CellSerial::CellSerial(CellSerial&& other359) noexcept {
  c = std::move(other359.c);
  k = std::move(other359.k);
  ts = other359.ts;
  v = std::move(other359.v);
  __isset = other359.__isset;
}
CellSerial& CellSerial::operator=(const CellSerial& other360) {
  c = other360.c;
  k = other360.k;
  ts = other360.ts;
  v = other360.v;
  __isset = other360.__isset;
  return *this;
}
CellSerial& CellSerial::operator=(CellSerial&& other361) noexcept {
  c = std::move(other361.c);
  k = std::move(other361.k);
  ts = other361.ts;
  v = std::move(other361.v);
  __isset = other361.__isset;
  return *this;
}
void CellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellSerial(";
  out << "c=" << to_string(c);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


Cells::~Cells() noexcept {
}


void Cells::__set_cells(const std::vector<Cell> & val) {
  this->cells = val;
}

void Cells::__set_serial_cells(const std::vector<CellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const Cells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size362;
            ::apache::thrift::protocol::TType _etype365;
            xfer += iprot->readListBegin(_etype365, _size362);
            this->cells.resize(_size362);
            uint32_t _i366;
            for (_i366 = 0; _i366 < _size362; ++_i366)
            {
              xfer += this->cells[_i366].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size367;
            ::apache::thrift::protocol::TType _etype370;
            xfer += iprot->readListBegin(_etype370, _size367);
            this->serial_cells.resize(_size367);
            uint32_t _i371;
            for (_i371 = 0; _i371 < _size367; ++_i371)
            {
              xfer += this->serial_cells[_i371].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cells");

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<Cell> ::const_iterator _iter372;
    for (_iter372 = this->cells.begin(); _iter372 != this->cells.end(); ++_iter372)
    {
      xfer += (*_iter372).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<CellSerial> ::const_iterator _iter373;
    for (_iter373 = this->serial_cells.begin(); _iter373 != this->serial_cells.end(); ++_iter373)
    {
      xfer += (*_iter373).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cells &a, Cells &b) {
  using ::std::swap;
  swap(a.cells, b.cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

Cells::Cells(const Cells& other374) {
  cells = other374.cells;
  serial_cells = other374.serial_cells;
  __isset = other374.__isset;
}
Cells::Cells(Cells&& other375) noexcept {
  cells = std::move(other375.cells);
  serial_cells = std::move(other375.serial_cells);
  __isset = other375.__isset;
}
Cells& Cells::operator=(const Cells& other376) {
  cells = other376.cells;
  serial_cells = other376.serial_cells;
  __isset = other376.__isset;
  return *this;
}
Cells& Cells::operator=(Cells&& other377) noexcept {
  cells = std::move(other377.cells);
  serial_cells = std::move(other377.serial_cells);
  __isset = other377.__isset;
  return *this;
}
void Cells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cells(";
  out << "cells=" << to_string(cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


CCell::~CCell() noexcept {
}


void CCell::__set_k(const Key& val) {
  this->k = val;
}

void CCell::__set_ts(const int64_t val) {
  this->ts = val;
}

void CCell::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const CCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size378;
            ::apache::thrift::protocol::TType _etype381;
            xfer += iprot->readListBegin(_etype381, _size378);
            this->k.resize(_size378);
            uint32_t _i382;
            for (_i382 = 0; _i382 < _size378; ++_i382)
            {
              xfer += iprot->readBinary(this->k[_i382]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCell");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter383;
    for (_iter383 = this->k.begin(); _iter383 != this->k.end(); ++_iter383)
    {
      xfer += oprot->writeBinary((*_iter383));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCell &a, CCell &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CCell::CCell(const CCell& other384) {
  k = other384.k;
  ts = other384.ts;
  v = other384.v;
  __isset = other384.__isset;
}
CCell::CCell(CCell&& other385) noexcept {
  k = std::move(other385.k);
  ts = other385.ts;
  v = std::move(other385.v);
  __isset = other385.__isset;
}
CCell& CCell::operator=(const CCell& other386) {
  k = other386.k;
  ts = other386.ts;
  v = other386.v;
  __isset = other386.__isset;
  return *this;
}
CCell& CCell::operator=(CCell&& other387) noexcept {
  k = std::move(other387.k);
  ts = other387.ts;
  v = std::move(other387.v);
  __isset = other387.__isset;
  return *this;
}
void CCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCell(";
  out << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


CCellSerial::~CCellSerial() noexcept {
}


void CCellSerial::__set_k(const Key& val) {
  this->k = val;
}

void CCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void CCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const CCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size388;
            ::apache::thrift::protocol::TType _etype391;
            xfer += iprot->readListBegin(_etype391, _size388);
            this->k.resize(_size388);
            uint32_t _i392;
            for (_i392 = 0; _i392 < _size388; ++_i392)
            {
              xfer += iprot->readBinary(this->k[_i392]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size393;
            ::apache::thrift::protocol::TType _etype396;
            xfer += iprot->readListBegin(_etype396, _size393);
            this->v.resize(_size393);
            uint32_t _i397;
            for (_i397 = 0; _i397 < _size393; ++_i397)
            {
              xfer += this->v[_i397].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCellSerial");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter398;
    for (_iter398 = this->k.begin(); _iter398 != this->k.end(); ++_iter398)
    {
      xfer += oprot->writeBinary((*_iter398));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter399;
    for (_iter399 = this->v.begin(); _iter399 != this->v.end(); ++_iter399)
    {
      xfer += (*_iter399).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCellSerial &a, CCellSerial &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CCellSerial::CCellSerial(const CCellSerial& other400) {
  k = other400.k;
  ts = other400.ts;
  v = other400.v;
  __isset = other400.__isset;
}
CCellSerial::CCellSerial(CCellSerial&& other401) noexcept {
  k = std::move(other401.k);
  ts = other401.ts;
  v = std::move(other401.v);
  __isset = other401.__isset;
}
CCellSerial& CCellSerial::operator=(const CCellSerial& other402) {
  k = other402.k;
  ts = other402.ts;
  v = other402.v;
  __isset = other402.__isset;
  return *this;
}
CCellSerial& CCellSerial::operator=(CCellSerial&& other403) noexcept {
  k = std::move(other403.k);
  ts = other403.ts;
  v = std::move(other403.v);
  __isset = other403.__isset;
  return *this;
}
void CCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCellSerial(";
  out << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


ColCells::~ColCells() noexcept {
}


void ColCells::__set_cells(const std::vector<CCell> & val) {
  this->cells = val;
}

void ColCells::__set_serial_cells(const std::vector<CCellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const ColCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size404;
            ::apache::thrift::protocol::TType _etype407;
            xfer += iprot->readListBegin(_etype407, _size404);
            this->cells.resize(_size404);
            uint32_t _i408;
            for (_i408 = 0; _i408 < _size404; ++_i408)
            {
              xfer += this->cells[_i408].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size409;
            ::apache::thrift::protocol::TType _etype412;
            xfer += iprot->readListBegin(_etype412, _size409);
            this->serial_cells.resize(_size409);
            uint32_t _i413;
            for (_i413 = 0; _i413 < _size409; ++_i413)
            {
              xfer += this->serial_cells[_i413].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColCells");

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<CCell> ::const_iterator _iter414;
    for (_iter414 = this->cells.begin(); _iter414 != this->cells.end(); ++_iter414)
    {
      xfer += (*_iter414).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<CCellSerial> ::const_iterator _iter415;
    for (_iter415 = this->serial_cells.begin(); _iter415 != this->serial_cells.end(); ++_iter415)
    {
      xfer += (*_iter415).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColCells &a, ColCells &b) {
  using ::std::swap;
  swap(a.cells, b.cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

ColCells::ColCells(const ColCells& other416) {
  cells = other416.cells;
  serial_cells = other416.serial_cells;
  __isset = other416.__isset;
}
ColCells::ColCells(ColCells&& other417) noexcept {
  cells = std::move(other417.cells);
  serial_cells = std::move(other417.serial_cells);
  __isset = other417.__isset;
}
ColCells& ColCells::operator=(const ColCells& other418) {
  cells = other418.cells;
  serial_cells = other418.serial_cells;
  __isset = other418.__isset;
  return *this;
}
ColCells& ColCells::operator=(ColCells&& other419) noexcept {
  cells = std::move(other419.cells);
  serial_cells = std::move(other419.serial_cells);
  __isset = other419.__isset;
  return *this;
}
void ColCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColCells(";
  out << "cells=" << to_string(cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


KCell::~KCell() noexcept {
}


void KCell::__set_c(const std::string& val) {
  this->c = val;
}

void KCell::__set_ts(const int64_t val) {
  this->ts = val;
}

void KCell::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const KCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KCell");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KCell &a, KCell &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

KCell::KCell(const KCell& other420) {
  c = other420.c;
  ts = other420.ts;
  v = other420.v;
  __isset = other420.__isset;
}
KCell::KCell(KCell&& other421) noexcept {
  c = std::move(other421.c);
  ts = other421.ts;
  v = std::move(other421.v);
  __isset = other421.__isset;
}
KCell& KCell::operator=(const KCell& other422) {
  c = other422.c;
  ts = other422.ts;
  v = other422.v;
  __isset = other422.__isset;
  return *this;
}
KCell& KCell::operator=(KCell&& other423) noexcept {
  c = std::move(other423.c);
  ts = other423.ts;
  v = std::move(other423.v);
  __isset = other423.__isset;
  return *this;
}
void KCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KCell(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


KCellSerial::~KCellSerial() noexcept {
}


void KCellSerial::__set_c(const std::string& val) {
  this->c = val;
}

void KCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void KCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const KCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size424;
            ::apache::thrift::protocol::TType _etype427;
            xfer += iprot->readListBegin(_etype427, _size424);
            this->v.resize(_size424);
            uint32_t _i428;
            for (_i428 = 0; _i428 < _size424; ++_i428)
            {
              xfer += this->v[_i428].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KCellSerial");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter429;
    for (_iter429 = this->v.begin(); _iter429 != this->v.end(); ++_iter429)
    {
      xfer += (*_iter429).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KCellSerial &a, KCellSerial &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

KCellSerial::KCellSerial(const KCellSerial& other430) {
  c = other430.c;
  ts = other430.ts;
  v = other430.v;
  __isset = other430.__isset;
}
KCellSerial::KCellSerial(KCellSerial&& other431) noexcept {
  c = std::move(other431.c);
  ts = other431.ts;
  v = std::move(other431.v);
  __isset = other431.__isset;
}
KCellSerial& KCellSerial::operator=(const KCellSerial& other432) {
  c = other432.c;
  ts = other432.ts;
  v = other432.v;
  __isset = other432.__isset;
  return *this;
}
KCellSerial& KCellSerial::operator=(KCellSerial&& other433) noexcept {
  c = std::move(other433.c);
  ts = other433.ts;
  v = std::move(other433.v);
  __isset = other433.__isset;
  return *this;
}
void KCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KCellSerial(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


kCells::~kCells() noexcept {
}


void kCells::__set_k(const Key& val) {
  this->k = val;
}

void kCells::__set_cells(const std::vector<KCell> & val) {
  this->cells = val;
}

void kCells::__set_serial_cells(const std::vector<KCellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const kCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t kCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size434;
            ::apache::thrift::protocol::TType _etype437;
            xfer += iprot->readListBegin(_etype437, _size434);
            this->k.resize(_size434);
            uint32_t _i438;
            for (_i438 = 0; _i438 < _size434; ++_i438)
            {
              xfer += iprot->readBinary(this->k[_i438]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size439;
            ::apache::thrift::protocol::TType _etype442;
            xfer += iprot->readListBegin(_etype442, _size439);
            this->cells.resize(_size439);
            uint32_t _i443;
            for (_i443 = 0; _i443 < _size439; ++_i443)
            {
              xfer += this->cells[_i443].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size444;
            ::apache::thrift::protocol::TType _etype447;
            xfer += iprot->readListBegin(_etype447, _size444);
            this->serial_cells.resize(_size444);
            uint32_t _i448;
            for (_i448 = 0; _i448 < _size444; ++_i448)
            {
              xfer += this->serial_cells[_i448].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kCells");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter449;
    for (_iter449 = this->k.begin(); _iter449 != this->k.end(); ++_iter449)
    {
      xfer += oprot->writeBinary((*_iter449));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<KCell> ::const_iterator _iter450;
    for (_iter450 = this->cells.begin(); _iter450 != this->cells.end(); ++_iter450)
    {
      xfer += (*_iter450).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<KCellSerial> ::const_iterator _iter451;
    for (_iter451 = this->serial_cells.begin(); _iter451 != this->serial_cells.end(); ++_iter451)
    {
      xfer += (*_iter451).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(kCells &a, kCells &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.cells, b.cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

kCells::kCells(const kCells& other452) {
  k = other452.k;
  cells = other452.cells;
  serial_cells = other452.serial_cells;
  __isset = other452.__isset;
}
kCells::kCells(kCells&& other453) noexcept {
  k = std::move(other453.k);
  cells = std::move(other453.cells);
  serial_cells = std::move(other453.serial_cells);
  __isset = other453.__isset;
}
kCells& kCells::operator=(const kCells& other454) {
  k = other454.k;
  cells = other454.cells;
  serial_cells = other454.serial_cells;
  __isset = other454.__isset;
  return *this;
}
kCells& kCells::operator=(kCells&& other455) noexcept {
  k = std::move(other455.k);
  cells = std::move(other455.cells);
  serial_cells = std::move(other455.serial_cells);
  __isset = other455.__isset;
  return *this;
}
void kCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "kCells(";
  out << "k=" << to_string(k);
  out << ", " << "cells=" << to_string(cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


FCell::~FCell() noexcept {
}


void FCell::__set_c(const std::string& val) {
  this->c = val;
}

void FCell::__set_ts(const int64_t val) {
  this->ts = val;
}

void FCell::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FCell& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCell::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCell::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCell");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCell &a, FCell &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FCell::FCell(const FCell& other456) {
  c = other456.c;
  ts = other456.ts;
  v = other456.v;
  __isset = other456.__isset;
}
FCell::FCell(FCell&& other457) noexcept {
  c = std::move(other457.c);
  ts = other457.ts;
  v = std::move(other457.v);
  __isset = other457.__isset;
}
FCell& FCell::operator=(const FCell& other458) {
  c = other458.c;
  ts = other458.ts;
  v = other458.v;
  __isset = other458.__isset;
  return *this;
}
FCell& FCell::operator=(FCell&& other459) noexcept {
  c = std::move(other459.c);
  ts = other459.ts;
  v = std::move(other459.v);
  __isset = other459.__isset;
  return *this;
}
void FCell::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCell(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FCellSerial::~FCellSerial() noexcept {
}


void FCellSerial::__set_c(const std::string& val) {
  this->c = val;
}

void FCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void FCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size460;
            ::apache::thrift::protocol::TType _etype463;
            xfer += iprot->readListBegin(_etype463, _size460);
            this->v.resize(_size460);
            uint32_t _i464;
            for (_i464 = 0; _i464 < _size460; ++_i464)
            {
              xfer += this->v[_i464].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCellSerial");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter465;
    for (_iter465 = this->v.begin(); _iter465 != this->v.end(); ++_iter465)
    {
      xfer += (*_iter465).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCellSerial &a, FCellSerial &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FCellSerial::FCellSerial(const FCellSerial& other466) {
  c = other466.c;
  ts = other466.ts;
  v = other466.v;
  __isset = other466.__isset;
}
FCellSerial::FCellSerial(FCellSerial&& other467) noexcept {
  c = std::move(other467.c);
  ts = other467.ts;
  v = std::move(other467.v);
  __isset = other467.__isset;
}
FCellSerial& FCellSerial::operator=(const FCellSerial& other468) {
  c = other468.c;
  ts = other468.ts;
  v = other468.v;
  __isset = other468.__isset;
  return *this;
}
FCellSerial& FCellSerial::operator=(FCellSerial&& other469) noexcept {
  c = std::move(other469.c);
  ts = other469.ts;
  v = std::move(other469.v);
  __isset = other469.__isset;
  return *this;
}
void FCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCellSerial(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FCells::~FCells() noexcept {
}


void FCells::__set_f(const std::map<std::string, FCells> & val) {
  this->f = val;
}

void FCells::__set_cells(const std::vector<FCell> & val) {
  this->cells = val;
}

void FCells::__set_serial_cells(const std::vector<FCellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const FCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->f.clear();
            uint32_t _size470;
            ::apache::thrift::protocol::TType _ktype471;
            ::apache::thrift::protocol::TType _vtype472;
            xfer += iprot->readMapBegin(_ktype471, _vtype472, _size470);
            uint32_t _i474;
            for (_i474 = 0; _i474 < _size470; ++_i474)
            {
              std::string _key475;
              xfer += iprot->readBinary(_key475);
              FCells& _val476 = this->f[_key475];
              xfer += _val476.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cells.clear();
            uint32_t _size477;
            ::apache::thrift::protocol::TType _etype480;
            xfer += iprot->readListBegin(_etype480, _size477);
            this->cells.resize(_size477);
            uint32_t _i481;
            for (_i481 = 0; _i481 < _size477; ++_i481)
            {
              xfer += this->cells[_i481].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size482;
            ::apache::thrift::protocol::TType _etype485;
            xfer += iprot->readListBegin(_etype485, _size482);
            this->serial_cells.resize(_size482);
            uint32_t _i486;
            for (_i486 = 0; _i486 < _size482; ++_i486)
            {
              xfer += this->serial_cells[_i486].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCells");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->f.size()));
    std::map<std::string, FCells> ::const_iterator _iter487;
    for (_iter487 = this->f.begin(); _iter487 != this->f.end(); ++_iter487)
    {
      xfer += oprot->writeBinary(_iter487->first);
      xfer += _iter487->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cells.size()));
    std::vector<FCell> ::const_iterator _iter488;
    for (_iter488 = this->cells.begin(); _iter488 != this->cells.end(); ++_iter488)
    {
      xfer += (*_iter488).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<FCellSerial> ::const_iterator _iter489;
    for (_iter489 = this->serial_cells.begin(); _iter489 != this->serial_cells.end(); ++_iter489)
    {
      xfer += (*_iter489).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCells &a, FCells &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.cells, b.cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

FCells::FCells(const FCells& other490) {
  f = other490.f;
  cells = other490.cells;
  serial_cells = other490.serial_cells;
  __isset = other490.__isset;
}
FCells::FCells(FCells&& other491) noexcept {
  f = std::move(other491.f);
  cells = std::move(other491.cells);
  serial_cells = std::move(other491.serial_cells);
  __isset = other491.__isset;
}
FCells& FCells::operator=(const FCells& other492) {
  f = other492.f;
  cells = other492.cells;
  serial_cells = other492.serial_cells;
  __isset = other492.__isset;
  return *this;
}
FCells& FCells::operator=(FCells&& other493) noexcept {
  f = std::move(other493.f);
  cells = std::move(other493.cells);
  serial_cells = std::move(other493.serial_cells);
  __isset = other493.__isset;
  return *this;
}
void FCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCells(";
  out << "f=" << to_string(f);
  out << ", " << "cells=" << to_string(cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


CellsGroup::~CellsGroup() noexcept {
}


void CellsGroup::__set_cells(const Cells& val) {
  this->cells = val;
}

void CellsGroup::__set_ccells(const CCells& val) {
  this->ccells = val;
}

void CellsGroup::__set_kcells(const KCells& val) {
  this->kcells = val;
}

void CellsGroup::__set_fcells(const FCells& val) {
  this->fcells = val;
}
std::ostream& operator<<(std::ostream& out, const CellsGroup& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellsGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cells.read(iprot);
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ccells.clear();
            uint32_t _size494;
            ::apache::thrift::protocol::TType _ktype495;
            ::apache::thrift::protocol::TType _vtype496;
            xfer += iprot->readMapBegin(_ktype495, _vtype496, _size494);
            uint32_t _i498;
            for (_i498 = 0; _i498 < _size494; ++_i498)
            {
              std::string _key499;
              xfer += iprot->readString(_key499);
              ColCells& _val500 = this->ccells[_key499];
              xfer += _val500.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ccells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->kcells.clear();
            uint32_t _size501;
            ::apache::thrift::protocol::TType _etype504;
            xfer += iprot->readListBegin(_etype504, _size501);
            this->kcells.resize(_size501);
            uint32_t _i505;
            for (_i505 = 0; _i505 < _size501; ++_i505)
            {
              xfer += this->kcells[_i505].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.kcells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fcells.read(iprot);
          this->__isset.fcells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellsGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellsGroup");

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cells.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ccells", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ccells.size()));
    std::map<std::string, ColCells> ::const_iterator _iter506;
    for (_iter506 = this->ccells.begin(); _iter506 != this->ccells.end(); ++_iter506)
    {
      xfer += oprot->writeString(_iter506->first);
      xfer += _iter506->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("kcells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->kcells.size()));
    std::vector<kCells> ::const_iterator _iter507;
    for (_iter507 = this->kcells.begin(); _iter507 != this->kcells.end(); ++_iter507)
    {
      xfer += (*_iter507).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fcells", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->fcells.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellsGroup &a, CellsGroup &b) {
  using ::std::swap;
  swap(a.cells, b.cells);
  swap(a.ccells, b.ccells);
  swap(a.kcells, b.kcells);
  swap(a.fcells, b.fcells);
  swap(a.__isset, b.__isset);
}

CellsGroup::CellsGroup(const CellsGroup& other508) {
  cells = other508.cells;
  ccells = other508.ccells;
  kcells = other508.kcells;
  fcells = other508.fcells;
  __isset = other508.__isset;
}
CellsGroup::CellsGroup(CellsGroup&& other509) noexcept {
  cells = std::move(other509.cells);
  ccells = std::move(other509.ccells);
  kcells = std::move(other509.kcells);
  fcells = std::move(other509.fcells);
  __isset = other509.__isset;
}
CellsGroup& CellsGroup::operator=(const CellsGroup& other510) {
  cells = other510.cells;
  ccells = other510.ccells;
  kcells = other510.kcells;
  fcells = other510.fcells;
  __isset = other510.__isset;
  return *this;
}
CellsGroup& CellsGroup::operator=(CellsGroup&& other511) noexcept {
  cells = std::move(other511.cells);
  ccells = std::move(other511.ccells);
  kcells = std::move(other511.kcells);
  fcells = std::move(other511.fcells);
  __isset = other511.__isset;
  return *this;
}
void CellsGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellsGroup(";
  out << "cells=" << to_string(cells);
  out << ", " << "ccells=" << to_string(ccells);
  out << ", " << "kcells=" << to_string(kcells);
  out << ", " << "fcells=" << to_string(fcells);
  out << ")";
}


CompactResult::~CompactResult() noexcept {
}


void CompactResult::__set_cid(const int64_t val) {
  this->cid = val;
}

void CompactResult::__set_err(const int32_t val) {
  this->err = val;
}
std::ostream& operator<<(std::ostream& out, const CompactResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->err);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CompactResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactResult");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->err);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactResult &a, CompactResult &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

CompactResult::CompactResult(const CompactResult& other512) noexcept {
  cid = other512.cid;
  err = other512.err;
  __isset = other512.__isset;
}
CompactResult::CompactResult(CompactResult&& other513) noexcept {
  cid = other513.cid;
  err = other513.err;
  __isset = other513.__isset;
}
CompactResult& CompactResult::operator=(const CompactResult& other514) noexcept {
  cid = other514.cid;
  err = other514.err;
  __isset = other514.__isset;
  return *this;
}
CompactResult& CompactResult::operator=(CompactResult&& other515) noexcept {
  cid = other515.cid;
  err = other515.err;
  __isset = other515.__isset;
  return *this;
}
void CompactResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactResult(";
  out << "cid=" << to_string(cid);
  out << ", " << "err=" << to_string(err);
  out << ")";
}


Result::~Result() noexcept {
}


void Result::__set_schemas(const Schemas& val) {
  this->schemas = val;
}

void Result::__set_cells(const Cells& val) {
  this->cells = val;
}

void Result::__set_compact(const CompactResults& val) {
  this->compact = val;
}
std::ostream& operator<<(std::ostream& out, const Result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->schemas.clear();
            uint32_t _size516;
            ::apache::thrift::protocol::TType _etype519;
            xfer += iprot->readListBegin(_etype519, _size516);
            this->schemas.resize(_size516);
            uint32_t _i520;
            for (_i520 = 0; _i520 < _size516; ++_i520)
            {
              xfer += this->schemas[_i520].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.schemas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cells.read(iprot);
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compact.clear();
            uint32_t _size521;
            ::apache::thrift::protocol::TType _etype524;
            xfer += iprot->readListBegin(_etype524, _size521);
            this->compact.resize(_size521);
            uint32_t _i525;
            for (_i525 = 0; _i525 < _size521; ++_i525)
            {
              xfer += this->compact[_i525].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.compact = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Result");

  xfer += oprot->writeFieldBegin("schemas", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->schemas.size()));
    std::vector<Schema> ::const_iterator _iter526;
    for (_iter526 = this->schemas.begin(); _iter526 != this->schemas.end(); ++_iter526)
    {
      xfer += (*_iter526).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->cells.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compact", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->compact.size()));
    std::vector<CompactResult> ::const_iterator _iter527;
    for (_iter527 = this->compact.begin(); _iter527 != this->compact.end(); ++_iter527)
    {
      xfer += (*_iter527).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Result &a, Result &b) {
  using ::std::swap;
  swap(a.schemas, b.schemas);
  swap(a.cells, b.cells);
  swap(a.compact, b.compact);
  swap(a.__isset, b.__isset);
}

Result::Result(const Result& other528) {
  schemas = other528.schemas;
  cells = other528.cells;
  compact = other528.compact;
  __isset = other528.__isset;
}
Result::Result(Result&& other529) noexcept {
  schemas = std::move(other529.schemas);
  cells = std::move(other529.cells);
  compact = std::move(other529.compact);
  __isset = other529.__isset;
}
Result& Result::operator=(const Result& other530) {
  schemas = other530.schemas;
  cells = other530.cells;
  compact = other530.compact;
  __isset = other530.__isset;
  return *this;
}
Result& Result::operator=(Result&& other531) noexcept {
  schemas = std::move(other531.schemas);
  cells = std::move(other531.cells);
  compact = std::move(other531.compact);
  __isset = other531.__isset;
  return *this;
}
void Result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Result(";
  out << "schemas=" << to_string(schemas);
  out << ", " << "cells=" << to_string(cells);
  out << ", " << "compact=" << to_string(compact);
  out << ")";
}

}} // namespace
